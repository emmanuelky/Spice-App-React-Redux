{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: react-moveable\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable\nversion: 0.29.0\n*/\nimport getAgent from '@egjs/agent';\nimport { prefixNames, ref, refs, withMethods, prefixCSS } from 'framework-utils';\nimport { getShapeDirection, getRad, hasClass, isUndefined, isString, isFunction, isObject, isArray, splitBracket, splitUnit, splitSpace, average, findIndex, throttle, find, getDist as getDist$1, throttleArray, convertUnitSize, calculateBoundSize, dot, addClass, removeClass, splitComma, removeEvent, getKeys, addEvent } from '@daybrush/utils';\nimport { plus, calculate, convertPositionMatrix, convertMatrixtoCSS, invert, createIdentityMatrix, multiplies, createOriginMatrix, convertDimension, multiply, ignoreDimension, minus, convertCSStoMatrix, createScaleMatrix, getOrigin, fromTranslation, rotate, createRotateMatrix, createWarpMatrix } from '@scena/matrix';\nimport { toMat, calculateMatrixDist, parse, parseMat } from 'css-to-mat';\nimport { getMinMaxs, fitPoints, getOverlapSize, getAreaSize, isInside } from 'overlap-area';\nimport ChildrenDiffer, { diff } from '@egjs/children-differ';\nimport DragScroll from '@scena/dragscroll';\nimport { createElement, PureComponent } from 'react';\nimport Gesto from 'gesto';\nimport styled from 'react-css-styled';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n}\n\nfunction makeAble(name, able) {\n  var _a;\n\n  return _assign({\n    events: {},\n    props: (_a = {}, _a[name] = Boolean, _a),\n    name: name\n  }, able);\n}\n\nfunction getSVGCursor(scale, degree) {\n  return \"data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"\" + 32 * scale + \"px\\\" height=\\\"\" + 32 * scale + \"px\\\" viewBox=\\\"0 0 32 32\\\" ><path d=\\\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"1.2\\\" fill=\\\"black\\\" stroke=\\\"white\\\" style=\\\"transform:rotate(\" + degree + \"deg);transform-origin: 16px 16px\\\"></path></svg>\";\n}\n\nfunction getCursorCSS(degree) {\n  var x1 = getSVGCursor(1, degree);\n  var x2 = getSVGCursor(2, degree);\n  var degree45 = Math.round(degree / 45) * 45 % 180;\n  var defaultCursor = \"ns-resize\";\n\n  if (degree45 === 135) {\n    defaultCursor = \"nwse-resize\";\n  } else if (degree45 === 45) {\n    defaultCursor = \"nesw-resize\";\n  } else if (degree45 === 90) {\n    defaultCursor = \"ew-resize\";\n  } // tslint:disable-next-line: max-line-length\n\n\n  return \"cursor:\" + defaultCursor + \";cursor: url('\" + x1 + \"') 16 16, \" + defaultCursor + \";cursor: -webkit-image-set(url('\" + x1 + \"') 1x, url('\" + x2 + \"') 2x) 16 16, \" + defaultCursor + \";\";\n}\n\nvar agent = getAgent();\nvar IS_WEBKIT = agent.browser.webkit;\n\nvar IS_WEBKIT605 = IS_WEBKIT && function () {\n  var res = /applewebkit\\/([^\\s]+)/g.exec(navigator.userAgent.toLowerCase());\n  return res ? parseFloat(res[1]) < 605 : false;\n}();\n\nvar PREFIX = \"moveable-\";\nvar MOVEABLE_CSS = \"\\n{\\n\\tposition: absolute;\\n\\twidth: 1px;\\n\\theight: 1px;\\n\\tleft: 0;\\n\\ttop: 0;\\n    z-index: 3000;\\n    --moveable-color: #4af;\\n    --zoom: 1;\\n    --zoompx: 1px;\\n    will-change: transform;\\n}\\n.control-box {\\n    z-index: 0;\\n}\\n.line, .control {\\n    position: absolute;\\n\\tleft: 0;\\n    top: 0;\\n    will-change: transform;\\n}\\n.control {\\n\\twidth: 14px;\\n\\theight: 14px;\\n\\tborder-radius: 50%;\\n\\tborder: 2px solid #fff;\\n\\tbox-sizing: border-box;\\n    background: #4af;\\n    background: var(--moveable-color);\\n\\tmargin-top: -7px;\\n    margin-left: -7px;\\n    border: 2px solid #fff;\\n    z-index: 10;\\n}\\n.padding {\\n    position: absolute;\\n    top: 0px;\\n    left: 0px;\\n    width: 100px;\\n    height: 100px;\\n    transform-origin: 0 0;\\n}\\n.line {\\n\\twidth: 1px;\\n    height: 1px;\\n    background: #4af;\\n    background: var(--moveable-color);\\n\\ttransform-origin: 0px 50%;\\n}\\n.line.dashed {\\n    box-sizing: border-box;\\n    background: transparent;\\n}\\n.line.dashed.horizontal {\\n    border-top: 1px dashed #4af;\\n    border-top-color: #4af;\\n    border-top-color: var(--moveable-color);\\n}\\n.line.dashed.vertical {\\n    border-left: 1px dashed #4af;\\n    border-left-color: #4af;\\n    border-left-color: var(--moveable-color);\\n}\\n.line.vertical {\\n    transform: translateX(-50%);\\n}\\n.line.horizontal {\\n    transform: translateY(-50%);\\n}\\n.line.vertical.bold {\\n    width: 2px;\\n}\\n.line.horizontal.bold {\\n    height: 2px;\\n}\\n\\n.control.origin {\\n\\tborder-color: #f55;\\n\\tbackground: #fff;\\n\\twidth: 12px;\\n\\theight: 12px;\\n\\tmargin-top: -6px;\\n    margin-left: -6px;\\n\\tpointer-events: none;\\n}\\n\" + [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (degree) {\n  return \"\\n.direction[data-rotation=\\\"\" + degree + \"\\\"] {\\n\\t\" + getCursorCSS(degree) + \"\\n}\\n\";\n}).join(\"\\n\") + \"\\n.group {\\n    z-index: -1;\\n}\\n.area {\\n    position: absolute;\\n}\\n.area-pieces {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    display: none;\\n}\\n.area.avoid, .area.pass {\\n    pointer-events: none;\\n}\\n.area.avoid+.area-pieces {\\n    display: block;\\n}\\n.area-piece {\\n    position: absolute;\\n}\\n\\n\" + (IS_WEBKIT605 ? \":global svg *:before {\\n\\tcontent:\\\"\\\";\\n\\ttransform-origin: inherit;\\n}\" : \"\") + \"\\n\";\nvar NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];\nvar FLOAT_POINT_NUM = 0.0001;\nvar TINY_NUM = 0.0000001;\nvar MIN_SCALE = 0.000000001;\nvar MAX_NUM = Math.pow(10, 10);\nvar MIN_NUM = -MAX_NUM;\nvar DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\nvar DIRECTION_INDEXES = {\n  n: [0, 1],\n  s: [2, 3],\n  w: [2, 0],\n  e: [1, 3],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n};\nvar DIRECTION_ROTATIONS = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n};\nvar MOVEABLE_METHODS = [\"isMoveableElement\", \"updateRect\", \"updateTarget\", \"destroy\", \"dragStart\", \"isInside\", \"hitTest\", \"setState\", \"getRect\", \"request\", \"isDragging\", \"getManager\"];\n\nfunction multiply2(pos1, pos2) {\n  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];\n}\n\nfunction prefix() {\n  var classNames = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    classNames[_i] = arguments[_i];\n  }\n\n  return prefixNames.apply(void 0, __spreadArrays([PREFIX], classNames));\n}\n\nfunction getTransformMatrix(transform) {\n  if (!transform || transform === \"none\") {\n    return [1, 0, 0, 1, 0, 0];\n  }\n\n  if (isObject(transform)) {\n    return transform;\n  }\n\n  var value = splitBracket(transform).value;\n  return value.split(/s*,\\s*/g).map(function (v) {\n    return parseFloat(v);\n  });\n}\n\nfunction getAbsoluteMatrix(matrix, n, origin) {\n  return multiplies(n, createOriginMatrix(origin, n), matrix, createOriginMatrix(origin.map(function (a) {\n    return -a;\n  }), n));\n}\n\nfunction measureSVGSize(el, unit, isHorizontal) {\n  if (unit === \"%\") {\n    var viewBox = getSVGViewBox(el.ownerSVGElement);\n    return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n  }\n\n  return 1;\n}\n\nfunction getBeforeTransformOrigin(el) {\n  var relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n  return relativeOrigin.map(function (o, i) {\n    var _a = splitUnit(o),\n        value = _a.value,\n        unit = _a.unit;\n\n    return value * measureSVGSize(el, unit, i === 0);\n  });\n}\n\nfunction getTransformOrigin(style) {\n  var transformOrigin = style.transformOrigin;\n  return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\n\nfunction getOffsetInfo(el, lastParent, isParent) {\n  var body = document.body;\n  var target = !el || isParent ? el : el.parentElement;\n  var isEnd = el === lastParent || target === lastParent;\n  var position = \"relative\";\n\n  while (target && target !== body) {\n    if (lastParent === target) {\n      isEnd = true;\n    }\n\n    var style = getComputedStyle(target);\n    var transform = style.transform;\n    position = style.position;\n\n    if (target.tagName.toLowerCase() === \"svg\" || position !== \"static\" || transform && transform !== \"none\") {\n      break;\n    }\n\n    target = target.parentElement;\n    position = \"relative\";\n  }\n\n  return {\n    isStatic: position === \"static\",\n    isEnd: isEnd || !target || target === body,\n    offsetParent: target || body\n  };\n}\n\nfunction getOffsetPosInfo(el, container, style, isFixed) {\n  var _a;\n\n  var tagName = el.tagName.toLowerCase();\n  var offsetLeft = el.offsetLeft;\n  var offsetTop = el.offsetTop;\n\n  if (isFixed) {\n    var containerClientRect = (container || document.documentElement).getBoundingClientRect();\n    offsetLeft -= containerClientRect.left;\n    offsetTop -= containerClientRect.top;\n  } // svg\n\n\n  var isSVG = isUndefined(offsetLeft);\n  var hasOffset = !isSVG;\n  var origin;\n  var targetOrigin; // inner svg element\n\n  if (!hasOffset && tagName !== \"svg\") {\n    origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function (pos) {\n      return parseFloat(pos);\n    });\n    targetOrigin = origin.slice();\n    hasOffset = true;\n    _a = getSVGGraphicsOffset(el, origin), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];\n  } else {\n    origin = getTransformOrigin(style).map(function (pos) {\n      return parseFloat(pos);\n    });\n    targetOrigin = origin.slice();\n  }\n\n  return {\n    tagName: tagName,\n    isSVG: isSVG,\n    hasOffset: hasOffset,\n    offset: [offsetLeft || 0, offsetTop || 0],\n    origin: origin,\n    targetOrigin: targetOrigin\n  };\n}\n\nfunction getBodyOffset(el, isSVG, style) {\n  if (style === void 0) {\n    style = getComputedStyle(el);\n  }\n\n  var bodyStyle = getComputedStyle(document.body);\n  var bodyPosition = bodyStyle.position;\n\n  if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\n    return [0, 0];\n  }\n\n  var marginLeft = parseInt(bodyStyle.marginLeft, 10);\n  var marginTop = parseInt(bodyStyle.marginTop, 10);\n\n  if (style.position === \"absolute\") {\n    if (style.top !== \"auto\" || style.bottom !== \"auto\") {\n      marginTop = 0;\n    }\n\n    if (style.left !== \"auto\" || style.right !== \"auto\") {\n      marginLeft = 0;\n    }\n  }\n\n  return [marginLeft, marginTop];\n}\n\nfunction convert3DMatrixes(matrixes) {\n  matrixes.forEach(function (info) {\n    var matrix = info.matrix;\n\n    if (matrix) {\n      info.matrix = convertDimension(matrix, 3, 4);\n    }\n  });\n}\n\nfunction getMatrixStackInfo(target, container) {\n  var el = target;\n  var matrixes = [];\n  var isEnd = target === container;\n  var is3d = false;\n  var n = 3;\n  var transformOrigin;\n  var targetTransformOrigin;\n  var targetMatrix;\n  var offsetContainer = getOffsetInfo(container, container, true).offsetParent; // if (prevMatrix) {\n  //     isEnd = target === container;\n  //     if (prevMatrix.length > 10) {\n  //         is3d = true;\n  //         n = 4;\n  //     }\n  //     container = target.parentElement;\n  // }\n\n  while (el && !isEnd) {\n    var style = getComputedStyle(el);\n    var position = style.position;\n    var isFixed = position === \"fixed\";\n    var matrix = convertCSStoMatrix(getTransformMatrix(style.transform)); // convert 3 to 4\n\n    var length = matrix.length;\n\n    if (!is3d && length === 16) {\n      is3d = true;\n      n = 4;\n      convert3DMatrixes(matrixes);\n    }\n\n    if (is3d && length === 9) {\n      matrix = convertDimension(matrix, 3, 4);\n    }\n\n    var _a = getOffsetPosInfo(el, container, style, isFixed),\n        tagName = _a.tagName,\n        hasOffset = _a.hasOffset,\n        isSVG = _a.isSVG,\n        origin = _a.origin,\n        targetOrigin = _a.targetOrigin,\n        offsetPos = _a.offset;\n\n    var offsetLeft = offsetPos[0],\n        offsetTop = offsetPos[1];\n\n    if (tagName === \"svg\" && targetMatrix) {\n      // scale matrix for svg's SVGElements.\n      matrixes.push({\n        type: \"target\",\n        target: el,\n        matrix: getSVGMatrix(el, n)\n      });\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        matrix: createIdentityMatrix(n)\n      });\n    } else if (tagName === \"g\" && target !== el) {\n      offsetLeft = 0;\n      offsetTop = 0;\n    }\n\n    var _b = getOffsetInfo(el, container),\n        offsetParent = _b.offsetParent,\n        isOffsetEnd = _b.isEnd,\n        isStatic = _b.isStatic;\n\n    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === \"relative\" || position === \"static\")) {\n      offsetLeft -= offsetParent.offsetLeft;\n      offsetTop -= offsetParent.offsetTop;\n      isEnd = isEnd || isOffsetEnd;\n    }\n\n    var parentClientLeft = 0;\n    var parentClientTop = 0;\n\n    if (hasOffset && offsetContainer !== offsetParent) {\n      // border\n      parentClientLeft = offsetParent.clientLeft;\n      parentClientTop = offsetParent.clientTop;\n    }\n\n    if (hasOffset && offsetParent === document.body) {\n      var margin = getBodyOffset(el, false, style);\n      offsetLeft += margin[0];\n      offsetTop += margin[1];\n    }\n\n    matrixes.push({\n      type: \"target\",\n      target: el,\n      matrix: getAbsoluteMatrix(matrix, n, origin)\n    });\n\n    if (hasOffset) {\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        matrix: createOriginMatrix([offsetLeft - el.scrollLeft + parentClientLeft, offsetTop - el.scrollTop + parentClientTop], n)\n      });\n    } else {\n      // svg\n      matrixes.push({\n        type: \"offset\",\n        target: el,\n        origin: origin\n      });\n    }\n\n    if (!targetMatrix) {\n      targetMatrix = matrix;\n    }\n\n    if (!transformOrigin) {\n      transformOrigin = origin;\n    }\n\n    if (!targetTransformOrigin) {\n      targetTransformOrigin = targetOrigin;\n    }\n\n    if (isEnd || isFixed) {\n      break;\n    } else {\n      el = offsetParent;\n      isEnd = isOffsetEnd;\n    }\n  }\n\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(n);\n  }\n\n  if (!transformOrigin) {\n    transformOrigin = [0, 0];\n  }\n\n  if (!targetTransformOrigin) {\n    targetTransformOrigin = [0, 0];\n  }\n\n  return {\n    offsetContainer: offsetContainer,\n    matrixes: matrixes,\n    targetMatrix: targetMatrix,\n    transformOrigin: transformOrigin,\n    targetOrigin: targetTransformOrigin,\n    is3d: is3d\n  };\n}\n\nfunction calculateElementInfo(target, container, rootContainer, isAbsolute3d) {\n  var _a;\n\n  if (rootContainer === void 0) {\n    rootContainer = container;\n  } // const prevMatrix = state ? state.beforeMatrix : undefined;\n  // const prevRootMatrix = state ? state.rootMatrix : undefined;\n  // const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n\n\n  var width = 0;\n  var height = 0;\n  var rotation = 0;\n  var allResult = {};\n\n  if (target) {\n    var style = getComputedStyle(target);\n    width = target.offsetWidth;\n    height = target.offsetHeight;\n\n    if (isUndefined(width)) {\n      _a = getSize(target, style, true), width = _a[0], height = _a[1];\n    }\n  }\n\n  if (target) {\n    var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);\n    var position = calculateMoveablePosition(result.allMatrix, result.transformOrigin, width, height);\n    allResult = _assign(_assign({}, result), position);\n    var rotationPosition = calculateMoveablePosition(result.allMatrix, [50, 50], 100, 100);\n    rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);\n  }\n\n  var n = isAbsolute3d ? 4 : 3;\n  return _assign({\n    width: width,\n    height: height,\n    rotation: rotation,\n    // rootMatrix: number[];\n    // beforeMatrix: number[];\n    // offsetMatrix: number[];\n    // allMatrix: number[];\n    // targetMatrix: number[];\n    // targetTransform: string;\n    // transformOrigin: number[];\n    // targetOrigin: number[];\n    // is3d: boolean;\n    rootMatrix: createIdentityMatrix(n),\n    beforeMatrix: createIdentityMatrix(n),\n    offsetMatrix: createIdentityMatrix(n),\n    allMatrix: createIdentityMatrix(n),\n    targetMatrix: createIdentityMatrix(n),\n    targetTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!isAbsolute3d,\n    // left: number;\n    // top: number;\n    // right: number;\n    // bottom: number;\n    // origin: number[];\n    // pos1: number[];\n    // pos2: number[];\n    // pos3: number[];\n    // pos4: number[];\n    // direction: 1 | -1;\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1\n  }, allResult);\n}\n\nfunction getElementInfo(target, container, rootContainer) {\n  if (rootContainer === void 0) {\n    rootContainer = container;\n  }\n\n  return calculateElementInfo(target, container, rootContainer, true);\n}\n\nfunction calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {\n  if (rootContainer === void 0) {\n    rootContainer = container;\n  }\n\n  var _a = getMatrixStackInfo(target, container),\n      matrixes = _a.matrixes,\n      is3d = _a.is3d,\n      prevTargetMatrix = _a.targetMatrix,\n      transformOrigin = _a.transformOrigin,\n      targetOrigin = _a.targetOrigin,\n      offsetContainer = _a.offsetContainer; // prevMatrix\n\n\n  var _b = getMatrixStackInfo(offsetContainer, rootContainer),\n      rootMatrixes = _b.matrixes,\n      isRoot3d = _b.is3d; // prevRootMatrix\n  // if (rootContainer === document.body) {\n  //     console.log(offsetContainer, rootContainer, rootMatrixes);\n  // }\n\n\n  var isNext3d = isAbsolute3d || isRoot3d || is3d;\n  var n = isNext3d ? 4 : 3;\n  var isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n  var targetMatrix = prevTargetMatrix; // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n  // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n  // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n\n  var allMatrix = createIdentityMatrix(n);\n  var rootMatrix = createIdentityMatrix(n);\n  var beforeMatrix = createIdentityMatrix(n);\n  var offsetMatrix = createIdentityMatrix(n);\n  var length = matrixes.length;\n  var originalRootContainer = rootContainer || document.body;\n  var endContainer = getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;\n  rootMatrixes.reverse();\n  matrixes.reverse();\n\n  if (!is3d && isNext3d) {\n    targetMatrix = convertDimension(targetMatrix, 3, 4);\n    convert3DMatrixes(matrixes);\n  }\n\n  if (!isRoot3d && isNext3d) {\n    convert3DMatrixes(rootMatrixes);\n  } // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n  // if (!prevRootMatrix) {\n\n\n  rootMatrixes.forEach(function (info) {\n    rootMatrix = multiply(rootMatrix, info.matrix, n);\n  }); // }\n\n  matrixes.forEach(function (info, i) {\n    if (length - 2 === i) {\n      // length - 3\n      beforeMatrix = allMatrix.slice();\n    }\n\n    if (length - 1 === i) {\n      // length - 2\n      offsetMatrix = allMatrix.slice();\n    } // calculate for SVGElement\n\n\n    if (!info.matrix) {\n      var nextInfo = matrixes[i + 1];\n      var offset = getSVGOffset(info, nextInfo, endContainer, n, multiply(rootMatrix, allMatrix, n));\n      info.matrix = createOriginMatrix(offset, n);\n    }\n\n    allMatrix = multiply(allMatrix, info.matrix, n);\n  });\n  var isMatrix3d = !isSVGGraphicElement && is3d;\n\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n  }\n\n  var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? convertDimension(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);\n  rootMatrix = ignoreDimension(rootMatrix, n, n);\n  return {\n    rootMatrix: rootMatrix,\n    beforeMatrix: beforeMatrix,\n    offsetMatrix: offsetMatrix,\n    allMatrix: allMatrix,\n    targetMatrix: targetMatrix,\n    targetTransform: targetTransform,\n    transformOrigin: transformOrigin,\n    targetOrigin: targetOrigin,\n    is3d: isNext3d\n  };\n}\n\nfunction makeMatrixCSS(matrix, is3d) {\n  if (is3d === void 0) {\n    is3d = matrix.length > 9;\n  }\n\n  return (is3d ? \"matrix3d\" : \"matrix\") + \"(\" + convertMatrixtoCSS(matrix, !is3d).join(\",\") + \")\";\n}\n\nfunction getSVGViewBox(el) {\n  var clientWidth = el.clientWidth;\n  var clientHeight = el.clientHeight;\n\n  if (!el) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      clientWidth: clientWidth,\n      clientHeight: clientHeight\n    };\n  }\n\n  var viewBox = el.viewBox;\n  var baseVal = viewBox && viewBox.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: baseVal.x,\n    y: baseVal.y,\n    width: baseVal.width || clientWidth,\n    height: baseVal.height || clientHeight,\n    clientWidth: clientWidth,\n    clientHeight: clientHeight\n  };\n}\n\nfunction getSVGMatrix(el, n) {\n  var _a = getSVGViewBox(el),\n      viewBoxWidth = _a.width,\n      viewBoxHeight = _a.height,\n      clientWidth = _a.clientWidth,\n      clientHeight = _a.clientHeight;\n\n  var scaleX = clientWidth / viewBoxWidth;\n  var scaleY = clientHeight / viewBoxHeight;\n  var preserveAspectRatio = el.preserveAspectRatio.baseVal; // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n\n  var align = preserveAspectRatio.align; // 1 : meet 2: slice\n\n  var meetOrSlice = preserveAspectRatio.meetOrSlice;\n  var svgOrigin = [0, 0];\n  var scale = [scaleX, scaleY];\n  var translate = [0, 0];\n\n  if (align !== 1) {\n    var xAlign = (align - 2) % 3;\n    var yAlign = Math.floor((align - 2) / 3);\n    svgOrigin[0] = viewBoxWidth * xAlign / 2;\n    svgOrigin[1] = viewBoxHeight * yAlign / 2;\n    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n    scale[0] = scaleDimension;\n    scale[1] = scaleDimension;\n    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n  }\n\n  var scaleMatrix = createScaleMatrix(scale, n);\n  scaleMatrix[n * (n - 1)] = translate[0], scaleMatrix[n * (n - 1) + 1] = translate[1];\n  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);\n}\n\nfunction getSVGGraphicsOffset(el, origin) {\n  if (!el.getBBox) {\n    return [0, 0];\n  }\n\n  var bbox = el.getBBox();\n  var viewBox = getSVGViewBox(el.ownerSVGElement);\n  var left = bbox.x - viewBox.x;\n  var top = bbox.y - viewBox.y;\n  return [left, top, origin[0] - left, origin[1] - top];\n}\n\nfunction calculatePosition(matrix, pos, n) {\n  return calculate(matrix, convertPositionMatrix(pos, n), n);\n}\n\nfunction calculatePoses(matrix, width, height, n) {\n  return [[0, 0], [width, 0], [0, height], [width, height]].map(function (pos) {\n    return calculatePosition(matrix, pos, n);\n  });\n}\n\nfunction getRect(poses) {\n  var posesX = poses.map(function (pos) {\n    return pos[0];\n  });\n  var posesY = poses.map(function (pos) {\n    return pos[1];\n  });\n  var left = Math.min.apply(Math, posesX);\n  var top = Math.min.apply(Math, posesY);\n  var right = Math.max.apply(Math, posesX);\n  var bottom = Math.max.apply(Math, posesY);\n  var rectWidth = right - left;\n  var rectHeight = bottom - top;\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    width: rectWidth,\n    height: rectHeight\n  };\n}\n\nfunction calculateRect(matrix, width, height, n) {\n  var poses = calculatePoses(matrix, width, height, n);\n  return getRect(poses);\n}\n\nfunction getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {\n  var _a;\n\n  var target = offsetInfo.target;\n  var origin = offsetInfo.origin;\n  var targetMatrix = targetInfo.matrix;\n\n  var _b = getSize(target, undefined, true),\n      width = _b[0],\n      height = _b[1];\n\n  var containerClientRect = container.getBoundingClientRect();\n  var margin = [0, 0];\n\n  if (container === document.body) {\n    margin = getBodyOffset(target, true);\n  }\n\n  var rect = target.getBoundingClientRect();\n  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];\n  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n  var mat = multiplies(n, beforeMatrix, targetMatrix);\n\n  var _c = calculateRect(mat, width, height, n),\n      prevLeft = _c.left,\n      prevTop = _c.top,\n      prevWidth = _c.width,\n      prevHeight = _c.height;\n\n  var posOrigin = calculatePosition(mat, origin, n);\n  var prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];\n  var offset = [0, 0];\n  var count = 0;\n\n  while (++count < 10) {\n    var inverseBeforeMatrix = invert(beforeMatrix, n);\n    _a = minus(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a[0], offset[1] = _a[1];\n    var mat2 = multiplies(n, beforeMatrix, createOriginMatrix(offset, n), targetMatrix);\n\n    var _d = calculateRect(mat2, width, height, n),\n        nextLeft = _d.left,\n        nextTop = _d.top;\n\n    var distLeft = nextLeft - rectLeft;\n    var distTop = nextTop - rectTop;\n\n    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n      break;\n    }\n\n    rectOrigin[0] -= distLeft;\n    rectOrigin[1] -= distTop;\n  }\n\n  return offset.map(function (p) {\n    return Math.round(p);\n  });\n}\n\nfunction calculateMoveablePosition(matrix, origin, width, height) {\n  var is3d = matrix.length === 16;\n  var n = is3d ? 4 : 3;\n  var poses = calculatePoses(matrix, width, height, n);\n  var _a = poses[0],\n      x1 = _a[0],\n      y1 = _a[1],\n      _b = poses[1],\n      x2 = _b[0],\n      y2 = _b[1],\n      _c = poses[2],\n      x3 = _c[0],\n      y3 = _c[1],\n      _d = poses[3],\n      x4 = _d[0],\n      y4 = _d[1];\n\n  var _e = calculatePosition(matrix, origin, n),\n      originX = _e[0],\n      originY = _e[1];\n\n  var left = Math.min(x1, x2, x3, x4);\n  var top = Math.min(y1, y2, y3, y4);\n  var right = Math.max(x1, x2, x3, x4);\n  var bottom = Math.max(y1, y2, y3, y4);\n  x1 = x1 - left || 0;\n  x2 = x2 - left || 0;\n  x3 = x3 - left || 0;\n  x4 = x4 - left || 0;\n  y1 = y1 - top || 0;\n  y2 = y2 - top || 0;\n  y3 = y3 - top || 0;\n  y4 = y4 - top || 0;\n  originX = originX - left || 0;\n  originY = originY - top || 0;\n  var direction = getShapeDirection(poses);\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    origin: [originX, originY],\n    pos1: [x1, y1],\n    pos2: [x2, y2],\n    pos3: [x3, y3],\n    pos4: [x4, y4],\n    direction: direction\n  };\n}\n\nfunction getDistSize(vec) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\n\nfunction getDiagonalSize(pos1, pos2) {\n  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);\n}\n\nfunction getLineStyle(pos1, pos2, zoom, rad) {\n  if (zoom === void 0) {\n    zoom = 1;\n  }\n\n  if (rad === void 0) {\n    rad = getRad(pos1, pos2);\n  }\n\n  var width = getDiagonalSize(pos1, pos2);\n  return {\n    transform: \"translateY(-50%) translate(\" + pos1[0] + \"px, \" + pos1[1] + \"px) rotate(\" + rad + \"rad) scaleY(\" + zoom + \")\",\n    width: width + \"px\"\n  };\n}\n\nfunction getControlTransform(rotation, zoom) {\n  var poses = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    poses[_i - 2] = arguments[_i];\n  }\n\n  var length = poses.length;\n  var x = poses.reduce(function (prev, pos) {\n    return prev + pos[0];\n  }, 0) / length;\n  var y = poses.reduce(function (prev, pos) {\n    return prev + pos[1];\n  }, 0) / length;\n  return {\n    transform: \"translateZ(0px) translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"rad) scale(\" + zoom + \")\"\n  };\n}\n\nfunction getCSSSize(target) {\n  var style = getComputedStyle(target);\n  return [parseFloat(style.width), parseFloat(style.height)];\n}\n\nfunction getSize(target, style, isOffset, isBoxSizing) {\n  if (style === void 0) {\n    style = getComputedStyle(target);\n  }\n\n  if (isBoxSizing === void 0) {\n    isBoxSizing = isOffset || style.boxSizing === \"border-box\";\n  }\n\n  var width = target.offsetWidth;\n  var height = target.offsetHeight;\n  var hasOffset = !isUndefined(width);\n\n  if ((isOffset || isBoxSizing) && hasOffset) {\n    return [width, height];\n  }\n\n  if (!hasOffset && target.tagName.toLowerCase() !== \"svg\") {\n    var bbox = target.getBBox();\n    return [bbox.width, bbox.height];\n  }\n\n  width = target.clientWidth;\n  height = target.clientHeight;\n\n  if (isOffset || isBoxSizing) {\n    var borderLeft = parseFloat(style.borderLeftWidth) || 0;\n    var borderRight = parseFloat(style.borderRightWidth) || 0;\n    var borderTop = parseFloat(style.borderTopWidth) || 0;\n    var borderBottom = parseFloat(style.borderBottomWidth) || 0;\n    return [width + borderLeft + borderRight, height + borderTop + borderBottom];\n  } else {\n    var paddingLeft = parseFloat(style.paddingLeft) || 0;\n    var paddingRight = parseFloat(style.paddingRight) || 0;\n    var paddingTop = parseFloat(style.paddingTop) || 0;\n    var paddingBottom = parseFloat(style.paddingBottom) || 0;\n    return [width - paddingLeft - paddingRight, height - paddingTop - paddingBottom];\n  }\n}\n\nfunction getRotationRad(poses, direction) {\n  return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\n\nfunction getTargetInfo(moveableElement, target, container, parentContainer, rootContainer) {\n  var beforeDirection = 1;\n  var beforeOrigin = [0, 0];\n  var targetClientRect = resetClientRect();\n  var containerClientRect = resetClientRect();\n  var moveableClientRect = resetClientRect();\n  var result = calculateElementInfo(target, container, rootContainer, false);\n\n  if (target) {\n    var n = result.is3d ? 4 : 3;\n    var beforePosition = calculateMoveablePosition(result.offsetMatrix, plus(result.transformOrigin, getOrigin(result.targetMatrix, n)), result.width, result.height);\n    beforeDirection = beforePosition.direction;\n    beforeOrigin = plus(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);\n    targetClientRect = getClientRect(target);\n    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);\n\n    if (moveableElement) {\n      moveableClientRect = getClientRect(moveableElement);\n    }\n  }\n\n  return _assign({\n    targetClientRect: targetClientRect,\n    containerClientRect: containerClientRect,\n    moveableClientRect: moveableClientRect,\n    beforeDirection: beforeDirection,\n    beforeOrigin: beforeOrigin,\n    originalBeforeOrigin: beforeOrigin,\n    target: target\n  }, result);\n}\n\nfunction resetClientRect() {\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    width: 0,\n    height: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\n\nfunction getClientRect(el, isExtends) {\n  var left = 0;\n  var top = 0;\n  var width = 0;\n  var height = 0;\n\n  if (el === document.body || el === document.documentElement) {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    left = -(document.documentElement.scrollLeft || document.body.scrollLeft);\n    top = -(document.documentElement.scrollTop || document.body.scrollTop);\n  } else {\n    var clientRect = el.getBoundingClientRect();\n    left = clientRect.left;\n    top = clientRect.top;\n    width = clientRect.width;\n    height = clientRect.height;\n  }\n\n  var rect = {\n    left: left,\n    right: left + width,\n    top: top,\n    bottom: top + height,\n    width: width,\n    height: height\n  };\n\n  if (isExtends) {\n    rect.clientLeft = el.clientLeft;\n    rect.clientTop = el.clientTop;\n    rect.clientWidth = el.clientWidth;\n    rect.clientHeight = el.clientHeight;\n    rect.scrollWidth = el.scrollWidth;\n    rect.scrollHeight = el.scrollHeight;\n    rect.overflow = getComputedStyle(el).overflow !== \"visible\";\n  }\n\n  return rect;\n}\n\nfunction getDirection(target) {\n  if (!target) {\n    return;\n  }\n\n  var direciton = target.getAttribute(\"data-direction\");\n\n  if (!direciton) {\n    return;\n  }\n\n  var dir = [0, 0];\n  direciton.indexOf(\"w\") > -1 && (dir[0] = -1);\n  direciton.indexOf(\"e\") > -1 && (dir[0] = 1);\n  direciton.indexOf(\"n\") > -1 && (dir[1] = -1);\n  direciton.indexOf(\"s\") > -1 && (dir[1] = 1);\n  return dir;\n}\n\nfunction getAbsolutePoses(poses, dist) {\n  return [plus(dist, poses[0]), plus(dist, poses[1]), plus(dist, poses[2]), plus(dist, poses[3])];\n}\n\nfunction getAbsolutePosesByState(_a) {\n  var left = _a.left,\n      top = _a.top,\n      pos1 = _a.pos1,\n      pos2 = _a.pos2,\n      pos3 = _a.pos3,\n      pos4 = _a.pos4;\n  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\n\nfunction roundSign(num) {\n  return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\n\nfunction unset(self, name) {\n  if (self[name]) {\n    self[name].unset();\n    self[name] = null;\n  }\n}\n\nfunction fillParams(moveable, e, params) {\n  var datas = e.datas;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n\n  var nextParams = _assign(_assign({}, params), {\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    moveable: moveable,\n    datas: datas.datas\n  });\n\n  if (datas.isStartEvent) {\n    datas.lastEvent = nextParams;\n  } else {\n    datas.isStartEvent = true;\n  }\n\n  return nextParams;\n}\n\nfunction fillEndParams(moveable, e, params) {\n  var datas = e.datas;\n  var isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n\n  return _assign(_assign({\n    isDrag: isDrag\n  }, params), {\n    moveable: moveable,\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    lastEvent: datas.lastEvent,\n    isDouble: e.isDouble,\n    datas: datas.datas\n  });\n}\n\nfunction triggerEvent(moveable, name, params, isManager) {\n  return moveable.triggerEvent(name, params, isManager);\n}\n\nfunction getComputedStyle(el, pseudoElt) {\n  return window.getComputedStyle(el, pseudoElt);\n}\n\nfunction filterAbles(ables, methods, triggerAblesSimultaneously) {\n  var enabledAbles = {};\n  var ableGroups = {};\n  return ables.filter(function (able) {\n    var name = able.name;\n\n    if (enabledAbles[name] || !methods.some(function (method) {\n      return able[method];\n    })) {\n      return false;\n    }\n\n    if (!triggerAblesSimultaneously && able.ableGroup) {\n      if (ableGroups[able.ableGroup]) {\n        return false;\n      }\n\n      ableGroups[able.ableGroup] = true;\n    }\n\n    enabledAbles[name] = true;\n    return true;\n  });\n}\n\nfunction equals(a1, a2) {\n  return a1 === a2 || a1 == null && a2 == null;\n}\n\nfunction selectValue() {\n  var values = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    values[_i] = arguments[_i];\n  }\n\n  var length = values.length - 1;\n\n  for (var i = 0; i < length; ++i) {\n    var value = values[i];\n\n    if (!isUndefined(value)) {\n      return value;\n    }\n  }\n\n  return values[length];\n}\n\nfunction groupBy(arr, func) {\n  var groups = [];\n  var groupKeys = [];\n  arr.forEach(function (el, index) {\n    var groupKey = func(el, index, arr);\n    var keyIndex = groupKeys.indexOf(groupKey);\n    var group = groups[keyIndex] || [];\n\n    if (keyIndex === -1) {\n      groupKeys.push(groupKey);\n      groups.push(group);\n    }\n\n    group.push(el);\n  });\n  return groups;\n}\n\nfunction groupByMap(arr, func) {\n  var groups = [];\n  var groupKeys = {};\n  arr.forEach(function (el, index) {\n    var groupKey = func(el, index, arr);\n    var group = groupKeys[groupKey];\n\n    if (!group) {\n      group = [];\n      groupKeys[groupKey] = group;\n      groups.push(group);\n    }\n\n    group.push(el);\n  });\n  return groups;\n}\n\nfunction flat(arr) {\n  return arr.reduce(function (prev, cur) {\n    return prev.concat(cur);\n  }, []);\n}\n\nfunction maxOffset() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  args.sort(function (a, b) {\n    return Math.abs(b) - Math.abs(a);\n  });\n  return args[0];\n}\n\nfunction minOffset() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  args.sort(function (a, b) {\n    return Math.abs(a) - Math.abs(b);\n  });\n  return args[0];\n}\n\nfunction calculateInversePosition(matrix, pos, n) {\n  return calculate(invert(matrix, n), convertPositionMatrix(pos, n), n);\n}\n\nfunction convertDragDist(state, e) {\n  var _a;\n\n  var is3d = state.is3d,\n      rootMatrix = state.rootMatrix;\n  var n = is3d ? 4 : 3;\n  _a = calculateInversePosition(rootMatrix, [e.distX, e.distY], n), e.distX = _a[0], e.distY = _a[1];\n  return e;\n}\n\nfunction calculatePadding(matrix, pos, transformOrigin, origin, n) {\n  return minus(calculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\n\nfunction convertCSSSize(value, size, isRelative) {\n  return isRelative ? value / size * 100 + \"%\" : value + \"px\";\n}\n\nfunction moveControlPos(controlPoses, index, dist, isRect) {\n  var _a = controlPoses[index],\n      direction = _a.direction,\n      sub = _a.sub;\n  var dists = controlPoses.map(function () {\n    return [0, 0];\n  });\n  var directions = direction ? direction.split(\"\") : [];\n\n  if (isRect && index < 8) {\n    var verticalDirection_1 = directions.filter(function (dir) {\n      return dir === \"w\" || dir === \"e\";\n    })[0];\n    var horizontalDirection_1 = directions.filter(function (dir) {\n      return dir === \"n\" || dir === \"s\";\n    })[0];\n    dists[index] = dist;\n    controlPoses.forEach(function (controlPose, i) {\n      var controlDir = controlPose.direction;\n\n      if (!controlDir) {\n        return;\n      }\n\n      if (controlDir.indexOf(verticalDirection_1) > -1) {\n        dists[i][0] = dist[0];\n      }\n\n      if (controlDir.indexOf(horizontalDirection_1) > -1) {\n        dists[i][1] = dist[1];\n      }\n    });\n\n    if (verticalDirection_1) {\n      dists[1][0] = dist[0] / 2;\n      dists[5][0] = dist[0] / 2;\n    }\n\n    if (horizontalDirection_1) {\n      dists[3][1] = dist[1] / 2;\n      dists[7][1] = dist[1] / 2;\n    }\n  } else if (direction && !sub) {\n    directions.forEach(function (dir) {\n      var isVertical = dir === \"n\" || dir === \"s\";\n      controlPoses.forEach(function (controlPose, i) {\n        var dirDir = controlPose.direction,\n            dirHorizontal = controlPose.horizontal,\n            dirVertical = controlPose.vertical;\n\n        if (!dirDir || dirDir.indexOf(dir) === -1) {\n          return;\n        }\n\n        dists[i] = [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]];\n      });\n    });\n  } else {\n    dists[index] = dist;\n  }\n\n  return dists;\n}\n\nfunction getTinyDist(v) {\n  return Math.abs(v) <= TINY_NUM ? 0 : v;\n}\n\nfunction directionCondition(moveable, e) {\n  if (e.isRequest) {\n    if (e.requestAble === \"resizable\" || e.requestAble === \"scalable\") {\n      return e.parentDirection;\n    } else {\n      return false;\n    }\n  }\n\n  return hasClass(e.inputEvent.target, prefix(\"direction\"));\n}\n\nfunction invertObject(obj) {\n  var nextObj = {};\n\n  for (var name in obj) {\n    nextObj[obj[name]] = name;\n  }\n\n  return nextObj;\n}\n\nfunction getTransform(transforms, index) {\n  var beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);\n  var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);\n  var targetFunctionText = transforms[index] || \"\";\n  var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n  var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n  var beforeFunctions = parse(beforeFunctionTexts);\n  var beforeFunctions2 = parse(beforeFunctionTexts2);\n  var targetFunctions = parse([targetFunctionText]);\n  var afterFunctions = parse(afterFunctionTexts);\n  var afterFunctions2 = parse(afterFunctionTexts2);\n  var beforeFunctionMatrix = toMat(beforeFunctions);\n  var beforeFunctionMatrix2 = toMat(beforeFunctions2);\n  var afterFunctionMatrix = toMat(afterFunctions);\n  var afterFunctionMatrix2 = toMat(afterFunctions2);\n  var allFunctionMatrix = multiply(beforeFunctionMatrix, afterFunctionMatrix, 4);\n  return {\n    transforms: transforms,\n    beforeFunctionMatrix: beforeFunctionMatrix,\n    beforeFunctionMatrix2: beforeFunctionMatrix2,\n    targetFunctionMatrix: toMat(targetFunctions),\n    afterFunctionMatrix: afterFunctionMatrix,\n    afterFunctionMatrix2: afterFunctionMatrix2,\n    allFunctionMatrix: allFunctionMatrix,\n    beforeFunctions: beforeFunctions,\n    beforeFunctions2: beforeFunctions2,\n    targetFunction: targetFunctions[0],\n    afterFunctions: afterFunctions,\n    afterFunctions2: afterFunctions2,\n    beforeFunctionTexts: beforeFunctionTexts,\n    beforeFunctionTexts2: beforeFunctionTexts2,\n    targetFunctionText: targetFunctionText,\n    afterFunctionTexts: afterFunctionTexts,\n    afterFunctionTexts2: afterFunctionTexts2\n  };\n}\n\nfunction isArrayFormat(arr) {\n  if (!arr || !isObject(arr)) {\n    return false;\n  }\n\n  return isArray(arr) || \"length\" in arr;\n}\n\nfunction getRefTarget(target, isSelector) {\n  if (!target) {\n    return null;\n  }\n\n  if (isString(target)) {\n    if (isSelector) {\n      return document.querySelector(target);\n    }\n\n    return target;\n  }\n\n  if (isFunction(target)) {\n    return target();\n  }\n\n  if (\"current\" in target) {\n    return target.current;\n  }\n\n  return target;\n}\n\nfunction getRefTargets(targets, isSelector) {\n  if (!targets) {\n    return [];\n  }\n\n  var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];\n  return userTargets.reduce(function (prev, target) {\n    if (isString(target) && isSelector) {\n      return __spreadArrays(prev, [].slice.call(document.querySelectorAll(target)));\n    }\n\n    prev.push(getRefTarget(target, isSelector));\n    return prev;\n  }, []);\n}\n\nfunction getElementTargets(targets, selectorMap) {\n  var elementTargets = [];\n  targets.forEach(function (target) {\n    if (!target) {\n      return;\n    }\n\n    if (isString(target)) {\n      if (selectorMap[target]) {\n        elementTargets.push.apply(elementTargets, selectorMap[target]);\n      }\n\n      return;\n    }\n\n    elementTargets.push(target);\n  });\n  return elementTargets;\n}\n\nfunction getAbsoluteRotation(pos1, pos2, direction) {\n  var deg = getRad(pos1, pos2) / Math.PI * 180;\n  deg = direction >= 0 ? deg : 180 - deg;\n  deg = deg >= 0 ? deg : 360 + deg;\n  return deg;\n}\n\nfunction getDragDistByState(state, dist) {\n  var rootMatrix = state.rootMatrix,\n      is3d = state.is3d;\n  var n = is3d ? 4 : 3;\n  var inverseMatrix = invert(rootMatrix, n);\n\n  if (!is3d) {\n    inverseMatrix = convertDimension(inverseMatrix, 3, 4);\n  }\n\n  inverseMatrix[12] = 0;\n  inverseMatrix[13] = 0;\n  inverseMatrix[14] = 0;\n  return calculateMatrixDist(inverseMatrix, dist);\n}\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\n\n\nvar Pinchable = makeAble(\"pinchable\", {\n  events: {\n    onPinchStart: \"pinchStart\",\n    onPinch: \"pinch\",\n    onPinchEnd: \"pinchEnd\",\n    onPinchGroupStart: \"pinchGroupStart\",\n    onPinchGroup: \"pinchGroup\",\n    onPinchGroupEnd: \"pinchGroupEnd\"\n  },\n  dragStart: function dragStart() {\n    return true;\n  },\n  pinchStart: function pinchStart(moveable, e) {\n    var datas = e.datas,\n        targets = e.targets,\n        angle = e.angle,\n        originalDatas = e.originalDatas;\n    var _a = moveable.props,\n        pinchable = _a.pinchable,\n        ables = _a.ables;\n\n    if (!pinchable) {\n      return false;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\") + \"Start\";\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"ControlStart\";\n    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {\n      return pinchable.indexOf(able.name) > -1;\n    })).filter(function (able) {\n      return able.canPinch && able[controlEventName];\n    });\n    var params = fillParams(moveable, e, {});\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    var result = triggerEvent(moveable, eventName, params);\n    datas.isPinch = result !== false;\n    datas.ables = pinchAbles;\n    var isPinch = datas.isPinch;\n\n    if (!isPinch) {\n      return false;\n    }\n\n    pinchAbles.forEach(function (able) {\n      originalDatas[able.name] = originalDatas[able.name] || {};\n\n      if (!able[controlEventName]) {\n        return;\n      }\n\n      var ableEvent = _assign(_assign({}, e), {\n        datas: originalDatas[able.name],\n        parentRotate: angle,\n        isPinch: true\n      });\n\n      able[controlEventName](moveable, ableEvent);\n    });\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: [0, 0]\n    };\n    return isPinch;\n  },\n  pinch: function pinch(moveable, e) {\n    var datas = e.datas,\n        pinchScale = e.scale,\n        distance = e.distance,\n        originalDatas = e.originalDatas,\n        inputEvent = e.inputEvent,\n        targets = e.targets,\n        angle = e.angle;\n\n    if (!datas.isPinch) {\n      return;\n    }\n\n    var parentDistance = distance * (1 - 1 / pinchScale);\n    var params = fillParams(moveable, e, {});\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\");\n    triggerEvent(moveable, eventName, params);\n    var ables = datas.ables;\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"Control\";\n    ables.forEach(function (able) {\n      if (!able[controlEventName]) {\n        return;\n      }\n\n      able[controlEventName](moveable, _assign(_assign({}, e), {\n        datas: originalDatas[able.name],\n        inputEvent: inputEvent,\n        parentDistance: parentDistance,\n        parentRotate: angle,\n        isPinch: true\n      }));\n    });\n    return params;\n  },\n  pinchEnd: function pinchEnd(moveable, e) {\n    var datas = e.datas,\n        isPinch = e.isPinch,\n        inputEvent = e.inputEvent,\n        targets = e.targets,\n        originalDatas = e.originalDatas;\n\n    if (!datas.isPinch) {\n      return;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\") + \"End\";\n    var params = fillEndParams(moveable, e, {\n      isDrag: isPinch\n    });\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    triggerEvent(moveable, eventName, params);\n    var ables = datas.ables;\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"ControlEnd\";\n    ables.forEach(function (able) {\n      if (!able[controlEventName]) {\n        return;\n      }\n\n      able[controlEventName](moveable, _assign(_assign({}, e), {\n        isDrag: isPinch,\n        datas: originalDatas[able.name],\n        inputEvent: inputEvent,\n        isPinch: true\n      }));\n    });\n    return isPinch;\n  },\n  pinchGroupStart: function pinchGroupStart(moveable, e) {\n    return this.pinchStart(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  pinchGroup: function pinchGroup(moveable, e) {\n    return this.pinch(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  pinchGroupEnd: function pinchGroupEnd(moveable, e) {\n    return this.pinchEnd(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets\n    }));\n  }\n});\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n\nfunction setCustomDrag(e, state, delta, isPinch, isConvert) {\n  var result = state.gesto.move(delta, e.inputEvent);\n  var datas = result.originalDatas || result.datas;\n  var draggableDatas = datas.draggable || (datas.draggable = {});\n  return _assign(_assign({}, isConvert ? convertDragDist(state, result) : result), {\n    isDrag: true,\n    isPinch: !!isPinch,\n    parentEvent: true,\n    datas: draggableDatas,\n    originalDatas: e.originalDatas\n  });\n}\n\nvar CustomGesto = /*#__PURE__*/function () {\n  function CustomGesto() {\n    this.prevX = 0;\n    this.prevY = 0;\n    this.startX = 0;\n    this.startY = 0;\n    this.isDrag = false;\n    this.isFlag = false;\n    this.datas = {\n      draggable: {}\n    };\n  }\n\n  var __proto = CustomGesto.prototype;\n\n  __proto.dragStart = function (client, e) {\n    this.isDrag = false;\n    this.isFlag = false;\n    var originalDatas = e.originalDatas;\n    this.datas = originalDatas;\n\n    if (!originalDatas.draggable) {\n      originalDatas.draggable = {};\n    }\n\n    return _assign(_assign({}, this.move(client, e.inputEvent)), {\n      type: \"dragstart\"\n    });\n  };\n\n  __proto.drag = function (client, inputEvent) {\n    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);\n  };\n\n  __proto.move = function (delta, inputEvent) {\n    var clientX;\n    var clientY;\n\n    if (!this.isFlag) {\n      this.prevX = delta[0];\n      this.prevY = delta[1];\n      this.startX = delta[0];\n      this.startY = delta[1];\n      clientX = delta[0];\n      clientY = delta[1];\n      this.isFlag = true;\n    } else {\n      clientX = this.prevX + delta[0];\n      clientY = this.prevY + delta[1];\n      this.isDrag = true;\n    }\n\n    this.prevX = clientX;\n    this.prevY = clientY;\n    return {\n      type: \"drag\",\n      clientX: clientX,\n      clientY: clientY,\n      inputEvent: inputEvent,\n      isDrag: this.isDrag,\n      distX: clientX - this.startX,\n      distY: clientY - this.startY,\n      deltaX: delta[0],\n      deltaY: delta[1],\n      datas: this.datas.draggable,\n      originalDatas: this.datas,\n      parentEvent: true,\n      parentGesto: this\n    };\n  };\n\n  return CustomGesto;\n}();\n\nfunction fillChildEvents(moveable, name, e) {\n  var datas = e.originalDatas;\n  datas.groupable = datas.groupable || {};\n  var groupableDatas = datas.groupable;\n  groupableDatas.childDatas = groupableDatas.childDatas || [];\n  var childDatas = groupableDatas.childDatas;\n  return moveable.moveables.map(function (_, i) {\n    childDatas[i] = childDatas[i] || {};\n    childDatas[i][name] = childDatas[i][name] || {};\n    return _assign(_assign({}, e), {\n      datas: childDatas[i][name],\n      originalDatas: childDatas[i]\n    });\n  });\n}\n\nfunction triggerChildGesto(moveable, able, type, delta, e, isConvert) {\n  var isStart = !!type.match(/Start$/g);\n  var isEnd = !!type.match(/End$/g);\n  var isPinch = e.isPinch;\n  var datas = e.datas;\n  var events = fillChildEvents(moveable, able.name, e);\n  var moveables = moveable.moveables;\n  var childs = events.map(function (ev, i) {\n    var childMoveable = moveables[i];\n    var childEvent = ev;\n\n    if (isStart) {\n      childEvent = new CustomGesto().dragStart(delta, ev);\n    } else {\n      if (!childMoveable.state.gesto) {\n        childMoveable.state.gesto = datas.childGestos[i];\n      }\n\n      childEvent = setCustomDrag(ev, childMoveable.state, delta, isPinch, isConvert);\n    }\n\n    var result = able[type](childMoveable, _assign(_assign({}, childEvent), {\n      parentFlag: true\n    }));\n\n    if (isEnd) {\n      childMoveable.state.gesto = null;\n    }\n\n    return result;\n  });\n\n  if (isStart) {\n    datas.childGestos = moveables.map(function (child) {\n      return child.state.gesto;\n    });\n  }\n\n  return childs;\n}\n\nfunction triggerChildAbles(moveable, able, type, e, eachEvent, callback) {\n  if (eachEvent === void 0) {\n    eachEvent = function eachEvent(_, ev) {\n      return ev;\n    };\n  }\n\n  var isEnd = !!type.match(/End$/g);\n  var events = fillChildEvents(moveable, able.name, e);\n  var moveables = moveable.moveables;\n  var childs = events.map(function (ev, i) {\n    var childMoveable = moveables[i];\n    var childEvent = ev;\n    childEvent = eachEvent(childMoveable, ev);\n    var result = able[type](childMoveable, _assign(_assign({}, childEvent), {\n      parentFlag: true\n    }));\n    result && callback && callback(childMoveable, ev, result, i);\n\n    if (isEnd) {\n      childMoveable.state.gesto = null;\n    }\n\n    return result;\n  });\n  return childs;\n}\n\nfunction calculatePointerDist(moveable, e) {\n  var clientX = e.clientX,\n      clientY = e.clientY,\n      datas = e.datas;\n  var _a = moveable.state,\n      moveableClientRect = _a.moveableClientRect,\n      rootMatrix = _a.rootMatrix,\n      is3d = _a.is3d,\n      pos1 = _a.pos1;\n  var left = moveableClientRect.left,\n      top = moveableClientRect.top;\n  var n = is3d ? 4 : 3;\n\n  var _b = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1),\n      posX = _b[0],\n      posY = _b[1];\n\n  var _c = getDragDist({\n    datas: datas,\n    distX: posX,\n    distY: posY\n  }),\n      distX = _c[0],\n      distY = _c[1];\n\n  return [distX, distY];\n}\n\nfunction setDragStart(moveable, _a) {\n  var datas = _a.datas;\n  var _b = moveable.state,\n      allMatrix = _b.allMatrix,\n      beforeMatrix = _b.beforeMatrix,\n      is3d = _b.is3d,\n      left = _b.left,\n      top = _b.top,\n      origin = _b.origin,\n      offsetMatrix = _b.offsetMatrix,\n      targetMatrix = _b.targetMatrix,\n      transformOrigin = _b.transformOrigin;\n  var n = is3d ? 4 : 3;\n  datas.is3d = is3d;\n  datas.matrix = allMatrix;\n  datas.targetMatrix = targetMatrix;\n  datas.beforeMatrix = beforeMatrix;\n  datas.offsetMatrix = offsetMatrix;\n  datas.transformOrigin = transformOrigin;\n  datas.inverseMatrix = invert(allMatrix, n);\n  datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n  datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n  datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n  datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\n\nfunction getTransformDirection(e) {\n  return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\n\nfunction resolveTransformEvent(event, functionName) {\n  var datas = event.datas,\n      originalDatas = event.originalDatas.beforeRenderable;\n  var index = datas.transformIndex;\n  var nextTransforms = originalDatas.nextTransforms;\n  var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;\n  var nextIndex = index === -1 ? nextTransforms.length : index + nextTransformAppendedIndexes.filter(function (i) {\n    return i < index;\n  }).length;\n  var result = getTransform(nextTransforms, nextIndex);\n  var targetFunction = result.targetFunction;\n  var matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n  datas.beforeFunctionTexts = result.beforeFunctionTexts;\n  datas.afterFunctionTexts = result.afterFunctionTexts;\n  datas.beforeTransform = result.beforeFunctionMatrix;\n  datas.beforeTransform2 = result.beforeFunctionMatrix2;\n  datas.targetTansform = result.targetFunctionMatrix;\n  datas.afterTransform = result.afterFunctionMatrix;\n  datas.afterTransform2 = result.afterFunctionMatrix2;\n  datas.targetAllTransform = result.allFunctionMatrix;\n\n  if (targetFunction.functionName === matFunctionName) {\n    datas.afterFunctionTexts.splice(0, 1);\n    datas.isAppendTransform = false;\n  } else {\n    datas.isAppendTransform = true;\n    originalDatas.nextTransformAppendedIndexes = __spreadArrays(nextTransformAppendedIndexes, [nextIndex]);\n  }\n}\n\nfunction convertTransformFormat(datas, value, dist) {\n  return datas.beforeFunctionTexts.join(\" \") + \" \" + (datas.isAppendTransform ? dist : value) + \" \" + datas.afterFunctionTexts.join(\" \");\n}\n\nfunction getTransformDist(_a) {\n  var datas = _a.datas,\n      distX = _a.distX,\n      distY = _a.distY;\n\n  var _b = getBeforeDragDist({\n    datas: datas,\n    distX: distX,\n    distY: distY\n  }),\n      bx = _b[0],\n      by = _b[1]; // B * [tx, ty] * A = [bx, by] * targetMatrix;\n  // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\n\n\n  var res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));\n  return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);\n}\n\nfunction getTransfromMatrix(datas, targetMatrix, isAfter) {\n  var beforeTransform = datas.beforeTransform,\n      afterTransform = datas.afterTransform,\n      beforeTransform2 = datas.beforeTransform2,\n      afterTransform2 = datas.afterTransform2,\n      targetAllTransform = datas.targetAllTransform; // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\n  // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\n  // nextTargetMatrix = (targetMatrix * targetAllTransform)\n\n  var nextTargetMatrix = isAfter ? multiply(targetAllTransform, targetMatrix, 4) : multiply(targetMatrix, targetAllTransform, 4); // res1 = B-1 * nextTargetMatrix\n\n  var res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4); // res3 = res2 * A-1\n\n  var afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);\n  return afterTargetMatrix;\n}\n\nfunction getBeforeDragDist(_a) {\n  var datas = _a.datas,\n      distX = _a.distX,\n      distY = _a.distY; // TT = BT\n\n  var inverseBeforeMatrix = datas.inverseBeforeMatrix,\n      is3d = datas.is3d,\n      startDragBeforeDist = datas.startDragBeforeDist,\n      absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3; // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\n  // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\n\n  return minus(calculate(inverseBeforeMatrix, plus(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);\n}\n\nfunction getDragDist(_a, isBefore) {\n  var datas = _a.datas,\n      distX = _a.distX,\n      distY = _a.distY;\n  var inverseBeforeMatrix = datas.inverseBeforeMatrix,\n      inverseMatrix = datas.inverseMatrix,\n      is3d = datas.is3d,\n      startDragBeforeDist = datas.startDragBeforeDist,\n      startDragDist = datas.startDragDist,\n      absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(calculate(isBefore ? inverseBeforeMatrix : inverseMatrix, plus(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);\n}\n\nfunction getInverseDragDist(_a, isBefore) {\n  var datas = _a.datas,\n      distX = _a.distX,\n      distY = _a.distY;\n  var beforeMatrix = datas.beforeMatrix,\n      matrix = datas.matrix,\n      is3d = datas.is3d,\n      startDragBeforeDist = datas.startDragBeforeDist,\n      startDragDist = datas.startDragDist,\n      absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(calculate(isBefore ? beforeMatrix : matrix, plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);\n}\n\nfunction calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {\n  if (prevWidth === void 0) {\n    prevWidth = width;\n  }\n\n  if (prevHeight === void 0) {\n    prevHeight = height;\n  }\n\n  if (prevOrigin === void 0) {\n    prevOrigin = [0, 0];\n  }\n\n  if (!transformOrigin) {\n    return prevOrigin;\n  }\n\n  return transformOrigin.map(function (pos, i) {\n    var _a = splitUnit(pos),\n        value = _a.value,\n        unit = _a.unit;\n\n    var prevSize = i ? prevHeight : prevWidth;\n    var size = i ? height : width;\n\n    if (pos === \"%\" || isNaN(value)) {\n      // no value but %\n      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n      return size * measureRatio;\n    } else if (unit !== \"%\") {\n      return value;\n    }\n\n    return size * value / 100;\n  });\n}\n\nfunction getPosIndexesByDirection(direction) {\n  var indexes = [];\n\n  if (direction[1] >= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(3);\n    }\n\n    if (direction[0] <= 0) {\n      indexes.push(2);\n    }\n  }\n\n  if (direction[1] <= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(1);\n    }\n\n    if (direction[0] <= 0) {\n      indexes.push(0);\n    }\n  }\n\n  return indexes;\n}\n\nfunction getPosesByDirection(poses, direction) {\n  /*\n  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n  */\n  return getPosIndexesByDirection(direction).map(function (index) {\n    return poses[index];\n  });\n}\n\nfunction getPosByDirection(poses, direction) {\n  /*\n  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n  */\n  var nextPoses = getPosesByDirection(poses, direction);\n  return [average(nextPoses.map(function (pos) {\n    return pos[0];\n  })), average(nextPoses.map(function (pos) {\n    return pos[1];\n  }))];\n}\n\nfunction getPosByReverseDirection(poses, direction) {\n  /*\n  [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n  [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n  [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n  */\n  return getPosByDirection(poses, direction.map(function (dir) {\n    return -dir;\n  }));\n}\n\nfunction getDist(startPos, matrix, width, height, n, fixedDirection) {\n  var poses = calculatePoses(matrix, width, height, n);\n  var fixedPos = getPosByDirection(poses, fixedDirection);\n  var distX = startPos[0] - fixedPos[0];\n  var distY = startPos[1] - fixedPos[1];\n  return [distX, distY];\n}\n\nfunction getNextMatrix(offsetMatrix, targetMatrix, origin, n) {\n  return multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);\n}\n\nfunction getNextTransformMatrix(state, datas, transform) {\n  var transformOrigin = state.transformOrigin,\n      offsetMatrix = state.offsetMatrix,\n      is3d = state.is3d;\n  var beforeTransform = datas.beforeTransform,\n      afterTransform = datas.afterTransform;\n  var n = is3d ? 4 : 3;\n  var targetTransform = parseMat([transform]);\n  return getNextMatrix(offsetMatrix, convertDimension(multiply(multiply(beforeTransform, targetTransform, 4), afterTransform, 4), 4, n), transformOrigin, n);\n}\n\nfunction scaleMatrix(state, scale) {\n  var transformOrigin = state.transformOrigin,\n      offsetMatrix = state.offsetMatrix,\n      is3d = state.is3d,\n      targetMatrix = state.targetMatrix;\n  var n = is3d ? 4 : 3;\n  return getNextMatrix(offsetMatrix, multiply(targetMatrix, createScaleMatrix(scale, n), n), transformOrigin, n);\n}\n\nfunction fillTransformStartEvent(e) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  return {\n    setTransform: function setTransform(transform, index) {\n      if (index === void 0) {\n        index = -1;\n      }\n\n      originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n\n      _setTransformIndex(e, index);\n    },\n    setTransformIndex: function setTransformIndex(index) {\n      _setTransformIndex(e, index);\n    }\n  };\n}\n\nfunction setDefaultTransformIndex(e, property) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  var startTransforms = originalDatas.startTransforms;\n\n  _setTransformIndex(e, findIndex(startTransforms, function (func) {\n    return func.indexOf(property + \"(\") === 0;\n  }));\n}\n\nfunction _setTransformIndex(e, index) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  var datas = e.datas;\n  datas.transformIndex = index;\n\n  if (index === -1) {\n    return;\n  }\n\n  var transform = originalDatas.startTransforms[index];\n\n  if (!transform) {\n    return;\n  }\n\n  var info = parse([transform]);\n  datas.startValue = info[0].functionValue;\n}\n\nfunction fillOriginalTransform(e, transform) {\n  var originalDatas = e.originalDatas.beforeRenderable;\n  originalDatas.nextTransforms = splitSpace(transform);\n}\n\nfunction fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {\n  fillOriginalTransform(e, nextTransform);\n  return {\n    transform: nextTransform,\n    drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false))\n  };\n}\n\nfunction getTranslateDist(moveable, transform, fixedDirection, fixedPosition, datas) {\n  var state = moveable.state;\n  var left = state.left,\n      top = state.top;\n  var groupable = moveable.props.groupable;\n  var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);\n  var groupLeft = groupable ? left : 0;\n  var groupTop = groupable ? top : 0;\n  var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);\n  var dist = minus(fixedPosition, nextFixedPosition);\n  return minus(dist, [groupLeft, groupTop]);\n}\n\nfunction getScaleDist(moveable, scaleDist, fixedDirection, fixedPosition, datas) {\n  return getTranslateDist(moveable, \"scale(\" + scaleDist.join(\", \") + \")\", fixedDirection, fixedPosition, datas);\n}\n\nfunction getOriginDirection(moveable) {\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height,\n      transformOrigin = _a.transformOrigin;\n  return [-1 + transformOrigin[0] / (width / 2), -1 + transformOrigin[1] / (height / 2)];\n}\n\nfunction getDirectionOffset(moveable, direction, nextMatrix) {\n  if (nextMatrix === void 0) {\n    nextMatrix = moveable.state.allMatrix;\n  }\n\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height,\n      is3d = _a.is3d;\n  var n = is3d ? 4 : 3;\n  var nextFixedOffset = [width / 2 * (1 + direction[0]), height / 2 * (1 + direction[1])];\n  return calculatePosition(nextMatrix, nextFixedOffset, n);\n}\n\nfunction getRotateDist(moveable, rotateDist, fixedPosition, datas) {\n  var fixedDirection = getOriginDirection(moveable);\n  return getTranslateDist(moveable, \"rotate(\" + rotateDist + \"deg)\", fixedDirection, fixedPosition, datas);\n}\n\nfunction getResizeDist(moveable, width, height, fixedDirection, fixedPosition, transformOrigin) {\n  var groupable = moveable.props.groupable;\n  var _a = moveable.state,\n      prevOrigin = _a.transformOrigin,\n      targetMatrix = _a.targetMatrix,\n      offsetMatrix = _a.offsetMatrix,\n      is3d = _a.is3d,\n      prevWidth = _a.width,\n      prevHeight = _a.height,\n      left = _a.left,\n      top = _a.top;\n  var n = is3d ? 4 : 3;\n  var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);\n  var groupLeft = groupable ? left : 0;\n  var groupTop = groupable ? top : 0;\n  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n  var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\n  return minus(dist, [groupLeft, groupTop]);\n}\n\nfunction getAbsolutePosition(moveable, direction) {\n  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n\nfunction calculateContainerPos(rootMatrix, containerRect, n) {\n  var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);\n  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];\n}\n\nfunction getGapGuidelines(guidelines, type, snapThreshold, index, _a, _b) {\n  var start = _a[0],\n      end = _a[1];\n  var otherStart = _b[0],\n      otherEnd = _b[1];\n  var totalGuidelines = [];\n  var otherIndex = index ? 0 : 1;\n  var otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n  var elementGuidelines = groupBy(guidelines.filter(function (_a) {\n    var guidelineType = _a.type;\n    return guidelineType === type;\n  }), function (_a) {\n    var element = _a.element;\n    return element;\n  }).map(function (group) {\n    return group[0];\n  }).filter(function (_a) {\n    var pos = _a.pos,\n        sizes = _a.sizes;\n    return pos[otherIndex] <= otherEnd && otherStart <= pos[otherIndex] + sizes[otherIndex];\n  });\n  elementGuidelines.forEach(function (guideline1) {\n    var elementStart = guideline1.pos[index];\n    var elementEnd = elementStart + guideline1.sizes[index];\n    elementGuidelines.forEach(function (guideline2) {\n      var guideline2Pos = guideline2.pos,\n          guideline2Sizes = guideline2.sizes,\n          guideline2Element = guideline2.element,\n          guidline2ClassName = guideline2.className;\n      var targetStart = guideline2Pos[index];\n      var targetEnd = targetStart + guideline2Sizes[index];\n      var pos = 0;\n      var gap = 0;\n      var canSnap = true;\n\n      if (elementEnd <= targetStart) {\n        // gap -\n        gap = elementEnd - targetStart;\n        pos = targetEnd - gap;\n\n        if (start < pos - snapThreshold) {\n          canSnap = false;\n        } // element target moveable\n\n      } else if (targetEnd <= elementStart) {\n        // gap +\n        gap = elementStart - targetEnd;\n        pos = targetStart - gap;\n\n        if (end > pos + snapThreshold) {\n          canSnap = false;\n        } // moveable target element\n\n      } else {\n        return;\n      }\n\n      if (canSnap) {\n        totalGuidelines.push({\n          pos: otherType === \"vertical\" ? [pos, guideline2Pos[1]] : [guideline2Pos[0], pos],\n          element: guideline2Element,\n          sizes: guideline2Sizes,\n          size: 0,\n          type: otherType,\n          gap: gap,\n          className: guidline2ClassName,\n          gapGuidelines: elementGuidelines\n        });\n      }\n\n      if (elementEnd <= start && end <= targetStart) {\n        // elementEnd   moveable   target\n        var centerPos = (targetStart + elementEnd - (end - start)) / 2;\n\n        if (throttle(start - (centerPos - snapThreshold), 0.1) >= 0) {\n          totalGuidelines.push({\n            pos: otherType === \"vertical\" ? [centerPos, guideline2Pos[1]] : [guideline2Pos[0], centerPos],\n            className: guidline2ClassName,\n            element: guideline2Element,\n            sizes: guideline2Sizes,\n            size: 0,\n            type: otherType,\n            gap: elementEnd - start,\n            gapGuidelines: elementGuidelines\n          });\n        }\n      }\n    });\n  });\n  return totalGuidelines;\n}\n\nfunction getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {\n  if (clientLeft === void 0) {\n    clientLeft = 0;\n  }\n\n  if (clientTop === void 0) {\n    clientTop = 0;\n  }\n\n  if (snapOffset === void 0) {\n    snapOffset = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n\n  var guidelines = [];\n  var snapOffsetLeft = snapOffset.left,\n      snapOffsetTop = snapOffset.top,\n      snapOffsetBottom = snapOffset.bottom,\n      snapOffsetRight = snapOffset.right;\n  var snapWidth = width + snapOffsetRight - snapOffsetLeft;\n  var snapHeight = height + snapOffsetBottom - snapOffsetTop;\n  horizontalGuidelines && horizontalGuidelines.forEach(function (pos) {\n    guidelines.push({\n      type: \"horizontal\",\n      pos: [snapOffsetLeft, throttle(pos - clientTop + snapOffsetTop, 0.1)],\n      size: snapWidth\n    });\n  });\n  verticalGuidelines && verticalGuidelines.forEach(function (pos) {\n    guidelines.push({\n      type: \"vertical\",\n      pos: [throttle(pos - clientLeft + snapOffsetLeft, 0.1), snapOffsetTop],\n      size: snapHeight\n    });\n  });\n  return guidelines;\n}\n\nfunction calculateElementGuidelines(moveable, values) {\n  var guidelines = [];\n\n  if (!values.length) {\n    return guidelines;\n  }\n\n  var state = moveable.state;\n  var snapCenter = moveable.props.snapCenter;\n  var containerClientRect = state.containerClientRect,\n      _a = state.targetClientRect,\n      clientTop = _a.top,\n      clientLeft = _a.left,\n      rootMatrix = state.rootMatrix,\n      is3d = state.is3d;\n  var n = is3d ? 4 : 3;\n\n  var _b = calculateContainerPos(rootMatrix, containerClientRect, n),\n      containerLeft = _b[0],\n      containerTop = _b[1];\n\n  var poses = getAbsolutePosesByState(state);\n\n  var _c = getMinMaxs(poses),\n      targetLeft = _c.minX,\n      targetTop = _c.minY;\n\n  var _d = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function (pos) {\n    return roundSign(pos);\n  }),\n      distLeft = _d[0],\n      distTop = _d[1];\n\n  values.forEach(function (value) {\n    var element = value.element,\n        topValue = value.top,\n        leftValue = value.left,\n        rightValue = value.right,\n        bottomValue = value.bottom,\n        className = value.className;\n    var rect = element.getBoundingClientRect();\n    var left = rect.left - containerLeft;\n    var top = rect.top - containerTop;\n    var bottom = top + rect.height;\n    var right = left + rect.width;\n\n    var _a = calculateInversePosition(rootMatrix, [left, top], n),\n        elementLeft = _a[0],\n        elementTop = _a[1];\n\n    var _b = calculateInversePosition(rootMatrix, [right, bottom], n),\n        elementRight = _b[0],\n        elementBottom = _b[1];\n\n    var width = elementRight - elementLeft;\n    var height = elementBottom - elementTop;\n    var sizes = [width, height]; //top\n\n    if (topValue !== false) {\n      guidelines.push({\n        type: \"vertical\",\n        element: element,\n        pos: [throttle(elementLeft + distLeft, 0.1), elementTop],\n        size: height,\n        sizes: sizes,\n        className: className\n      });\n    } // bottom\n\n\n    if (bottomValue !== false) {\n      guidelines.push({\n        type: \"vertical\",\n        element: element,\n        pos: [throttle(elementRight + distLeft, 0.1), elementTop],\n        size: height,\n        sizes: sizes,\n        className: className\n      });\n    } // left\n\n\n    if (leftValue !== false) {\n      guidelines.push({\n        type: \"horizontal\",\n        element: element,\n        pos: [elementLeft, throttle(elementTop + distTop, 0.1)],\n        size: width,\n        sizes: sizes,\n        className: className\n      });\n    } // right\n\n\n    if (rightValue !== false) {\n      guidelines.push({\n        type: \"horizontal\",\n        element: element,\n        pos: [elementLeft, throttle(elementBottom + distTop, 0.1)],\n        size: width,\n        sizes: sizes,\n        className: className\n      });\n    }\n\n    if (snapCenter) {\n      guidelines.push({\n        type: \"vertical\",\n        element: element,\n        pos: [throttle((elementLeft + elementRight) / 2 + distLeft, 0.1), elementTop],\n        size: height,\n        sizes: sizes,\n        center: true,\n        className: className\n      });\n      guidelines.push({\n        type: \"horizontal\",\n        element: element,\n        pos: [elementLeft, throttle((elementTop + elementBottom) / 2 + distTop, 0.1)],\n        size: width,\n        sizes: sizes,\n        center: true,\n        className: className\n      });\n    }\n  });\n  return guidelines;\n}\n\nfunction getElementGuidelines(moveable, isRefresh, prevGuidelines) {\n  if (prevGuidelines === void 0) {\n    prevGuidelines = [];\n  }\n\n  var guidelines = [];\n  var state = moveable.state;\n\n  if (isRefresh && state.guidelines && state.guidelines.length) {\n    return guidelines;\n  }\n\n  var _a = moveable.props.elementGuidelines,\n      elementGuidelines = _a === void 0 ? [] : _a;\n\n  if (!elementGuidelines.length) {\n    return guidelines;\n  }\n\n  var prevValues = state.elementGuidelineValues || [];\n  var nextValues = elementGuidelines.map(function (el) {\n    if (isObject(el) && \"element\" in el) {\n      return el;\n    }\n\n    return {\n      element: getRefTarget(el, true)\n    };\n  }).filter(function (value) {\n    return value.element;\n  });\n  state.elementGuidelineValues = nextValues;\n\n  var _b = diff(prevValues.map(function (v) {\n    return v.element;\n  }), nextValues.map(function (v) {\n    return v.element;\n  })),\n      added = _b.added,\n      removed = _b.removed;\n\n  var removedElements = removed.map(function (index) {\n    return prevValues[index].element;\n  });\n  var addedGuidelines = calculateElementGuidelines(moveable, added.map(function (index) {\n    return nextValues[index];\n  }).filter(function (value) {\n    return value.refresh && isRefresh || !value.refresh && !isRefresh;\n  }));\n  return __spreadArrays(prevGuidelines.filter(function (guideline) {\n    return removedElements.indexOf(guideline.element) === -1;\n  }), addedGuidelines);\n}\n\nfunction getTotalGuidelines(moveable) {\n  var _a = moveable.state,\n      snapOffset = _a.snapOffset,\n      staticGuidelines = _a.staticGuidelines,\n      _b = _a.containerClientRect,\n      overflow = _b.overflow,\n      containerHeight = _b.scrollHeight,\n      containerWidth = _b.scrollWidth,\n      containerClientHeight = _b.clientHeight,\n      containerClientWidth = _b.clientWidth,\n      clientLeft = _b.clientLeft,\n      clientTop = _b.clientTop;\n  var _c = moveable.props,\n      _d = _c.snapHorizontal,\n      snapHorizontal = _d === void 0 ? true : _d,\n      _e = _c.snapVertical,\n      snapVertical = _e === void 0 ? true : _e,\n      _f = _c.snapGap,\n      snapGap = _f === void 0 ? true : _f,\n      verticalGuidelines = _c.verticalGuidelines,\n      horizontalGuidelines = _c.horizontalGuidelines,\n      _g = _c.snapThreshold,\n      snapThreshold = _g === void 0 ? 5 : _g,\n      _h = _c.snapGridWidth,\n      snapGridWidth = _h === void 0 ? 0 : _h,\n      _j = _c.snapGridHeight,\n      snapGridHeight = _j === void 0 ? 0 : _j;\n\n  var totalGuidelines = __spreadArrays(staticGuidelines, getElementGuidelines(moveable, true));\n\n  if (snapGap) {\n    var _k = getRect(getAbsolutePosesByState(moveable.state)),\n        top = _k.top,\n        left = _k.left,\n        bottom = _k.bottom,\n        right = _k.right;\n\n    var elementGuidelines = staticGuidelines.filter(function (_a) {\n      var element = _a.element;\n      return element;\n    });\n    totalGuidelines.push.apply(totalGuidelines, __spreadArrays(getGapGuidelines(elementGuidelines, \"horizontal\", snapThreshold, 0, [left, right], [top, bottom]), getGapGuidelines(elementGuidelines, \"vertical\", snapThreshold, 1, [top, bottom], [left, right])));\n  }\n\n  totalGuidelines.push.apply(totalGuidelines, getGridGuidelines(snapGridWidth, snapGridHeight, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop));\n  totalGuidelines.push.apply(totalGuidelines, getDefaultGuidelines(snapHorizontal && horizontalGuidelines || false, snapVertical && verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset));\n  return totalGuidelines;\n}\n\nfunction getGridGuidelines(snapGridWidth, snapGridHeight, containerWidth, containerHeight, clientLeft, clientTop) {\n  if (clientLeft === void 0) {\n    clientLeft = 0;\n  }\n\n  if (clientTop === void 0) {\n    clientTop = 0;\n  }\n\n  var guidelines = [];\n\n  if (snapGridHeight) {\n    for (var pos = 0; pos <= containerHeight; pos += snapGridHeight) {\n      guidelines.push({\n        type: \"horizontal\",\n        pos: [0, throttle(pos - clientTop, 0.1)],\n        size: containerWidth,\n        hide: true\n      });\n    }\n  }\n\n  if (snapGridWidth) {\n    for (var pos = 0; pos <= containerWidth; pos += snapGridWidth) {\n      guidelines.push({\n        type: \"vertical\",\n        pos: [throttle(pos - clientLeft, 0.1), 0],\n        size: containerHeight,\n        hide: true\n      });\n    }\n  }\n\n  return guidelines;\n}\n\nfunction checkMoveableSnapPoses(moveable, posesX, posesY, snapCenter, customSnapThreshold) {\n  var props = moveable.props;\n  var _a = props.snapElement,\n      snapElement = _a === void 0 ? true : _a;\n  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);\n  return checkSnapPoses(moveable.state.guidelines, posesX, posesY, {\n    snapThreshold: snapThreshold,\n    snapCenter: snapCenter,\n    snapElement: snapElement\n  });\n}\n\nfunction checkSnapPoses(guidelines, posesX, posesY, options) {\n  return {\n    vertical: checkSnap(guidelines, \"vertical\", posesX, options),\n    horizontal: checkSnap(guidelines, \"horizontal\", posesY, options)\n  };\n}\n\nfunction checkSnapKeepRatio(moveable, startPos, endPos) {\n  var endX = endPos[0],\n      endY = endPos[1];\n  var startX = startPos[0],\n      startY = startPos[1];\n\n  var _a = minus(endPos, startPos),\n      dx = _a[0],\n      dy = _a[1];\n\n  var isBottom = dy > 0;\n  var isRight = dx > 0;\n  dx = getTinyDist(dx);\n  dy = getTinyDist(dy);\n  var verticalInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0\n  };\n  var horizontalInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0\n  };\n\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo\n    };\n  }\n\n  var _b = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []),\n      verticalSnapInfo = _b.vertical,\n      horizontalSnapInfo = _b.horizontal;\n\n  verticalSnapInfo.posInfos.filter(function (_a) {\n    var pos = _a.pos;\n    return isRight ? pos >= startX : pos <= startX;\n  });\n  horizontalSnapInfo.posInfos.filter(function (_a) {\n    var pos = _a.pos;\n    return isBottom ? pos >= startY : pos <= startY;\n  });\n  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n  var _c = getNearestSnapGuidelineInfo(verticalSnapInfo),\n      isVerticalSnap = _c.isSnap,\n      verticalGuideline = _c.guideline;\n\n  var _d = getNearestSnapGuidelineInfo(horizontalSnapInfo),\n      isHorizontalSnap = _d.isSnap,\n      horizontalGuideline = _d.guideline;\n\n  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;\n  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;\n\n  if (dx === 0) {\n    if (isHorizontalSnap) {\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = horizontalGuideline.pos[1];\n      horizontalInfo.offset = endY - horizontalInfo.pos;\n    }\n  } else if (dy === 0) {\n    if (isVerticalSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = verticalPos;\n      verticalInfo.offset = endX - verticalPos;\n    }\n  } else {\n    // y - y1 = a * (x - x1)\n    var a = dy / dx;\n    var b = endPos[1] - a * endX;\n    var y = 0;\n    var x = 0;\n    var isSnap = false;\n\n    if (isVerticalSnap) {\n      x = verticalPos;\n      y = a * x + b;\n      isSnap = true;\n    } else if (isHorizontalSnap) {\n      y = horizontalPos;\n      x = (y - b) / a;\n      isSnap = true;\n    }\n\n    if (isSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = x;\n      verticalInfo.offset = endX - x;\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = y;\n      horizontalInfo.offset = endY - y;\n    }\n  }\n\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo\n  };\n}\n\nfunction checkSnaps(moveable, rect, isCenter, customSnapThreshold) {\n  var snapCenter = moveable.props.snapCenter;\n  var isSnapCenter = snapCenter && isCenter;\n  var verticalNames = [\"left\", \"right\"];\n  var horizontalNames = [\"top\", \"bottom\"];\n\n  if (isSnapCenter) {\n    verticalNames.push(\"center\");\n    horizontalNames.push(\"middle\");\n  }\n\n  verticalNames = verticalNames.filter(function (name) {\n    return name in rect;\n  });\n  horizontalNames = horizontalNames.filter(function (name) {\n    return name in rect;\n  });\n  return checkMoveableSnapPoses(moveable, verticalNames.map(function (name) {\n    return rect[name];\n  }), horizontalNames.map(function (name) {\n    return rect[name];\n  }), isSnapCenter, customSnapThreshold);\n}\n\nfunction getNearestSnapGuidelineInfo(snapInfo) {\n  var isSnap = snapInfo.isSnap;\n\n  if (!isSnap) {\n    return {\n      isSnap: false,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  }\n\n  var posInfo = snapInfo.posInfos[0];\n  var guidelineInfo = posInfo.guidelineInfos[0];\n  var offset = guidelineInfo.offset;\n  var dist = guidelineInfo.dist;\n  var guideline = guidelineInfo.guideline;\n  return {\n    isSnap: isSnap,\n    offset: offset,\n    dist: dist,\n    pos: posInfo.pos,\n    guideline: guideline\n  };\n}\n\nfunction checkSnap(guidelines, targetType, targetPoses, _a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.snapThreshold,\n      snapThreshold = _c === void 0 ? 5 : _c,\n      snapElement = _b.snapElement,\n      snapCenter = _b.snapCenter;\n\n  if (!guidelines || !guidelines.length) {\n    return {\n      isSnap: false,\n      index: -1,\n      posInfos: []\n    };\n  }\n\n  var isVertical = targetType === \"vertical\";\n  var posType = isVertical ? 0 : 1;\n  var snapPosInfos = targetPoses.map(function (targetPos, index) {\n    var guidelineInfos = guidelines.map(function (guideline) {\n      var pos = guideline.pos;\n      var offset = targetPos - pos[posType];\n      return {\n        offset: offset,\n        dist: Math.abs(offset),\n        guideline: guideline\n      };\n    }).filter(function (_a) {\n      var guideline = _a.guideline,\n          dist = _a.dist;\n      var type = guideline.type,\n          center = guideline.center,\n          element = guideline.element;\n\n      if (!snapElement && element || !snapCenter && center || type !== targetType || dist > snapThreshold) {\n        return false;\n      }\n\n      return true;\n    }).sort(function (a, b) {\n      return a.dist - b.dist;\n    });\n    return {\n      pos: targetPos,\n      index: index,\n      guidelineInfos: guidelineInfos\n    };\n  }).filter(function (snapPosInfo) {\n    return snapPosInfo.guidelineInfos.length > 0;\n  }).sort(function (a, b) {\n    return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n  });\n  var isSnap = snapPosInfos.length > 0;\n  return {\n    isSnap: isSnap,\n    index: isSnap ? snapPosInfos[0].index : -1,\n    posInfos: snapPosInfos\n  };\n}\n\nfunction getSnapInfosByDirection(moveable, poses, snapDirection) {\n  var nextPoses = [];\n\n  if (snapDirection[0] && snapDirection[1]) {\n    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function (direction) {\n      return getPosByDirection(poses, direction);\n    });\n  } else if (!snapDirection[0] && !snapDirection[1]) {\n    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n    for (var i = 0; i < 4; ++i) {\n      nextPoses.push(alignPoses[i]);\n      nextPoses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);\n    }\n  } else {\n    if (moveable.props.keepRatio) {\n      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function (dir) {\n        return getPosByDirection(poses, dir);\n      });\n    } else {\n      nextPoses = getPosesByDirection(poses, snapDirection);\n\n      if (nextPoses.length > 1) {\n        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);\n      }\n    }\n  }\n\n  return checkMoveableSnapPoses(moveable, nextPoses.map(function (pos) {\n    return pos[0];\n  }), nextPoses.map(function (pos) {\n    return pos[1];\n  }), true, 1);\n}\n\nfunction checkSnapBoundPriority(a, b) {\n  var aDist = Math.abs(a.offset);\n  var bDist = Math.abs(b.offset);\n\n  if (a.isBound && b.isBound) {\n    return bDist - aDist;\n  } else if (a.isBound) {\n    return -1;\n  } else if (b.isBound) {\n    return 1;\n  } else if (a.isSnap && b.isSnap) {\n    return bDist - aDist;\n  } else if (a.isSnap) {\n    return -1;\n  } else if (b.isSnap) {\n    return 1;\n  } else if (aDist < TINY_NUM) {\n    return 1;\n  } else if (bDist < TINY_NUM) {\n    return -1;\n  }\n\n  return aDist - bDist;\n}\n\nfunction getNearOffsetInfo(offsets, index) {\n  return offsets.slice().sort(function (a, b) {\n    var aSign = a.sign[index];\n    var bSign = b.sign[index];\n    var aOffset = a.offset[index];\n    var bOffset = b.offset[index]; // -1 The positions of a and b do not change.\n    // 1 The positions of a and b are reversed.\n\n    if (!aSign) {\n      return 1;\n    } else if (!bSign) {\n      return -1;\n    }\n\n    return checkSnapBoundPriority({\n      isBound: a.isBound,\n      isSnap: a.isSnap,\n      offset: aOffset\n    }, {\n      isBound: b.isBound,\n      isSnap: b.isSnap,\n      offset: bOffset\n    });\n  })[0];\n}\n\nfunction isStartLine(dot, line) {\n  // l    o     => true\n  // o    l    => false\n  var cx = average([line[0][0], line[1][0]]);\n  var cy = average([line[0][1], line[1][1]]);\n  return {\n    vertical: cx <= dot[0],\n    horizontal: cy <= dot[1]\n  };\n}\n\nfunction hitTestLine(dot, _a) {\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  var test1;\n  var test2;\n\n  if (!dx) {\n    test1 = pos1[0];\n    test2 = dot[0];\n  } else if (!dy) {\n    test1 = pos1[1];\n    test2 = dot[1];\n  } else {\n    var a = dy / dx; // y = a * (x - pos1) + pos1\n\n    test1 = a * (dot[0] - pos1[0]) + pos1[1];\n    test2 = dot[1];\n  }\n\n  return test1 - test2;\n}\n\nfunction isSameStartLine(dots, line, error) {\n  if (error === void 0) {\n    error = TINY_NUM;\n  }\n\n  var centerSign = hitTestLine(dots[0], line) <= 0;\n  return dots.slice(1).every(function (dot) {\n    var value = hitTestLine(dot, line);\n    var sign = value <= 0;\n    return sign === centerSign || Math.abs(value) <= error;\n  });\n}\n\nfunction checkInnerBoundDot(pos, start, end, isStart, threshold) {\n  if (threshold === void 0) {\n    threshold = 0;\n  }\n\n  if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {\n    // false 402 565 602 => 37 ([0, 37])\n    // true 400 524.9712603540036 600 => 124 ([124, 0])\n    // true 400 410 600 => 10 ([10, 0])\n    return {\n      isBound: true,\n      offset: isStart ? start - pos : end - pos\n    };\n  }\n\n  return {\n    isBound: false,\n    offset: 0\n  };\n}\n\nfunction checkInnerBound(moveable, line, center) {\n  var bounds = moveable.props.innerBounds;\n\n  if (!bounds) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0]\n    };\n  }\n\n  var left = bounds.left,\n      top = bounds.top,\n      width = bounds.width,\n      height = bounds.height;\n  var leftLine = [[left, top], [left, top + height]];\n  var topLine = [[left, top], [left + width, top]];\n  var rightLine = [[left + width, top], [left + width, top + height]];\n  var bottomLine = [[left, top + height], [left + width, top + height]];\n\n  var _a = isStartLine(center, line),\n      isHorizontalStart = _a.horizontal,\n      isVerticalStart = _a.vertical;\n\n  if (isSameStartLine([center, [left, top], [left + width, top], [left, top + height], [left + width, top + height]], line)) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0]\n    };\n  } // test vertical\n\n\n  var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n  var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart); // test horizontal\n\n  var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n  var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n  var offset = [0, 0];\n  var isBound = false;\n  var isAllBound = false;\n\n  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n    offset = [verticalOffset, 0];\n    isBound = isVerticalBound;\n    isAllBound = isAllVerticalBound;\n  } else {\n    offset = [0, horizontalOffset];\n    isBound = isHorizontalBound;\n    isAllBound = isAllHorizontalBound;\n  }\n\n  return {\n    isAllBound: isAllBound,\n    isVerticalBound: isVerticalBound,\n    isHorizontalBound: isHorizontalBound,\n    isBound: isBound,\n    offset: offset\n  };\n}\n\nfunction checkLineBoundCollision(line, boundLine, isStart, threshold, isRender) {\n  var dot1 = line[0];\n  var dot2 = line[1];\n  var boundDot1 = boundLine[0];\n  var boundDot2 = boundLine[1];\n  var dy1 = getTinyDist(dot2[1] - dot1[1]);\n  var dx1 = getTinyDist(dot2[0] - dot1[0]);\n  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]); // dx2 or dy2 is zero\n\n  if (!dx2) {\n    // vertical\n    if (isRender && !dy1) {\n      // 90deg\n      return {\n        isBound: false,\n        offset: 0\n      };\n    } else if (dx1) {\n      // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n      var y = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1]; // boundDot1[1] <= y  <= boundDot2[1]\n\n      return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n    } else {\n      var offset = boundDot1[0] - dot1[0];\n      var isBound = Math.abs(offset) <= (threshold || 0);\n      return {\n        isBound: isBound,\n        offset: isBound ? offset : 0\n      };\n    }\n  } else if (!dy2) {\n    // horizontal\n    if (isRender && !dx1) {\n      // 90deg\n      return {\n        isBound: false,\n        offset: 0\n      };\n    } else if (dy1) {\n      // y = a * (x - x1) + y1\n      // x = (y - y1) / a + x1\n      // const a = dy1 / dx1;\n      // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n      var x = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0]; // boundDot1[0] <= x && x <= boundDot2[0]\n\n      return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n    } else {\n      var offset = boundDot1[1] - dot1[1];\n      var isBound = Math.abs(offset) <= (threshold || 0);\n      return {\n        isBound: isBound,\n        offset: isBound ? offset : 0\n      };\n    }\n  }\n\n  return {\n    isBound: false,\n    offset: 0\n  };\n}\n\nfunction getInnerBoundInfo(moveable, lines, center, datas) {\n  return lines.map(function (_a) {\n    var multiple = _a[0],\n        pos1 = _a[1],\n        pos2 = _a[2];\n\n    var _b = checkInnerBound(moveable, [pos1, pos2], center),\n        isBound = _b.isBound,\n        offset = _b.offset,\n        isVerticalBound = _b.isVerticalBound,\n        isHorizontalBound = _b.isHorizontalBound;\n\n    var sizeOffset = getDragDist({\n      datas: datas,\n      distX: offset[0],\n      distY: offset[1]\n    }).map(function (size, i) {\n      return size * (multiple[i] ? 2 / multiple[i] : 0);\n    });\n    return {\n      sign: multiple,\n      isBound: isBound,\n      isVerticalBound: isVerticalBound,\n      isHorizontalBound: isHorizontalBound,\n      isSnap: false,\n      offset: sizeOffset\n    };\n  });\n}\n\nfunction getInnerBoundDragInfo(moveable, poses, datas) {\n  var _a;\n\n  var lines = getCheckInnerBoundLines(poses, [0, 0], false).map(function (_a) {\n    var sign = _a[0],\n        pos1 = _a[1],\n        pos2 = _a[2];\n    return [sign.map(function (dir) {\n      return Math.abs(dir) * 2;\n    }), pos1, pos2];\n  });\n  var innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n  var verticalOffset = 0;\n  var horizontalOffset = 0;\n  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n  if (isVerticalBound || isHorizontalBound) {\n    _a = getInverseDragDist({\n      datas: datas,\n      distX: -widthOffsetInfo.offset[0],\n      distY: -heightOffsetInfo.offset[1]\n    }), verticalOffset = _a[0], horizontalOffset = _a[1];\n  }\n\n  return {\n    vertical: {\n      isBound: isVerticalBound,\n      offset: verticalOffset\n    },\n    horizontal: {\n      isBound: isHorizontalBound,\n      offset: horizontalOffset\n    }\n  };\n}\n\nfunction getCheckSnapLineDirections(direction, keepRatio) {\n  var lineDirections = [];\n  var x = direction[0];\n  var y = direction[1];\n\n  if (x && y) {\n    lineDirections.push([[0, y * 2], direction, [-x, y]], [[x * 2, 0], direction, [x, -y]]);\n  } else if (x) {\n    // vertcal\n    lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);\n\n    if (keepRatio) {\n      lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);\n    }\n  } else if (y) {\n    // horizontal\n    lineDirections.push([[0, y * 2], [1, y], [-1, y]]);\n\n    if (keepRatio) {\n      lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);\n    }\n  } else {\n    // [0, 0] to all direction\n    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);\n  }\n\n  return lineDirections;\n}\n\nfunction getCheckInnerBoundLines(poses, direction, keepRatio) {\n  return getCheckSnapLineDirections(direction, keepRatio).map(function (_a) {\n    var sign = _a[0],\n        dir1 = _a[1],\n        dir2 = _a[2];\n    return [sign, getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)];\n  });\n}\n\nfunction isBoundRotate(relativePoses, boundDots, center, rad) {\n  var nextPoses = rad ? relativePoses.map(function (pos) {\n    return rotate(pos, rad);\n  }) : relativePoses;\n\n  var dots = __spreadArrays([center], boundDots);\n\n  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function (line) {\n    return !isSameStartLine(dots, line);\n  });\n}\n\nfunction getDistPointLine(_a) {\n  // x = 0, y = 0\n  // d = (ax + by + c) / root(a2 + b2)\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (!dx) {\n    return Math.abs(pos1[0]);\n  }\n\n  if (!dy) {\n    return Math.abs(pos1[1]);\n  } // y - y1 = a(x - x1)\n  // 0 = ax -y + -a * x1 + y1\n\n\n  var a = dy / dx;\n  return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\n\nfunction solveReverseLine(_a) {\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (!dx) {\n    return [pos1[0], 0];\n  }\n\n  if (!dy) {\n    return [0, pos1[1]];\n  }\n\n  var a = dy / dx; // y - y1 = a (x  - x1)\n  // y = ax - a * x1 + y1\n\n  var b = -a * pos1[0] + pos1[1]; // y = ax + b = -1/a x\n  // x = -b / (a + 1 / a)\n  // y = b / (1 + 1 / a^2)\n\n  return [-b / (a + 1 / a), b / (a * a + 1)];\n}\n\nfunction checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n  var bounds = moveable.props.innerBounds;\n  var rad = rotation * Math.PI / 180;\n\n  if (!bounds) {\n    return [];\n  }\n\n  var left = bounds.left,\n      top = bounds.top,\n      width = bounds.width,\n      height = bounds.height;\n  var relativeLeft = left - origin[0];\n  var relativeRight = left + width - origin[0];\n  var relativeTop = top - origin[1];\n  var relativeBottom = top + height - origin[1];\n  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];\n  var center = getPosByDirection(nextPoses, [0, 0]);\n\n  if (!isBoundRotate(nextPoses, dots, center, 0)) {\n    return [];\n  }\n\n  var result = [];\n  var dotInfos = dots.map(function (dot) {\n    return [getDistSize(dot), getRad([0, 0], dot)];\n  });\n  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function (line) {\n    var lineRad = getRad([0, 0], solveReverseLine(line));\n    var lineDist = getDistPointLine(line);\n    result.push.apply(result, dotInfos.filter(function (_a) {\n      var dotDist = _a[0];\n      return dotDist && lineDist <= dotDist;\n    }).map(function (_a) {\n      var dotDist = _a[0],\n          dotRad = _a[1];\n      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n      var nextRad1 = dotRad + distRad;\n      var nextRad2 = dotRad - distRad;\n      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];\n    }).reduce(function (prev, cur) {\n      prev.push.apply(prev, cur);\n      return prev;\n    }, []).filter(function (nextRad) {\n      return !isBoundRotate(prevPoses, dots, center, nextRad);\n    }).map(function (nextRad) {\n      return throttle(nextRad * 180 / Math.PI, TINY_NUM);\n    }));\n  });\n  return result;\n}\n\nfunction checkInnerBoundPoses(moveable) {\n  var innerBounds = moveable.props.innerBounds;\n\n  if (!innerBounds) {\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  }\n\n  var _a = moveable.getRect(),\n      pos1 = _a.pos1,\n      pos2 = _a.pos2,\n      pos3 = _a.pos3,\n      pos4 = _a.pos4;\n\n  var poses = [pos1, pos2, pos3, pos4];\n  var center = getPosByDirection(poses, [0, 0]);\n  var left = innerBounds.left,\n      top = innerBounds.top,\n      width = innerBounds.width,\n      height = innerBounds.height;\n  var leftLine = [[left, top], [left, top + height]];\n  var topLine = [[left, top], [left + width, top]];\n  var rightLine = [[left + width, top], [left + width, top + height]];\n  var bottomLine = [[left, top + height], [left + width, top + height]];\n  var lines = [[pos1, pos2], [pos2, pos4], [pos4, pos3], [pos3, pos1]];\n  var horizontalPoses = [];\n  var verticalPoses = [];\n  var boundMap = {\n    top: false,\n    bottom: false,\n    left: false,\n    right: false\n  };\n  lines.forEach(function (line) {\n    var _a = isStartLine(center, line),\n        isHorizontalStart = _a.horizontal,\n        isVerticalStart = _a.vertical; // test vertical\n\n\n    var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);\n    var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true); // test horizontal\n\n    var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);\n    var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);\n\n    if (topBoundInfo.isBound && !boundMap.top) {\n      horizontalPoses.push(top);\n      boundMap.top = true;\n    }\n\n    if (bottomBoundInfo.isBound && !boundMap.bottom) {\n      horizontalPoses.push(top + height);\n      boundMap.bottom = true;\n    }\n\n    if (leftBoundInfo.isBound && !boundMap.left) {\n      verticalPoses.push(left);\n      boundMap.left = true;\n    }\n\n    if (rightBoundInfo.isBound && !boundMap.right) {\n      verticalPoses.push(left + width);\n      boundMap.right = true;\n    }\n  });\n  return {\n    horizontal: horizontalPoses,\n    vertical: verticalPoses\n  };\n}\n\nfunction checkBoundPoses(bounds, verticalPoses, horizontalPoses) {\n  var _a = bounds || {},\n      _b = _a.position,\n      position = _b === void 0 ? \"client\" : _b,\n      _c = _a.left,\n      left = _c === void 0 ? -Infinity : _c,\n      _d = _a.top,\n      top = _d === void 0 ? -Infinity : _d,\n      _e = _a.right,\n      right = _e === void 0 ? Infinity : _e,\n      _f = _a.bottom,\n      bottom = _f === void 0 ? Infinity : _f;\n\n  var nextBounds = {\n    position: position,\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom\n  };\n  return {\n    vertical: checkBounds(nextBounds, verticalPoses, true),\n    horizontal: checkBounds(nextBounds, horizontalPoses, false)\n  };\n}\n\nfunction getBounds(moveable, externalBounds) {\n  var _a = moveable.state,\n      _b = _a.containerClientRect,\n      containerHeight = _b.clientHeight,\n      containerWidth = _b.clientWidth,\n      clientLeft = _b.clientLeft,\n      clientTop = _b.clientTop,\n      _c = _a.snapOffset,\n      snapOffsetLeft = _c.left,\n      snapOffsetTop = _c.top,\n      snapOffsetRight = _c.right,\n      snapOffsetBottom = _c.bottom;\n  var bounds = externalBounds || moveable.props.bounds || {};\n  var position = bounds.position || \"client\";\n  var isCSS = position === \"css\";\n  var _d = bounds.left,\n      left = _d === void 0 ? -Infinity : _d,\n      _e = bounds.top,\n      top = _e === void 0 ? -Infinity : _e;\n  var _f = bounds.right,\n      right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f,\n      _g = bounds.bottom,\n      bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;\n\n  if (isCSS) {\n    right = containerWidth + snapOffsetRight - snapOffsetLeft - right;\n    bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;\n  }\n\n  return {\n    left: left + snapOffsetLeft - clientLeft,\n    right: right + snapOffsetLeft - clientLeft,\n    top: top + snapOffsetTop - clientTop,\n    bottom: bottom + snapOffsetTop - clientTop\n  };\n}\n\nfunction checkBoundKeepRatio(moveable, startPos, endPos) {\n  var _a = getBounds(moveable),\n      left = _a.left,\n      top = _a.top,\n      right = _a.right,\n      bottom = _a.bottom;\n\n  var endX = endPos[0],\n      endY = endPos[1];\n\n  var _b = minus(endPos, startPos),\n      dx = _b[0],\n      dy = _b[1];\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  var isBottom = dy > 0;\n  var isRight = dx > 0;\n  var verticalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n  var horizontalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo\n    };\n  } else if (dx === 0) {\n    if (isBottom) {\n      if (bottom < endY) {\n        horizontalInfo.pos = bottom;\n        horizontalInfo.offset = endY - bottom;\n      }\n    } else {\n      if (top > endY) {\n        horizontalInfo.pos = top;\n        horizontalInfo.offset = endY - top;\n      }\n    }\n  } else if (dy === 0) {\n    if (isRight) {\n      if (right < endX) {\n        verticalInfo.pos = right;\n        verticalInfo.offset = endX - right;\n      }\n    } else {\n      if (left > endX) {\n        verticalInfo.pos = left;\n        verticalInfo.offset = endX - left;\n      }\n    }\n  } else {\n    // y - y1 = a * (x - x1)\n    var a = dy / dx;\n    var b = endPos[1] - a * endX;\n    var y = 0;\n    var x = 0;\n    var isBound = false;\n\n    if (isRight && right <= endX) {\n      y = a * right + b;\n      x = right;\n      isBound = true;\n    } else if (!isRight && endX <= left) {\n      y = a * left + b;\n      x = left;\n      isBound = true;\n    }\n\n    if (isBound) {\n      if (y < top || y > bottom) {\n        isBound = false;\n      }\n    }\n\n    if (!isBound) {\n      if (isBottom && bottom <= endY) {\n        y = bottom;\n        x = (y - b) / a;\n        isBound = true;\n      } else if (!isBottom && endY <= top) {\n        y = top;\n        x = (y - b) / a;\n        isBound = true;\n      }\n    }\n\n    if (isBound) {\n      verticalInfo.isBound = true;\n      verticalInfo.pos = x;\n      verticalInfo.offset = endX - x;\n      horizontalInfo.isBound = true;\n      horizontalInfo.pos = y;\n      horizontalInfo.offset = endY - y;\n    }\n  }\n\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo\n  };\n}\n\nfunction checkBounds(bounds, poses, isVertical) {\n  // 0   [100 - 200]  300\n  var startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n  var endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"]; // 450\n\n  var minPos = Math.min.apply(Math, poses);\n  var maxPos = Math.max.apply(Math, poses);\n  var boundInfos = [];\n\n  if (startBoundPos + 1 > minPos) {\n    boundInfos.push({\n      isBound: true,\n      offset: minPos - startBoundPos,\n      pos: startBoundPos\n    });\n  }\n\n  if (endBoundPos - 1 < maxPos) {\n    boundInfos.push({\n      isBound: true,\n      offset: maxPos - endBoundPos,\n      pos: endBoundPos\n    });\n  }\n\n  if (!boundInfos.length) {\n    boundInfos.push({\n      isBound: false,\n      offset: 0,\n      pos: 0\n    });\n  }\n\n  return boundInfos.sort(function (a, b) {\n    return Math.abs(b.offset) - Math.abs(a.offset);\n  });\n}\n\nfunction isBoundRotate$1(relativePoses, boundRect, rad) {\n  var nextPoses = rad ? relativePoses.map(function (pos) {\n    return rotate(pos, rad);\n  }) : relativePoses;\n  return nextPoses.some(function (pos) {\n    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;\n  });\n}\n\nfunction boundRotate(vec, boundPos, index) {\n  var r = getDistSize(vec);\n  var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n  return [nextPos, -nextPos].sort(function (a, b) {\n    return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n  }).map(function (pos) {\n    return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n  });\n}\n\nfunction checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n  if (!moveable.props.bounds) {\n    return [];\n  }\n\n  var rad = rotation * Math.PI / 180;\n\n  var _a = getBounds(moveable),\n      left = _a.left,\n      top = _a.top,\n      right = _a.right,\n      bottom = _a.bottom;\n\n  var relativeLeft = left - origin[0];\n  var relativeRight = right - origin[0];\n  var relativeTop = top - origin[1];\n  var relativeBottom = bottom - origin[1];\n  var boundRect = {\n    left: relativeLeft,\n    top: relativeTop,\n    right: relativeRight,\n    bottom: relativeBottom\n  };\n\n  if (!isBoundRotate$1(nextPoses, boundRect, 0)) {\n    return [];\n  }\n\n  var result = [];\n  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function (_a) {\n    var boundPos = _a[0],\n        index = _a[1];\n    nextPoses.forEach(function (nextPos) {\n      var relativeRad1 = getRad([0, 0], nextPos);\n      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function (relativeRad2) {\n        return rad + relativeRad2 - relativeRad1;\n      }).filter(function (nextRad) {\n        return !isBoundRotate$1(prevPoses, boundRect, nextRad);\n      }).map(function (nextRad) {\n        return throttle(nextRad * 180 / Math.PI, TINY_NUM);\n      }));\n    });\n  });\n  return result;\n}\n\nvar DIRECTION_NAMES = {\n  horizontal: [\"left\", \"top\", \"width\", \"Y\", \"X\"],\n  vertical: [\"top\", \"left\", \"height\", \"X\", \"Y\"]\n};\n\nfunction groupByElementGuidelines(guidelines, clientPos, size, index) {\n  var groupInfos = [];\n  var group = groupBy(guidelines.filter(function (_a) {\n    var element = _a.element,\n        gap = _a.gap;\n    return element && !gap;\n  }), function (_a) {\n    var element = _a.element,\n        pos = _a.pos;\n    var elementPos = pos[index];\n    var sign = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;\n    var groupKey = sign + \"_\" + pos[index ? 0 : 1];\n    var groupInfo = find(groupInfos, function (_a) {\n      var groupElement = _a[0],\n          groupPos = _a[1];\n      return element === groupElement && elementPos === groupPos;\n    });\n\n    if (groupInfo) {\n      return groupInfo[2];\n    }\n\n    groupInfos.push([element, elementPos, groupKey]);\n    return groupKey;\n  });\n  group.forEach(function (elementGuidelines) {\n    elementGuidelines.sort(function (a, b) {\n      var result = getElementGuidelineDist(a.pos[index], a.size, clientPos, size).size - getElementGuidelineDist(b.pos[index], a.size, clientPos, size).size;\n      return result || a.pos[index ? 0 : 1] - b.pos[index ? 0 : 1];\n    });\n  });\n  return group;\n}\n\nfunction getElementGuidelineDist(elementPos, elementSize, targetPos, targetSize) {\n  // relativePos < 0  => element(l)  ---  (r)target\n  // relativePos > 0  => target(l)   ---  (r)element\n  var relativePos = elementPos - targetPos;\n  var startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n  var endPos = relativePos < 0 ? 0 : relativePos;\n  var size = endPos - startPos;\n  return {\n    size: size,\n    pos: startPos\n  };\n}\n\nfunction renderGuideline(info, React) {\n  var _a;\n\n  var direction = info.direction,\n      classNames = info.classNames,\n      size = info.size,\n      pos = info.pos,\n      zoom = info.zoom,\n      key = info.key;\n  var isHorizontal = direction === \"horizontal\";\n  var scaleDirection = isHorizontal ? \"Y\" : \"X\"; // const scaleDirection2 = isHorizontal ? \"Y\" : \"X\";\n\n  return React.createElement(\"div\", {\n    key: key,\n    className: classNames.join(\" \"),\n    style: (_a = {}, _a[isHorizontal ? \"width\" : \"height\"] = \"\" + size, _a.transform = \"translate(\" + pos[0] + \", \" + pos[1] + \") translate\" + scaleDirection + \"(-50%) scale\" + scaleDirection + \"(\" + zoom + \")\", _a)\n  });\n}\n\nfunction renderInnerGuideline(info, React) {\n  return renderGuideline(_assign(_assign({}, info), {\n    classNames: __spreadArrays([prefix(\"line\", \"guideline\", info.direction)], info.classNames).filter(function (className) {\n      return className;\n    }),\n    size: info.size || info.sizeValue + \"px\",\n    pos: info.pos || info.posValue.map(function (v) {\n      return throttle(v, 0.1) + \"px\";\n    })\n  }), React);\n}\n\nfunction renderElementGroups(moveable, direction, groups, minPos, clientPos, clientSize, targetPos, snapThreshold, snapDigit, index, snapDistFormat, React) {\n  var _a = moveable.props,\n      zoom = _a.zoom,\n      _b = _a.isDisplaySnapDigit,\n      isDisplaySnapDigit = _b === void 0 ? true : _b;\n  var _c = DIRECTION_NAMES[direction],\n      posName1 = _c[0],\n      posName2 = _c[1],\n      sizeName = _c[2],\n      scaleDirection = _c[4];\n  return flat(groups.map(function (elementGuidelines, i) {\n    var isFirstRenderSize = true;\n    return elementGuidelines.map(function (_a, j) {\n      var _b;\n\n      var pos = _a.pos,\n          size = _a.size;\n\n      var _c = getElementGuidelineDist(pos[index], size, clientPos, clientSize),\n          linePos = _c.pos,\n          lineSize = _c.size;\n\n      if (lineSize < snapThreshold) {\n        return null;\n      }\n\n      var isRenderSize = isFirstRenderSize;\n      isFirstRenderSize = false;\n      var snapSize = isDisplaySnapDigit && isRenderSize ? parseFloat(lineSize.toFixed(snapDigit)) : 0;\n      return React.createElement(\"div\", {\n        key: direction + \"LinkGuideline\" + i + \"-\" + j,\n        className: prefix(\"guideline-group\", direction),\n        style: (_b = {}, _b[posName1] = minPos + linePos + \"px\", _b[posName2] = -targetPos + pos[index ? 0 : 1] + \"px\", _b[sizeName] = lineSize + \"px\", _b)\n      }, renderInnerGuideline({\n        direction: direction,\n        classNames: [prefix(\"dashed\")],\n        size: \"100%\",\n        posValue: [0, 0],\n        sizeValue: lineSize,\n        zoom: zoom\n      }, React), React.createElement(\"div\", {\n        className: prefix(\"size-value\"),\n        style: {\n          transform: \"translate\" + scaleDirection + \"(-50%) scale(\" + zoom + \")\"\n        }\n      }, snapSize > 0 ? snapDistFormat(snapSize) : \"\"));\n    });\n  }));\n}\n\nfunction renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {\n  var zoom = moveable.props.zoom;\n  return snapPoses.map(function (_a, i) {\n    var type = _a.type,\n        pos = _a.pos;\n    var renderPos = [0, 0];\n    renderPos[index] = minPos;\n    renderPos[index ? 0 : 1] = -targetPos + pos;\n    return renderInnerGuideline({\n      key: direction + \"TargetGuideline\" + i,\n      classNames: [prefix(\"target\", \"bold\", type)],\n      posValue: renderPos,\n      sizeValue: size,\n      zoom: zoom,\n      direction: direction\n    }, React);\n  });\n}\n\nfunction filterElementInnerGuidelines(moveable, guidelines, index, targetPos, clientPos, targetSizes) {\n  var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;\n  var otherIndex = index ? 0 : 1;\n  var targetContentPos = targetPos[index];\n  var targetContentSize = targetSizes[index];\n  var gapGuidelines = [];\n  var nextGuidelines = guidelines.filter(function (guideline) {\n    var element = guideline.element,\n        pos = guideline.pos,\n        size = guideline.size;\n\n    if (isDisplayInnerSnapDigit && element && pos[index] < targetContentPos && targetContentPos + targetContentSize < pos[index] + size) {\n      var contentPos = pos[index] - targetContentPos;\n      var inlinePos = pos[otherIndex] - targetPos[otherIndex];\n      gapGuidelines.push(_assign(_assign({}, guideline), {\n        inner: true,\n        gap: contentPos,\n        renderPos: index ? [inlinePos, contentPos] : [contentPos, inlinePos]\n      }));\n      gapGuidelines.push(_assign(_assign({}, guideline), {\n        inner: true,\n        gap: pos[index] + size - targetContentPos - targetContentSize,\n        renderPos: index ? [inlinePos, targetContentSize] : [targetContentSize, inlinePos]\n      }));\n      return false;\n    }\n\n    return true;\n  });\n  nextGuidelines = nextGuidelines.filter(function (guideline1) {\n    var element1 = guideline1.element,\n        pos1 = guideline1.pos,\n        size1 = guideline1.size;\n    var contentPos1 = pos1[index];\n\n    if (!element1) {\n      return true;\n    }\n\n    return nextGuidelines.every(function (guideline2) {\n      var element2 = guideline2.element,\n          pos2 = guideline2.pos,\n          size2 = guideline2.size;\n      var contentPos2 = pos2[index];\n\n      if (!element2 || guideline1 === guideline2) {\n        return true;\n      }\n\n      return contentPos1 + size1 <= contentPos2 || contentPos2 + size2 <= contentPos1 || contentPos1 < contentPos2 && contentPos2 + size2 < contentPos1 + size1;\n    });\n  });\n  var groups = groupByElementGuidelines(nextGuidelines, clientPos[index], targetContentSize, index);\n  gapGuidelines = gapGuidelines.filter(function (guideline) {\n    var gap = guideline.gap;\n    var inlinePos = guideline.pos[otherIndex];\n    return groups.every(function (group) {\n      return group.every(function (groupGuideline) {\n        var groupPos = groupGuideline.pos;\n        var renderPos = -targetContentPos + groupPos[index];\n\n        if (groupPos[otherIndex] !== inlinePos) {\n          return true;\n        }\n\n        if (gap < 0 && renderPos < 0) {\n          return false;\n        }\n\n        if (gap > 0 && renderPos > targetSizes[index]) {\n          return false;\n        }\n\n        return true;\n      });\n    });\n  });\n  return {\n    guidelines: nextGuidelines,\n    groups: groups,\n    gapGuidelines: gapGuidelines\n  };\n}\n\nfunction renderGuidelines(moveable, direction, guidelines, targetPos, React) {\n  var zoom = moveable.props.zoom;\n  return guidelines.filter(function (_a) {\n    var hide = _a.hide;\n    return !hide;\n  }).map(function (guideline, i) {\n    var pos = guideline.pos,\n        size = guideline.size,\n        element = guideline.element;\n    var renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];\n    return renderInnerGuideline({\n      key: direction + \"Guideline\" + i,\n      classNames: element ? [prefix(\"bold\")] : [],\n      direction: direction,\n      posValue: renderPos,\n      sizeValue: size,\n      zoom: zoom\n    }, React);\n  });\n}\n\nfunction renderGapGuidelines(moveable, direction, gapGuidelines, snapDistFormat, React) {\n  var _a = moveable.props,\n      _b = _a.snapDigit,\n      snapDigit = _b === void 0 ? 0 : _b,\n      _c = _a.isDisplaySnapDigit,\n      isDisplaySnapDigit = _c === void 0 ? true : _c,\n      zoom = _a.zoom;\n  var scaleDirection = direction === \"horizontal\" ? \"X\" : \"Y\";\n  var sizeName = direction === \"horizontal\" ? \"width\" : \"height\";\n  return gapGuidelines.map(function (_a, i) {\n    var _b;\n\n    var renderPos = _a.renderPos,\n        gap = _a.gap,\n        className = _a.className,\n        inner = _a.inner;\n    var absGap = Math.abs(gap);\n    var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;\n    return React.createElement(\"div\", {\n      key: direction + \"GapGuideline\" + i,\n      className: prefix(\"guideline-group\", direction),\n      style: (_b = {\n        left: renderPos[0] + \"px\",\n        top: renderPos[1] + \"px\"\n      }, _b[sizeName] = absGap + \"px\", _b)\n    }, renderInnerGuideline({\n      direction: direction,\n      classNames: [prefix(inner ? \"dashed\" : \"gap\"), className],\n      size: \"100%\",\n      posValue: [0, 0],\n      sizeValue: absGap,\n      zoom: zoom\n    }, React), React.createElement(\"div\", {\n      className: prefix(\"size-value\", \"gap\"),\n      style: {\n        transform: \"translate\" + scaleDirection + \"(-50%) scale(\" + zoom + \")\"\n      }\n    }, snapSize > 0 ? snapDistFormat(snapSize) : \"\"));\n  });\n}\n\nfunction snapStart(moveable) {\n  var state = moveable.state;\n\n  if (state.guidelines && state.guidelines.length) {\n    return;\n  }\n\n  var container = moveable.state.container;\n  var snapContainer = moveable.props.snapContainer || container;\n  var containerClientRect = state.containerClientRect;\n  var snapOffset = {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  };\n\n  if (container !== snapContainer) {\n    var snapContainerTarget = getRefTarget(snapContainer, true);\n\n    if (snapContainerTarget) {\n      var snapContainerRect = getClientRect(snapContainerTarget);\n      var offset1 = getDragDistByState(state, [snapContainerRect.left - containerClientRect.left, snapContainerRect.top - containerClientRect.top]);\n      var offset2 = getDragDistByState(state, [snapContainerRect.right - containerClientRect.right, snapContainerRect.bottom - containerClientRect.bottom]);\n      snapOffset.left = throttle(offset1[0], 0.1);\n      snapOffset.top = throttle(offset1[1], 0.1);\n      snapOffset.right = throttle(offset2[0], 0.1);\n      snapOffset.bottom = throttle(offset2[1], 0.1);\n    }\n  }\n\n  state.snapOffset = snapOffset;\n  state.elementGuidelineValues = [];\n  state.staticGuidelines = getElementGuidelines(moveable, false);\n  state.guidelines = getTotalGuidelines(moveable);\n  state.enableSnap = true;\n}\n\nfunction hasGuidelines(moveable, ableName) {\n  var _a = moveable.props,\n      snappable = _a.snappable,\n      bounds = _a.bounds,\n      innerBounds = _a.innerBounds,\n      verticalGuidelines = _a.verticalGuidelines,\n      horizontalGuidelines = _a.horizontalGuidelines,\n      snapGridWidth = _a.snapGridWidth,\n      snapGridHeight = _a.snapGridHeight,\n      _b = moveable.state,\n      guidelines = _b.guidelines,\n      enableSnap = _b.enableSnap;\n\n  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {\n    return false;\n  }\n\n  if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction solveNextOffset(pos1, pos2, offset, isVertical, datas) {\n  var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n\n  if (!sizeOffset) {\n    return {\n      isOutside: false,\n      offset: [0, 0]\n    };\n  }\n\n  var size = getDist$1(pos1, pos2);\n  var dist1 = getDist$1(sizeOffset, pos1);\n  var dist2 = getDist$1(sizeOffset, pos2);\n  var isOutside = dist1 > size || dist2 > size;\n\n  var _a = getDragDist({\n    datas: datas,\n    distX: sizeOffset[0],\n    distY: sizeOffset[1]\n  }),\n      widthOffset = _a[0],\n      heightOffset = _a[1];\n\n  return {\n    offset: [widthOffset, heightOffset],\n    isOutside: isOutside\n  };\n}\n\nfunction getNextFixedPoses(matrix, width, height, fixedPos, direction, is3d) {\n  var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n  var nextPos = getPosByReverseDirection(nextPoses, direction);\n  return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\n\nfunction getSnapBoundOffset(boundInfo, snapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return snapInfo.offset;\n  }\n\n  return 0;\n}\n\nfunction getSnapBound(boundInfo, snapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return getNearestSnapGuidelineInfo(snapInfo).offset;\n  }\n\n  return 0;\n}\n\nfunction checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {\n  var _a = checkBoundKeepRatio(moveable, startPos, endPos),\n      horizontalBoundInfo = _a.horizontal,\n      verticalBoundInfo = _a.vertical;\n\n  var _b = isRequest ? {\n    horizontal: {\n      isSnap: false\n    },\n    vertical: {\n      isSnap: false\n    }\n  } : checkSnapKeepRatio(moveable, startPos, endPos),\n      horizontalSnapInfo = _b.horizontal,\n      verticalSnapInfo = _b.vertical;\n\n  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfo.isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      offset: horizontalOffset,\n      dist: horizontalDist\n    },\n    vertical: {\n      isBound: verticalBoundInfo.isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      offset: verticalOffset,\n      dist: verticalDist\n    }\n  };\n}\n\nfunction checkMoveableSnapBounds(moveable, isRequest, poses, boundPoses) {\n  if (boundPoses === void 0) {\n    boundPoses = poses;\n  }\n\n  var _a = checkBoundPoses(getBounds(moveable), boundPoses.map(function (pos) {\n    return pos[0];\n  }), boundPoses.map(function (pos) {\n    return pos[1];\n  })),\n      horizontalBoundInfos = _a.horizontal,\n      verticalBoundInfos = _a.vertical;\n\n  var _b = isRequest ? {\n    horizontal: {\n      isSnap: false,\n      index: -1\n    },\n    vertical: {\n      isSnap: false,\n      index: -1\n    }\n  } : checkMoveableSnapPoses(moveable, poses.map(function (pos) {\n    return pos[0];\n  }), poses.map(function (pos) {\n    return pos[1];\n  }), moveable.props.snapCenter),\n      horizontalSnapInfo = _b.horizontal,\n      verticalSnapInfo = _b.vertical;\n\n  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);\n  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfos[0].isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      snapIndex: horizontalSnapInfo.index,\n      offset: horizontalOffset,\n      dist: horizontalDist,\n      bounds: horizontalBoundInfos,\n      snap: horizontalSnapInfo\n    },\n    vertical: {\n      isBound: verticalBoundInfos[0].isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      snapIndex: verticalSnapInfo.index,\n      offset: verticalOffset,\n      dist: verticalDist,\n      bounds: verticalBoundInfos,\n      snap: verticalSnapInfo\n    }\n  };\n}\n\nfunction checkSnapBounds(guideines, bounds, posesX, posesY, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = checkBoundPoses(bounds, posesX, posesY),\n      horizontalBoundInfos = _a.horizontal,\n      verticalBoundInfos = _a.vertical;\n\n  var _b = options.isRequest ? {\n    horizontal: {\n      isSnap: false,\n      index: -1\n    },\n    vertical: {\n      isSnap: false,\n      index: -1\n    }\n  } : checkSnapPoses(guideines, posesX, posesY, options),\n      horizontalSnapInfo = _b.horizontal,\n      verticalSnapInfo = _b.vertical;\n\n  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);\n  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfos[0].isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      snapIndex: horizontalSnapInfo.index,\n      offset: horizontalOffset,\n      dist: horizontalDist,\n      bounds: horizontalBoundInfos,\n      snap: horizontalSnapInfo\n    },\n    vertical: {\n      isBound: verticalBoundInfos[0].isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      snapIndex: verticalSnapInfo.index,\n      offset: verticalOffset,\n      dist: verticalDist,\n      bounds: verticalBoundInfos,\n      snap: verticalSnapInfo\n    }\n  };\n}\n\nfunction checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {\n  var fixedDirection = [-direction[0], -direction[1]];\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height;\n  var bounds = moveable.props.bounds;\n  var maxWidth = Infinity;\n  var maxHeight = Infinity;\n\n  if (bounds) {\n    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];\n    var _b = bounds.left,\n        left_1 = _b === void 0 ? -Infinity : _b,\n        _c = bounds.top,\n        top_1 = _c === void 0 ? -Infinity : _c,\n        _d = bounds.right,\n        right_1 = _d === void 0 ? Infinity : _d,\n        _e = bounds.bottom,\n        bottom_1 = _e === void 0 ? Infinity : _e;\n    directions.forEach(function (otherDirection) {\n      var isCheckVertical = otherDirection[0] !== fixedDirection[0];\n      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n      var otherPos = getPosByDirection(poses, otherDirection);\n      var deg = getRad(fixedPosition, otherPos) * 360 / Math.PI;\n\n      if (isCheckHorizontal) {\n        var nextOtherPos = otherPos.slice();\n\n        if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n          nextOtherPos[1] = fixedPosition[1];\n        }\n\n        var _a = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas),\n            _b = _a.offset,\n            heightOffset = _b[1],\n            isHeightOutside = _a.isOutside;\n\n        if (!isNaN(heightOffset)) {\n          maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);\n        }\n      }\n\n      if (isCheckVertical) {\n        var nextOtherPos = otherPos.slice();\n\n        if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n          nextOtherPos[0] = fixedPosition[0];\n        }\n\n        var _c = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas),\n            widthOffset = _c.offset[0],\n            isWidthOutside = _c.isOutside;\n\n        if (!isNaN(widthOffset)) {\n          maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);\n        }\n      }\n    });\n  }\n\n  return {\n    maxWidth: maxWidth,\n    maxHeight: maxHeight\n  };\n}\n\nfunction checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {\n  var rad = getRad(startPos, endPos) / Math.PI * 180;\n  var _a = snapBoundInfo.vertical,\n      isVerticalBound = _a.isBound,\n      isVerticalSnap = _a.isSnap,\n      verticalDist = _a.dist,\n      _b = snapBoundInfo.horizontal,\n      isHorizontalBound = _b.isBound,\n      isHorizontalSnap = _b.isSnap,\n      horizontalDist = _b.dist;\n  var rad180 = rad % 180;\n  var isHorizontalLine = rad180 < 3 || rad180 > 177;\n  var isVerticalLine = rad180 > 87 && rad180 < 93;\n\n  if (horizontalDist < verticalDist) {\n    if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {\n      return \"vertical\";\n    }\n  }\n\n  if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {\n    return \"horizontal\";\n  }\n\n  return \"\";\n}\n\nfunction getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {\n  return directions.map(function (_a) {\n    var startDirection = _a[0],\n        endDirection = _a[1];\n    var otherStartPos = getPosByDirection(poses, startDirection);\n    var otherEndPos = getPosByDirection(poses, endDirection);\n    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, [otherEndPos]);\n    var _b = snapBoundInfo.horizontal,\n        // dist: otherHorizontalDist,\n    otherHorizontalOffset = _b.offset,\n        isOtherHorizontalBound = _b.isBound,\n        isOtherHorizontalSnap = _b.isSnap,\n        _c = snapBoundInfo.vertical,\n        // dist: otherVerticalDist,\n    otherVerticalOffset = _c.offset,\n        isOtherVerticalBound = _c.isBound,\n        isOtherVerticalSnap = _c.isSnap;\n    var multiple = minus(endDirection, startDirection);\n\n    if (!otherVerticalOffset && !otherHorizontalOffset) {\n      return {\n        isBound: isOtherVerticalBound || isOtherHorizontalBound,\n        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n        sign: multiple,\n        offset: [0, 0]\n      };\n    }\n\n    var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);\n\n    if (!snapLine) {\n      return {\n        sign: multiple,\n        isBound: false,\n        isSnap: false,\n        offset: [0, 0]\n      };\n    }\n\n    var isVertical = snapLine === \"vertical\";\n    var sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset.map(function (size, i) {\n      return size * (multiple[i] ? 2 / multiple[i] : 0);\n    });\n    return {\n      sign: multiple,\n      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n      offset: sizeOffset\n    };\n  });\n}\n\nfunction getCheckSnapDirections(direction, keepRatio) {\n  var directions = [];\n  var fixedDirection = [-direction[0], -direction[1]];\n\n  if (direction[0] && direction[1]) {\n    directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);\n\n    if (keepRatio) {\n      // pass two direction condition\n      directions.push([fixedDirection, direction]);\n    }\n  } else if (direction[0]) {\n    // vertcal\n    if (keepRatio) {\n      directions.push([fixedDirection, [fixedDirection[0], -1]], [fixedDirection, [fixedDirection[0], 1]], [fixedDirection, [direction[0], -1]], [fixedDirection, direction], [fixedDirection, [direction[0], 1]]);\n    } else {\n      directions.push([[fixedDirection[0], -1], [direction[0], -1]], [[fixedDirection[0], 0], [direction[0], 0]], [[fixedDirection[0], 1], [direction[0], 1]]);\n    }\n  } else if (direction[1]) {\n    // horizontal\n    if (keepRatio) {\n      directions.push([fixedDirection, [-1, fixedDirection[1]]], [fixedDirection, [1, fixedDirection[1]]], [fixedDirection, [-1, direction[1]]], [fixedDirection, [1, direction[1]]], [fixedDirection, direction]);\n    } else {\n      directions.push([[-1, fixedDirection[1]], [-1, direction[1]]], [[0, fixedDirection[1]], [0, direction[1]]], [[1, fixedDirection[1]], [1, direction[1]]]);\n    }\n  } else {\n    // [0, 0] to all direction\n    directions.push([fixedDirection, [1, 0]], [fixedDirection, [-1, 0]], [fixedDirection, [0, -1]], [fixedDirection, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]);\n  }\n\n  return directions;\n}\n\nfunction getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {\n  var directions = getCheckSnapDirections(direction, keepRatio);\n  var lines = getCheckInnerBoundLines(poses, direction, keepRatio);\n\n  var offsets = __spreadArrays(getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas), getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas));\n\n  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n  return {\n    width: {\n      isBound: widthOffsetInfo.isBound,\n      offset: widthOffsetInfo.offset[0]\n    },\n    height: {\n      isBound: heightOffsetInfo.isBound,\n      offset: heightOffsetInfo.offset[1]\n    }\n  };\n}\n\nfunction recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {\n  var snapPos = getPosByDirection(poses, direction);\n\n  var _a = checkMoveableSnapBounds(moveable, isRequest, [snapPos]),\n      horizontalOffset = _a.horizontal.offset,\n      verticalOffset = _a.vertical.offset;\n\n  if (verticalOffset || horizontalOffset) {\n    var _b = getDragDist({\n      datas: datas,\n      distX: -verticalOffset,\n      distY: -horizontalOffset\n    }),\n        nextWidthOffset = _b[0],\n        nextHeightOffset = _b[1];\n\n    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n    return [nextWidth - width, nextHeight - height];\n  }\n\n  return [0, 0];\n}\n\nfunction checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {\n  var poses = getAbsolutePosesByState(moveable.state);\n  var keepRatio = moveable.props.keepRatio;\n  var widthOffset = 0;\n  var heightOffset = 0;\n\n  for (var i = 0; i < 2; ++i) {\n    var nextPoses = getNextPoses(widthOffset, heightOffset);\n\n    var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas),\n        widthOffsetInfo = _a.width,\n        heightOffsetInfo = _a.height;\n\n    var isWidthBound = widthOffsetInfo.isBound;\n    var isHeightBound = heightOffsetInfo.isBound;\n    var nextWidthOffset = widthOffsetInfo.offset;\n    var nextHeightOffset = heightOffsetInfo.offset;\n\n    if (i === 1) {\n      if (!isWidthBound) {\n        nextWidthOffset = 0;\n      }\n\n      if (!isHeightBound) {\n        nextHeightOffset = 0;\n      }\n    }\n\n    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n      return [0, 0];\n    }\n\n    if (keepRatio) {\n      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;\n\n      if (isGetWidthOffset) {\n        // width : height = ? : heightOffset\n        nextWidthOffset = width * nextHeightOffset / height;\n      } else {\n        // width : height = widthOffset : ?\n        nextHeightOffset = height * nextWidthOffset / width;\n      }\n    }\n\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n\n  if (direction[0] && direction[1]) {\n    var _b = checkMaxBounds(moveable, poses, direction, fixedPosition, datas),\n        maxWidth = _b.maxWidth,\n        maxHeight = _b.maxHeight;\n\n    var _c = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function (pos) {\n      return pos.map(function (p) {\n        return throttle(p, FLOAT_POINT_NUM);\n      });\n    }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas),\n        nextWidthOffset = _c[0],\n        nextHeightOffset = _c[1];\n\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n\n  return [widthOffset, heightOffset];\n}\n\nfunction checkSnapRotate(moveable, rect, origin, rotation) {\n  if (!hasGuidelines(moveable, \"rotatable\")) {\n    return rotation;\n  }\n\n  var pos1 = rect.pos1,\n      pos2 = rect.pos2,\n      pos3 = rect.pos3,\n      pos4 = rect.pos4;\n  var rad = rotation * Math.PI / 180;\n  var prevPoses = [pos1, pos2, pos3, pos4].map(function (pos) {\n    return minus(pos, origin);\n  });\n  var nextPoses = prevPoses.map(function (pos) {\n    return rotate(pos, rad);\n  });\n\n  var result = __spreadArrays(checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation), checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation));\n\n  result.sort(function (a, b) {\n    return Math.abs(a - rotation) - Math.abs(b - rotation);\n  });\n\n  if (result.length) {\n    return result[0];\n  } else {\n    return rotation;\n  }\n}\n\nfunction checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {\n  if (!hasGuidelines(moveable, \"resizable\")) {\n    return [0, 0];\n  }\n\n  var _a = moveable.state,\n      allMatrix = _a.allMatrix,\n      is3d = _a.is3d;\n  return checkSizeDist(moveable, function (widthOffset, heightOffset) {\n    return getNextFixedPoses(allMatrix, width + widthOffset, height + heightOffset, fixedPosition, direction, is3d);\n  }, width, height, direction, fixedPosition, isRequest, datas);\n}\n\nfunction checkSnapScale(moveable, scale, direction, isRequest, datas) {\n  var width = datas.width,\n      height = datas.height,\n      fixedPosition = datas.fixedPosition;\n\n  if (!hasGuidelines(moveable, \"scalable\")) {\n    return [0, 0];\n  }\n\n  var is3d = datas.is3d;\n  var sizeDist = checkSizeDist(moveable, function (widthOffset, heightOffset) {\n    return getNextFixedPoses(scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])), width, height, fixedPosition, direction, is3d);\n  }, width, height, direction, fixedPosition, isRequest, datas);\n  return [sizeDist[0] / width, sizeDist[1] / height];\n}\n\nfunction solveEquation(pos1, pos2, snapOffset, isVertical) {\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  if (!dx) {\n    // y = 0 * x + b\n    // only horizontal\n    if (!isVertical) {\n      return [0, snapOffset];\n    }\n\n    return [0, 0];\n  }\n\n  if (!dy) {\n    // only vertical\n    if (isVertical) {\n      return [snapOffset, 0];\n    }\n\n    return [0, 0];\n  } // y = ax + b\n\n\n  var a = dy / dx;\n  var b = pos1[1] - a * pos1[0];\n\n  if (isVertical) {\n    // y = a * x + b\n    var y = a * (pos2[0] + snapOffset) + b;\n    return [snapOffset, y - pos2[1]];\n  } else {\n    // x = (y - b) / a\n    var x = (pos2[1] + snapOffset - b) / a;\n    return [x - pos2[0], snapOffset];\n  }\n}\n\nfunction startCheckSnapDrag(moveable, datas) {\n  datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nfunction checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {\n  var distX = _a[0],\n      distY = _a[1];\n  var isVerticalBound = _b[0],\n      isHorizontalBound = _b[1];\n  var isVerticalSnap = _c[0],\n      isHorizontalSnap = _c[1];\n  var verticalOffset = _d[0],\n      horizontalOffset = _d[1];\n  var offsetX = -verticalOffset;\n  var offsetY = -horizontalOffset;\n\n  if (throttleDragRotate && distX && distY) {\n    offsetX = 0;\n    offsetY = 0;\n    var adjustPoses = [];\n\n    if (isVerticalBound && isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalBound) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset]);\n    } else if (isVerticalSnap && isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalSnap) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset]);\n    }\n\n    if (adjustPoses.length) {\n      adjustPoses.sort(function (a, b) {\n        return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));\n      });\n      var adjustPos = adjustPoses[0];\n\n      if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n        offsetX = -adjustPos[0];\n        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;\n      } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n        var prevDistY = distY;\n        offsetY = -adjustPos[1];\n        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;\n      }\n\n      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n        if (Math.abs(offsetX) > TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {\n          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n          offsetX *= scale;\n          offsetY *= scale;\n        } else if (Math.abs(offsetY) > TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {\n          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);\n          offsetX *= scale;\n          offsetY *= scale;\n        } else {\n          offsetX = maxOffset(-verticalOffset, offsetX);\n          offsetY = maxOffset(-horizontalOffset, offsetY);\n        }\n      }\n    }\n  } else {\n    offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n  }\n\n  return [offsetX, offsetY];\n}\n\nfunction checkSnapDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {\n  if (!hasGuidelines(moveable, \"draggable\")) {\n    return [{\n      isSnap: false,\n      isBound: false,\n      offset: 0\n    }, {\n      isSnap: false,\n      isBound: false,\n      offset: 0\n    }];\n  }\n\n  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n\n  var _a = getRect(poses),\n      left = _a.left,\n      right = _a.right,\n      top = _a.top,\n      bottom = _a.bottom;\n\n  var snapCenter = moveable.props.snapCenter;\n  var snapPoses = [[left, top], [right, top], [left, bottom], [right, bottom]];\n\n  if (snapCenter) {\n    snapPoses.push([(left + right) / 2, (top + bottom) / 2]);\n  }\n\n  var _b = checkMoveableSnapBounds(moveable, isRequest, snapPoses, poses),\n      verticalSnapBoundInfo = _b.vertical,\n      horizontalSnapBoundInfo = _b.horizontal;\n\n  var _c = getInnerBoundDragInfo(moveable, poses, datas),\n      verticalInnerBoundInfo = _c.vertical,\n      horizontalInnerBoundInfo = _c.horizontal;\n\n  var isVerticalSnap = verticalSnapBoundInfo.isSnap;\n  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n\n  var _d = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]),\n      offsetX = _d[0],\n      offsetY = _d[1];\n\n  return [{\n    isBound: isVerticalBound,\n    isSnap: isVerticalSnap,\n    offset: offsetX\n  }, {\n    isBound: isHorizontalBound,\n    isSnap: isHorizontalSnap,\n    offset: offsetY\n  }];\n}\n\nfunction getSnapGuidelines(posInfos) {\n  var guidelines = [];\n  posInfos.forEach(function (posInfo) {\n    posInfo.guidelineInfos.forEach(function (_a) {\n      var guideline = _a.guideline;\n\n      if (guidelines.indexOf(guideline) > -1) {\n        return;\n      }\n\n      guidelines.push(guideline);\n    });\n  });\n  return guidelines;\n}\n\nfunction getGapGuidelinesToStart(guidelines, index, targetPos, targetSizes, guidelinePos, gap, otherPos) {\n  var absGap = Math.abs(gap);\n  var start = guidelinePos[index] + (gap > 0 ? targetSizes[0] : 0);\n  return guidelines.filter(function (_a) {\n    var gapPos = _a.pos;\n    return gapPos[index] <= targetPos[index];\n  }).sort(function (_a, _b) {\n    var aPos = _a.pos;\n    var bPos = _b.pos;\n    return bPos[index] - aPos[index];\n  }).filter(function (_a) {\n    var gapPos = _a.pos,\n        gapSizes = _a.sizes;\n    var nextPos = gapPos[index];\n\n    if (throttle(nextPos + gapSizes[index], FLOAT_POINT_NUM) === throttle(start - absGap, FLOAT_POINT_NUM)) {\n      start = nextPos;\n      return true;\n    }\n\n    return false;\n  }).map(function (gapGuideline) {\n    var renderPos = -targetPos[index] + gapGuideline.pos[index] + gapGuideline.sizes[index];\n    return _assign(_assign({}, gapGuideline), {\n      gap: gap,\n      renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos]\n    });\n  });\n}\n\nfunction getGapGuidelinesToEnd(guidelines, index, targetPos, targetSizes, guidelinePos, gap, otherPos) {\n  var absGap = Math.abs(gap);\n  var start = guidelinePos[index] + (gap < 0 ? targetSizes[index] : 0);\n  return guidelines.filter(function (_a) {\n    var gapPos = _a.pos;\n    return gapPos[index] > targetPos[index];\n  }).sort(function (_a, _b) {\n    var aPos = _a.pos;\n    var bPos = _b.pos;\n    return aPos[index] - bPos[index];\n  }).filter(function (_a) {\n    var gapPos = _a.pos,\n        gapSizes = _a.sizes;\n    var nextPos = gapPos[index];\n\n    if (throttle(nextPos, FLOAT_POINT_NUM) === throttle(start + absGap, FLOAT_POINT_NUM)) {\n      start = nextPos + gapSizes[index];\n      return true;\n    }\n\n    return false;\n  }).map(function (gapGuideline) {\n    var renderPos = -targetPos[index] + gapGuideline.pos[index] - absGap;\n    return _assign(_assign({}, gapGuideline), {\n      gap: gap,\n      renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos]\n    });\n  });\n}\n\nfunction getGapGuidelines$1(guidelines, type, targetPos, targetSizes) {\n  var elementGuidelines = guidelines.filter(function (_a) {\n    var element = _a.element,\n        gap = _a.gap,\n        guidelineType = _a.type;\n    return element && gap && guidelineType === type;\n  });\n\n  var _a = type === \"vertical\" ? [0, 1] : [1, 0],\n      index = _a[0],\n      otherIndex = _a[1];\n\n  return flat(elementGuidelines.map(function (guideline) {\n    var pos = guideline.pos;\n    var gap = guideline.gap;\n    var gapGuidelines = guideline.gapGuidelines;\n    var sizes = guideline.sizes;\n    var offset = minOffset(pos[otherIndex] + sizes[otherIndex] - targetPos[otherIndex], pos[otherIndex] - targetPos[otherIndex] - targetSizes[otherIndex]);\n    var minSize = Math.min(sizes[otherIndex], targetSizes[otherIndex]);\n\n    if (offset > 0 && offset > minSize) {\n      offset = (offset - minSize / 2) * 2;\n    } else if (offset < 0 && offset < -minSize) {\n      offset = (offset + minSize / 2) * 2;\n    }\n\n    if (offset === 0) {\n      return [];\n    }\n\n    var otherPos = (offset > 0 ? 0 : targetSizes[otherIndex]) + offset / 2;\n    return __spreadArrays(getGapGuidelinesToStart(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos), getGapGuidelinesToEnd(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos));\n  }));\n}\n\nfunction addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {\n  var _a = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses),\n      verticalBoundInfos = _a.vertical,\n      horizontalBoundInfos = _a.horizontal;\n\n  verticalBoundInfos.forEach(function (info) {\n    if (info.isBound) {\n      verticalSnapPoses.push({\n        type: \"bounds\",\n        pos: info.pos\n      });\n    }\n  });\n  horizontalBoundInfos.forEach(function (info) {\n    if (info.isBound) {\n      horizontalSnapPoses.push({\n        type: \"bounds\",\n        pos: info.pos\n      });\n    }\n  });\n\n  var _b = checkInnerBoundPoses(moveable),\n      verticalInnerBoundPoses = _b.vertical,\n      horizontalInnerBoundPoses = _b.horizontal;\n\n  verticalInnerBoundPoses.forEach(function (innerPos) {\n    if (findIndex(verticalSnapPoses, function (_a) {\n      var type = _a.type,\n          pos = _a.pos;\n      return type === \"bounds\" && pos === innerPos;\n    }) >= 0) {\n      return;\n    }\n\n    verticalSnapPoses.push({\n      type: \"bounds\",\n      pos: innerPos\n    });\n  });\n  horizontalInnerBoundPoses.forEach(function (innerPos) {\n    if (findIndex(horizontalSnapPoses, function (_a) {\n      var type = _a.type,\n          pos = _a.pos;\n      return type === \"bounds\" && pos === innerPos;\n    }) >= 0) {\n      return;\n    }\n\n    horizontalSnapPoses.push({\n      type: \"bounds\",\n      pos: innerPos\n    });\n  });\n}\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\n\n\nvar Snappable = {\n  name: \"snappable\",\n  props: {\n    snappable: [Boolean, Array],\n    snapContainer: Object,\n    snapCenter: Boolean,\n    snapHorizontal: Boolean,\n    snapVertical: Boolean,\n    snapElement: Boolean,\n    snapGap: Boolean,\n    snapGridWidth: Number,\n    snapGridHeight: Number,\n    isDisplaySnapDigit: Boolean,\n    isDisplayInnerSnapDigit: Boolean,\n    snapDigit: Number,\n    snapThreshold: Number,\n    horizontalGuidelines: Array,\n    verticalGuidelines: Array,\n    elementGuidelines: Array,\n    bounds: Object,\n    innerBounds: Object,\n    snapDistFormat: Function\n  },\n  events: {\n    onSnap: \"snap\"\n  },\n  css: [\":host {\\n    --bounds-color: #d66;\\n}\\n.guideline {\\n    pointer-events: none;\\n    z-index: 2;\\n}\\n.guideline.bounds {\\n    background: #d66;\\n    background: var(--bounds-color);\\n}\\n.guideline-group {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n}\\n.guideline-group .size-value {\\n    position: absolute;\\n    color: #f55;\\n    font-size: 12px;\\n    font-weight: bold;\\n}\\n.guideline-group.horizontal .size-value {\\n    transform-origin: 50% 100%;\\n    transform: translateX(-50%);\\n    left: 50%;\\n    bottom: 5px;\\n}\\n.guideline-group.vertical .size-value {\\n    transform-origin: 0% 50%;\\n    top: 50%;\\n    transform: translateY(-50%);\\n    left: 5px;\\n}\\n.guideline.gap {\\n    background: #f55;\\n}\\n.size-value.gap {\\n    color: #f55;\\n}\\n\"],\n  render: function render(moveable, React) {\n    var state = moveable.state;\n    var targetTop = state.top,\n        targetLeft = state.left,\n        pos1 = state.pos1,\n        pos2 = state.pos2,\n        pos3 = state.pos3,\n        pos4 = state.pos4,\n        snapRenderInfo = state.snapRenderInfo,\n        targetClientRect = state.targetClientRect,\n        containerClientRect = state.containerClientRect,\n        is3d = state.is3d,\n        rootMatrix = state.rootMatrix;\n\n    if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n      return [];\n    }\n\n    state.staticGuidelines = getElementGuidelines(moveable, false, state.staticGuidelines);\n    state.guidelines = getTotalGuidelines(moveable);\n    var n = is3d ? 4 : 3;\n    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n    var containerPos = calculateContainerPos(rootMatrix, containerClientRect, n);\n\n    var _a = calculateInversePosition(rootMatrix, [targetClientRect.left - containerPos[0], targetClientRect.top - containerPos[1]], n),\n        clientLeft = _a[0],\n        clientTop = _a[1];\n\n    var _b = moveable.props,\n        _c = _b.snapThreshold,\n        snapThreshold = _c === void 0 ? 5 : _c,\n        _d = _b.snapDigit,\n        snapDigit = _d === void 0 ? 0 : _d,\n        _e = _b.snapDistFormat,\n        snapDistFormat = _e === void 0 ? function (v) {\n      return v;\n    } : _e;\n    var externalPoses = snapRenderInfo.externalPoses || [];\n    var poses = getAbsolutePosesByState(moveable.state);\n    var verticalSnapPoses = [];\n    var horizontalSnapPoses = [];\n    var verticalGuidelines = [];\n    var horizontalGuidelines = [];\n    var snapInfos = [];\n\n    var _f = getRect(poses),\n        width = _f.width,\n        height = _f.height,\n        top = _f.top,\n        left = _f.left,\n        bottom = _f.bottom,\n        right = _f.right;\n\n    var hasExternalPoses = externalPoses.length > 0;\n    var externalRect = hasExternalPoses ? getRect(externalPoses) : {};\n\n    if (!snapRenderInfo.request) {\n      if (snapRenderInfo.direction) {\n        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n      }\n\n      if (snapRenderInfo.snap) {\n        var rect = getRect(poses);\n\n        if (snapRenderInfo.center) {\n          rect.middle = (rect.top + rect.bottom) / 2;\n          rect.center = (rect.left + rect.right) / 2;\n        }\n\n        snapInfos.push(checkSnaps(moveable, rect, true, 1));\n      }\n\n      if (hasExternalPoses) {\n        if (snapRenderInfo.center) {\n          externalRect.middle = (externalRect.top + externalRect.bottom) / 2;\n          externalRect.center = (externalRect.left + externalRect.right) / 2;\n        }\n\n        snapInfos.push(checkSnaps(moveable, externalRect, true, 1));\n      }\n\n      snapInfos.forEach(function (snapInfo) {\n        var verticalPosInfos = snapInfo.vertical.posInfos,\n            horizontalPosInfos = snapInfo.horizontal.posInfos;\n        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.filter(function (_a) {\n          var guidelineInfos = _a.guidelineInfos;\n          return guidelineInfos.some(function (_a) {\n            var guideline = _a.guideline;\n            return !guideline.hide;\n          });\n        }).map(function (posInfo) {\n          return {\n            type: \"snap\",\n            pos: posInfo.pos\n          };\n        }));\n        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.filter(function (_a) {\n          var guidelineInfos = _a.guidelineInfos;\n          return guidelineInfos.some(function (_a) {\n            var guideline = _a.guideline;\n            return !guideline.hide;\n          });\n        }).map(function (posInfo) {\n          return {\n            type: \"snap\",\n            pos: posInfo.pos\n          };\n        }));\n        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));\n        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));\n      });\n    }\n\n    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);\n\n    if (hasExternalPoses) {\n      addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);\n    }\n\n    var gapHorizontalGuidelines = getGapGuidelines$1(verticalGuidelines, \"vertical\", [targetLeft, targetTop], [width, height]);\n    var gapVerticalGuidelines = getGapGuidelines$1(horizontalGuidelines, \"horizontal\", [targetLeft, targetTop], [width, height]);\n\n    var allGuidelines = __spreadArrays(verticalGuidelines, horizontalGuidelines);\n\n    triggerEvent(moveable, \"onSnap\", {\n      guidelines: allGuidelines.filter(function (_a) {\n        var element = _a.element;\n        return !element;\n      }),\n      elements: groupBy(allGuidelines.filter(function (_a) {\n        var element = _a.element;\n        return element;\n      }), function (_a) {\n        var element = _a.element;\n        return element;\n      }),\n      gaps: __spreadArrays(gapVerticalGuidelines, gapHorizontalGuidelines)\n    }, true);\n\n    var _g = filterElementInnerGuidelines(moveable, horizontalGuidelines, 0, [targetLeft, targetTop], [clientLeft, clientTop], [width, height]),\n        nextHorizontalGuidelines = _g.guidelines,\n        elementHorizontalGroups = _g.groups,\n        innerGapHorizontalGuidelines = _g.gapGuidelines;\n\n    var _h = filterElementInnerGuidelines(moveable, verticalGuidelines, 1, [targetLeft, targetTop], [clientLeft, clientTop], [width, height]),\n        nextVerticalGuidelines = _h.guidelines,\n        elementVerticalGroups = _h.groups,\n        innerGapVerticalGuidelines = _h.gapGuidelines;\n\n    return __spreadArrays(renderGapGuidelines(moveable, \"vertical\", __spreadArrays(gapVerticalGuidelines, innerGapVerticalGuidelines), snapDistFormat, React), renderGapGuidelines(moveable, \"horizontal\", __spreadArrays(gapHorizontalGuidelines, innerGapHorizontalGuidelines), snapDistFormat, React), renderElementGroups(moveable, \"horizontal\", elementHorizontalGroups, minLeft, clientLeft, width, targetTop, snapThreshold, snapDigit, 0, snapDistFormat, React), renderElementGroups(moveable, \"vertical\", elementVerticalGroups, minTop, clientTop, height, targetLeft, snapThreshold, snapDigit, 1, snapDistFormat, React), renderGuidelines(moveable, \"horizontal\", nextHorizontalGuidelines, [targetLeft, targetTop], React), renderGuidelines(moveable, \"vertical\", nextVerticalGuidelines, [targetLeft, targetTop], React), renderSnapPoses(moveable, \"horizontal\", horizontalSnapPoses, minLeft, targetTop, width, 0, React), renderSnapPoses(moveable, \"vertical\", verticalSnapPoses, minTop, targetLeft, height, 1, React));\n  },\n  dragStart: function dragStart(moveable, e) {\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest,\n      snap: true,\n      center: true\n    };\n    snapStart(moveable);\n  },\n  drag: function drag(moveable) {\n    var state = moveable.state;\n    state.staticGuidelines = getElementGuidelines(moveable, false, state.staticGuidelines);\n    state.guidelines = getTotalGuidelines(moveable);\n  },\n  pinchStart: function pinchStart(moveable) {\n    this.unset(moveable);\n  },\n  dragEnd: function dragEnd(moveable) {\n    this.unset(moveable);\n  },\n  dragControlCondition: function dragControlCondition(moveable, e) {\n    if (directionCondition(moveable, e) || _dragControlCondition(moveable, e)) {\n      return true;\n    }\n\n    if (!e.isRequest && e.inputEvent) {\n      return hasClass(e.inputEvent.target, prefix(\"snap-control\"));\n    }\n  },\n  dragControlStart: function dragControlStart(moveable) {\n    moveable.state.snapRenderInfo = null;\n    snapStart(moveable);\n  },\n  dragControl: function dragControl(moveable) {\n    this.drag(moveable);\n  },\n  dragControlEnd: function dragControlEnd(moveable) {\n    this.unset(moveable);\n  },\n  dragGroupStart: function dragGroupStart(moveable, e) {\n    this.dragStart(moveable, e);\n  },\n  dragGroup: function dragGroup(moveable) {\n    this.drag(moveable);\n  },\n  dragGroupEnd: function dragGroupEnd(moveable) {\n    this.unset(moveable);\n  },\n  dragGroupControlStart: function dragGroupControlStart(moveable) {\n    moveable.state.snapRenderInfo = null;\n    snapStart(moveable);\n  },\n  dragGroupControl: function dragGroupControl(moveable) {\n    this.drag(moveable);\n  },\n  dragGroupControlEnd: function dragGroupControlEnd(moveable) {\n    this.unset(moveable);\n  },\n  unset: function unset(moveable) {\n    var state = moveable.state;\n    state.enableSnap = false;\n    state.staticGuidelines = [];\n    state.guidelines = [];\n    state.snapRenderInfo = null;\n  }\n};\n/**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable.Snappable#snappable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n\n/**\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\n * @name Moveable.Snappable#snapContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.querySelector(\".container\"));\n *\n * moveable.snapContainer = document.body;\n */\n\n/**\n * When you drag, make the snap in the center of the target. (default: false)\n * @name Moveable.Snappable#snapCenter\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n * });\n *\n * moveable.snapCenter = true;\n */\n\n/**\n * When you drag, make the snap in the vertical guidelines. (default: true)\n * @name Moveable.Snappable#snapVertical\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapVertical = false;\n */\n\n/**\n * When you drag, make the snap in the horizontal guidelines. (default: true)\n * @name Moveable.Snappable#snapHorizontal\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapHorizontal = false;\n */\n\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n\n/**\n * When you drag, make the snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapElement\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapElement = false;\n */\n\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidelines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidelines = [100, 200, 500];\n */\n\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n\n/**\n * You can set up boundaries. (default: null)\n * @name Moveable.Snappable#bounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n\n/**\n * You can set up inner boundaries. (default: null)\n * @name Moveable.Snappable#innerBounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n\n/**\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridWidth\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridWidth = 5;\n */\n\n/**\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridHeight\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridHeight = 5;\n */\n\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * Whether to show element inner snap distance (default: false)\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplayInnerSnapDigit = true;\n */\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: v => v,\n * });\n * moveable.snapDistFormat = v => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\n\nvar Draggable = {\n  name: \"draggable\",\n  props: {\n    draggable: Boolean,\n    throttleDrag: Number,\n    throttleDragRotate: Number,\n    startDragRotate: Number,\n    edgeDraggable: Boolean\n  },\n  events: {\n    onDragStart: \"dragStart\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragEnd\",\n    onDragGroupStart: \"dragGroupStart\",\n    onDragGroup: \"dragGroup\",\n    onDragGroupEnd: \"dragGroupEnd\"\n  },\n  render: function render(moveable, React) {\n    var _a = moveable.props,\n        throttleDragRotate = _a.throttleDragRotate,\n        zoom = _a.zoom;\n    var _b = moveable.state,\n        dragInfo = _b.dragInfo,\n        beforeOrigin = _b.beforeOrigin;\n\n    if (!throttleDragRotate || !dragInfo) {\n      return [];\n    }\n\n    var dist = dragInfo.dist;\n\n    if (!dist[0] && !dist[1]) {\n      return [];\n    }\n\n    var width = getDistSize(dist);\n    var rad = getRad(dist, [0, 0]);\n    return [React.createElement(\"div\", {\n      className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: width + \"px\",\n        transform: \"translate(\" + beforeOrigin[0] + \"px, \" + beforeOrigin[1] + \"px) rotate(\" + rad + \"rad) scaleY(\" + zoom + \")\"\n      }\n    })];\n  },\n  dragStart: function dragStart(moveable, e) {\n    var datas = e.datas,\n        parentEvent = e.parentEvent,\n        parentGesto = e.parentGesto;\n    var state = moveable.state;\n    var target = state.target,\n        gesto = state.gesto;\n\n    if (gesto) {\n      return false;\n    }\n\n    state.gesto = parentGesto || moveable.targetGesto;\n    var style = getComputedStyle(target);\n    datas.datas = {};\n    datas.left = parseFloat(style.left || \"\") || 0;\n    datas.top = parseFloat(style.top || \"\") || 0;\n    datas.bottom = parseFloat(style.bottom || \"\") || 0;\n    datas.right = parseFloat(style.right || \"\") || 0;\n    datas.startValue = [0, 0];\n    setDragStart(moveable, e);\n    setDefaultTransformIndex(e, \"translate\");\n    startCheckSnapDrag(moveable, datas);\n    datas.prevDist = [0, 0];\n    datas.prevBeforeDist = [0, 0];\n    datas.isDrag = false;\n    var params = fillParams(moveable, e, _assign({\n      set: function set(translate) {\n        datas.startValue = translate;\n      }\n    }, fillTransformStartEvent(e)));\n    var result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n    if (result !== false) {\n      datas.isDrag = true;\n      moveable.state.dragInfo = {\n        startRect: moveable.getRect(),\n        dist: [0, 0]\n      };\n    } else {\n      state.gesto = null;\n      datas.isPinch = false;\n    }\n\n    return datas.isDrag ? params : false;\n  },\n  drag: function drag(moveable, e) {\n    resolveTransformEvent(e, \"translate\");\n    var datas = e.datas,\n        parentEvent = e.parentEvent,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        isRequest = e.isRequest;\n    var distX = e.distX,\n        distY = e.distY;\n    var isDrag = datas.isDrag,\n        prevDist = datas.prevDist,\n        prevBeforeDist = datas.prevBeforeDist,\n        startValue = datas.startValue;\n\n    if (!isDrag) {\n      return;\n    }\n\n    var props = moveable.props;\n    var parentMoveable = props.parentMoveable;\n    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;\n    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;\n    var isSnap = false;\n    var dragRotateRad = 0;\n\n    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n      var startDragRotate = props.startDragRotate || 0;\n      var deg = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;\n      var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n      var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n      var r = getDistSize([rx, ry]);\n      dragRotateRad = deg * Math.PI / 180;\n      distX = r * Math.cos(dragRotateRad);\n      distY = r * Math.sin(dragRotateRad);\n    }\n\n    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {\n      var _a = checkSnapDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas),\n          verticalInfo = _a[0],\n          horizontalInfo = _a[1];\n\n      var isVerticalSnap = verticalInfo.isSnap,\n          isVerticalBound = verticalInfo.isBound,\n          verticalOffset = verticalInfo.offset;\n      var isHorizontalSnap = horizontalInfo.isSnap,\n          isHorizontalBound = horizontalInfo.isBound,\n          horizontalOffset = horizontalInfo.offset;\n      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n      distX += verticalOffset;\n      distY += horizontalOffset;\n    }\n\n    datas.passDeltaX = distX - (datas.passDistX || 0);\n    datas.passDeltaY = distY - (datas.passDistY || 0);\n    datas.passDistX = distX;\n    datas.passDistY = distY;\n    var beforeTranslate = plus(getBeforeDragDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }), startValue);\n    var translate = plus(getTransformDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }), startValue);\n\n    if (!throttleDragRotate && !isSnap) {\n      throttleArray(translate, throttleDrag);\n      throttleArray(beforeTranslate, throttleDrag);\n    }\n\n    var beforeDist = minus(beforeTranslate, startValue);\n    var dist = minus(translate, startValue);\n    var delta = minus(dist, prevDist);\n    var beforeDelta = minus(beforeDist, prevBeforeDist);\n    datas.prevDist = dist;\n    datas.prevBeforeDist = beforeDist;\n    var left = datas.left + beforeDist[0];\n    var top = datas.top + beforeDist[1];\n    var right = datas.right - beforeDist[0];\n    var bottom = datas.bottom - beforeDist[1];\n    var nextTransform = convertTransformFormat(datas, \"translate(\" + translate[0] + \"px, \" + translate[1] + \"px)\", \"translate(\" + dist[0] + \"px, \" + dist[1] + \"px)\");\n    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n\n    if (!parentEvent && !parentMoveable && delta.every(function (num) {\n      return !num;\n    }) && beforeDelta.some(function (num) {\n      return !num;\n    })) {\n      return;\n    }\n\n    var _b = moveable.state,\n        width = _b.width,\n        height = _b.height;\n    var params = fillParams(moveable, e, {\n      transform: nextTransform,\n      dist: dist,\n      delta: delta,\n      translate: translate,\n      beforeDist: beforeDist,\n      beforeDelta: beforeDelta,\n      beforeTranslate: beforeTranslate,\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      width: width,\n      height: height,\n      isPinch: isPinch\n    });\n    !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n    return params;\n  },\n  dragEnd: function dragEnd(moveable, e) {\n    var parentEvent = e.parentEvent,\n        datas = e.datas,\n        isDrag = e.isDrag;\n    moveable.state.gesto = null;\n    moveable.state.dragInfo = null;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    datas.isDrag = false;\n    !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  },\n  dragGroupStart: function dragGroupStart(moveable, e) {\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY;\n    var params = this.dragStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var events = triggerChildGesto(moveable, this, \"dragStart\", [clientX || 0, clientY || 0], e, false);\n\n    var nextParams = _assign(_assign({}, params), {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n    datas.isDrag = result !== false;\n    return datas.isDrag ? params : false;\n  },\n  dragGroup: function dragGroup(moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    var params = this.drag(moveable, e);\n    var _a = e.datas,\n        passDeltaX = _a.passDeltaX,\n        passDeltaY = _a.passDeltaY;\n    var events = triggerChildGesto(moveable, this, \"drag\", [passDeltaX, passDeltaY], e, false);\n\n    if (!params) {\n      return;\n    }\n\n    var nextParams = _assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onDragGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupEnd: function dragGroupEnd(moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    this.dragEnd(moveable, e);\n    triggerChildGesto(moveable, this, \"dragEnd\", [0, 0], e, false);\n    triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams(moveable, e, {\n      targets: moveable.props.targets\n    }));\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Draggable#request\n   * @param {object} [e] - the draggable's request parameter\n   * @param {number} [e.x] - x position\n   * @param {number} [e.y] - y position\n   * @param {number} [e.deltaX] - X number to move\n   * @param {number} [e.deltaY] - Y number to move\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"draggable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100 });\n   * moveable.request(\"draggable\", { x: 220, y: 100 });\n   * moveable.request(\"draggable\", { x: 240, y: 100 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function request(moveable) {\n    var datas = {};\n    var rect = moveable.getRect();\n    var distX = 0;\n    var distY = 0;\n    return {\n      isControl: false,\n      requestStart: function requestStart() {\n        return {\n          datas: datas\n        };\n      },\n      request: function request(e) {\n        if (\"x\" in e) {\n          distX = e.x - rect.left;\n        } else if (\"deltaX\" in e) {\n          distX += e.deltaX;\n        }\n\n        if (\"y\" in e) {\n          distY = e.y - rect.top;\n        } else if (\"deltaY\" in e) {\n          distY += e.deltaY;\n        }\n\n        return {\n          datas: datas,\n          distX: distX,\n          distY: distY\n        };\n      },\n      requestEnd: function requestEnd() {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  },\n  unset: function unset(moveable) {\n    moveable.state.dragInfo = null;\n  }\n};\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group drag starts, the `dragGroupStart` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroupStart\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\n*     console.log(\"onDragGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group drag, the `dragGroup` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroup\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\n*     console.log(\"onDragGroup\", targets);\n*     events.forEach(ev => {\n*          // drag event\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\n*          // ev.target!.style.left = `${ev.left}px`;\n*          // ev.target!.style.top = `${ev.top}px`;\n*          console.log(\"onDrag translate\", ev.dist);\n*          ev.target!.style.transform = ev.transform;)\n*     });\n* });\n*/\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n\nfunction renderDirectionControls(moveable, defaultDirections, React, additionalClassName) {\n  if (additionalClassName === void 0) {\n    additionalClassName = \"\";\n  }\n\n  var _a = moveable.state,\n      renderPoses = _a.renderPoses,\n      radRotation = _a.rotation,\n      direction = _a.direction;\n  var _b = moveable.props,\n      _c = _b.renderDirections,\n      directions = _c === void 0 ? defaultDirections : _c,\n      zoom = _b.zoom;\n  var directionMap = {};\n\n  if (!directions) {\n    return [];\n  }\n\n  var sign = direction > 0 ? 1 : -1;\n  var renderDirections = directions === true ? DIRECTIONS : directions;\n  var degRotation = radRotation / Math.PI * 180;\n  renderDirections.forEach(function (dir) {\n    directionMap[dir] = true;\n  });\n  return renderDirections.map(function (dir) {\n    var indexes = DIRECTION_INDEXES[dir];\n\n    if (!indexes || !directionMap[dir]) {\n      return null;\n    }\n\n    var directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n    return React.createElement(\"div\", {\n      className: prefix(\"control\", \"direction\", dir, additionalClassName),\n      \"data-rotation\": directionRotation,\n      \"data-direction\": dir,\n      key: \"direction-\" + dir,\n      style: getControlTransform.apply(void 0, __spreadArrays([radRotation, zoom], indexes.map(function (index) {\n        return renderPoses[index];\n      })))\n    });\n  });\n}\n\nfunction renderLine(React, direction, pos1, pos2, zoom, key) {\n  var classNames = [];\n\n  for (var _i = 6; _i < arguments.length; _i++) {\n    classNames[_i - 6] = arguments[_i];\n  }\n\n  var rad = getRad(pos1, pos2);\n  var rotation = direction ? throttle(rad / Math.PI * 180, 15) % 180 : -1;\n  return React.createElement(\"div\", {\n    key: \"line\" + key,\n    className: prefix.apply(void 0, __spreadArrays([\"line\", \"direction\", direction], classNames)),\n    \"data-rotation\": rotation,\n    \"data-line-index\": key,\n    \"data-direction\": direction,\n    style: getLineStyle(pos1, pos2, zoom, rad)\n  });\n}\n\nfunction renderAllDirections(moveable, React) {\n  return renderDirectionControls(moveable, DIRECTIONS, React);\n}\n\nfunction renderDiagonalDirections(moveable, React) {\n  return renderDirectionControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\n\nfunction setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {\n  var n = moveable.state.is3d ? 4 : 3;\n  var nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);\n  var startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n  datas.startAbsoluteOrigin = startAbsoluteOrigin;\n  datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n  datas.prevSnapDeg = datas.prevDeg;\n  datas.startDeg = datas.prevDeg;\n  datas.loop = 0;\n}\n\nfunction getParentDeg(moveable, moveableRect, datas, parentDist, direction, startValue) {\n  var prevDeg = datas.prevDeg; // const absoluteDeg = startValue + parentDist;\n\n  var dist = checkSnapRotate(moveable, moveableRect, datas.origin, parentDist);\n  datas.prevDeg = dist;\n  var delta = dist - prevDeg;\n  return [delta, dist, startValue + dist];\n}\n\nfunction getDeg(moveable, moveableRect, datas, deg, direction, startValue, throttleRotate, isSnap) {\n  var prevDeg = datas.prevDeg,\n      prevSnapDeg = datas.prevSnapDeg,\n      startDeg = datas.startDeg,\n      prevLoop = datas.loop;\n\n  if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n    // 360 => 0\n    ++datas.loop;\n  } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n    // 0 => 360\n    --datas.loop;\n  }\n\n  var loop = datas.loop;\n  var absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startValue;\n  var absoluteDeg = loop * 360 + deg - startDeg + startValue;\n  datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startValue;\n  absoluteDeg = throttle(absoluteDeg, throttleRotate);\n  var dist = direction * (absoluteDeg - startValue);\n\n  if (isSnap) {\n    dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n    absoluteDeg = dist / direction + startValue;\n  }\n\n  datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startValue;\n  var delta = direction * (absoluteDeg - absolutePrevSnapDeg);\n  return [delta, dist, startValue + dist];\n}\n\nfunction getRotateInfo(moveable, moveableRect, datas, direction, clientX, clientY, startValue, throttleRotate) {\n  return getDeg(moveable, moveableRect, datas, getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, startValue, throttleRotate, true);\n}\n\nfunction getRotationPositions(rotationPosition, _a, direction) {\n  var pos1 = _a[0],\n      pos2 = _a[1],\n      pos3 = _a[2],\n      pos4 = _a[3];\n\n  if (rotationPosition === \"none\") {\n    return;\n  }\n\n  var _b = (rotationPosition || \"top\").split(\"-\"),\n      dir1 = _b[0],\n      dir2 = _b[1];\n\n  var radPoses = [pos1, pos2]; // if (scale[0] < 0) {\n  //     dir1 = getReversePositionX(dir1);\n  //     dir2 = getReversePositionX(dir2);\n  // }\n  // if (scale[1] < 0) {\n  //     dir1 = getReversePositionY(dir1);\n  //     dir2 = getReversePositionY(dir2);\n  // }\n\n  if (dir1 === \"left\") {\n    radPoses = [pos3, pos1];\n  } else if (dir1 === \"right\") {\n    radPoses = [pos2, pos4];\n  } else if (dir1 === \"bottom\") {\n    radPoses = [pos4, pos3];\n  }\n\n  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];\n  var rad = getRotationRad(radPoses, direction);\n\n  if (dir2) {\n    var isStart = dir2 === \"top\" || dir2 === \"left\";\n    var isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];\n  }\n\n  return [pos, rad];\n}\n\nfunction _dragControlCondition(moveable, e) {\n  if (e.isRequest) {\n    return e.requestAble === \"rotatable\";\n  }\n\n  var target = e.inputEvent.target;\n\n  if (hasClass(target, prefix(\"rotation-control\"))) {\n    return true;\n  }\n\n  var rotationTarget = moveable.props.rotationTarget;\n\n  if (rotationTarget) {\n    return getRefTargets(rotationTarget, true).some(function (element) {\n      if (!element) {\n        return false;\n      }\n\n      return target === element || target.contains(element);\n    });\n  }\n\n  return false;\n}\n\nvar Rotatable = {\n  name: \"rotatable\",\n  canPinch: true,\n  props: {\n    rotatable: Boolean,\n    rotationPosition: String,\n    throttleRotate: Number,\n    renderDirections: Object,\n    rotationTarget: Object\n  },\n  events: {\n    onRotateStart: \"rotateStart\",\n    onRotate: \"rotate\",\n    onRotateEnd: \"rotateEnd\",\n    onRotateGroupStart: \"rotateGroupStart\",\n    onRotateGroup: \"rotateGroup\",\n    onRotateGroupEnd: \"rotateGroupEnd\"\n  },\n  css: [\".rotation {\\n            position: absolute;\\n            height: 40px;\\n            width: 1px;\\n            transform-origin: 50% 100%;\\n            height: calc(40px * var(--zoom));\\n            top: auto;\\n            left: 0;\\n            bottom: 100%;\\n            will-change: transform;\\n        }\\n        .rotation .rotation-line {\\n            display: block;\\n            width: 100%;\\n            height: 100%;\\n            transform-origin: 50% 50%;\\n        }\\n        .rotation .rotation-control {\\n            border-color: #4af;\\n            border-color: var(--moveable-color);\\n            background:#fff;\\n            cursor: alias;\\n        }\"],\n  render: function render(moveable, React) {\n    var _a = moveable.props,\n        rotatable = _a.rotatable,\n        rotationPosition = _a.rotationPosition,\n        zoom = _a.zoom,\n        renderDirections = _a.renderDirections;\n    var _b = moveable.state,\n        renderPoses = _b.renderPoses,\n        direction = _b.direction;\n\n    if (!rotatable) {\n      return null;\n    }\n\n    var positions = getRotationPositions(rotationPosition, renderPoses, direction);\n    var jsxs = [];\n\n    if (positions) {\n      var pos = positions[0],\n          rad = positions[1];\n      jsxs.push(React.createElement(\"div\", {\n        key: \"rotation\",\n        className: prefix(\"rotation\"),\n        style: {\n          // tslint:disable-next-line: max-line-length\n          transform: \"translate(-50%) translate(\" + pos[0] + \"px, \" + pos[1] + \"px) rotate(\" + rad + \"rad)\"\n        }\n      }, React.createElement(\"div\", {\n        className: prefix(\"line rotation-line\"),\n        style: {\n          transform: \"scaleX(\" + zoom + \")\"\n        }\n      }), React.createElement(\"div\", {\n        className: prefix(\"control rotation-control\"),\n        style: {\n          transform: \"translate(0.5px) scale(\" + zoom + \")\"\n        }\n      })));\n    }\n\n    if (renderDirections) {\n      jsxs.push.apply(jsxs, renderDirectionControls(moveable, [], React));\n    }\n\n    return jsxs;\n  },\n  dragControlCondition: _dragControlCondition,\n  dragControlStart: function dragControlStart(moveable, e) {\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        parentRotate = e.parentRotate,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        isRequest = e.isRequest;\n    var _a = moveable.state,\n        target = _a.target,\n        left = _a.left,\n        top = _a.top,\n        origin = _a.origin,\n        beforeOrigin = _a.beforeOrigin,\n        direction = _a.direction,\n        beforeDirection = _a.beforeDirection,\n        targetTransform = _a.targetTransform,\n        moveableClientRect = _a.moveableClientRect;\n\n    if (!isRequest && !target) {\n      return false;\n    }\n\n    var rect = moveable.getRect();\n    datas.rect = rect;\n    datas.transform = targetTransform;\n    datas.left = left;\n    datas.top = top;\n    datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));\n    datas.absoluteInfo = {\n      origin: rect.origin,\n      startValue: rect.rotation\n    };\n    setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);\n\n    if (isRequest || isPinch || parentFlag) {\n      var externalRotate = parentRotate || 0;\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin,\n        prevDeg: externalRotate,\n        startDeg: externalRotate,\n        prevSnapDeg: externalRotate,\n        loop: 0\n      };\n      datas.afterInfo = {\n        origin: rect.origin,\n        prevDeg: externalRotate,\n        startDeg: externalRotate,\n        prevSnapDeg: externalRotate,\n        loop: 0\n      };\n    } else {\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin\n      };\n      datas.afterInfo = {\n        origin: rect.origin\n      };\n      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);\n      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);\n    }\n\n    datas.direction = direction;\n    datas.beforeDirection = beforeDirection;\n    datas.startValue = 0;\n    datas.datas = {};\n    setDefaultTransformIndex(e, \"rotate\");\n    var params = fillParams(moveable, e, _assign(_assign({\n      set: function set(rotatation) {\n        datas.startValue = rotatation * Math.PI / 180;\n      }\n    }, fillTransformStartEvent(e)), {\n      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))\n    }));\n    var result = triggerEvent(moveable, \"onRotateStart\", params);\n    datas.isRotate = result !== false;\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest\n    };\n    return datas.isRotate ? params : false;\n  },\n  dragControl: function dragControl(moveable, e) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        parentRotate = e.parentRotate,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        groupDelta = e.groupDelta;\n    var beforeDirection = datas.beforeDirection,\n        beforeInfo = datas.beforeInfo,\n        afterInfo = datas.afterInfo,\n        absoluteInfo = datas.absoluteInfo,\n        isRotate = datas.isRotate,\n        startValue = datas.startValue,\n        rect = datas.rect;\n\n    if (!isRotate) {\n      return;\n    }\n\n    resolveTransformEvent(e, \"rotate\");\n    var targetDirection = getTransformDirection(e);\n    var direction = beforeDirection * targetDirection;\n    var _k = moveable.props,\n        _l = _k.throttleRotate,\n        throttleRotate = _l === void 0 ? 0 : _l,\n        parentMoveable = _k.parentMoveable;\n    var delta;\n    var dist;\n    var rotate;\n    var beforeDelta;\n    var beforeDist;\n    var beforeRotate;\n    var absoluteDelta;\n    var absoluteDist;\n    var absoluteRotate;\n    var startDeg = 180 / Math.PI * startValue;\n    var absoluteStartDeg = absoluteInfo.startValue;\n\n    if (!parentFlag && \"parentDist\" in e) {\n      var parentDist = e.parentDist;\n      _a = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startDeg), delta = _a[0], dist = _a[1], rotate = _a[2];\n      _b = getParentDeg(moveable, rect, beforeInfo, parentDist, beforeDirection, startDeg), beforeDelta = _b[0], beforeDist = _b[1], beforeRotate = _b[2];\n      _c = getParentDeg(moveable, rect, absoluteInfo, parentDist, direction, absoluteStartDeg), absoluteDelta = _c[0], absoluteDist = _c[1], absoluteRotate = _c[2];\n    } else if (isPinch || parentFlag) {\n      _d = getDeg(moveable, rect, afterInfo, parentRotate, direction, startDeg, throttleRotate), delta = _d[0], dist = _d[1], rotate = _d[2];\n      _e = getDeg(moveable, rect, beforeInfo, parentRotate, beforeDirection, startDeg, throttleRotate), beforeDelta = _e[0], beforeDist = _e[1], beforeRotate = _e[2];\n      _f = getDeg(moveable, rect, absoluteInfo, parentRotate, direction, absoluteStartDeg, throttleRotate), absoluteDelta = _f[0], absoluteDist = _f[1], absoluteRotate = _f[2];\n    } else {\n      _g = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startDeg, throttleRotate), delta = _g[0], dist = _g[1], rotate = _g[2];\n      _h = getRotateInfo(moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startDeg, throttleRotate), beforeDelta = _h[0], beforeDist = _h[1], beforeRotate = _h[2];\n      _j = getRotateInfo(moveable, rect, absoluteInfo, direction, clientX, clientY, absoluteStartDeg, throttleRotate), absoluteDelta = _j[0], absoluteDist = _j[1], absoluteRotate = _j[2];\n    }\n\n    if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {\n      return;\n    }\n\n    var nextTransform = convertTransformFormat(datas, \"rotate(\" + rotate + \"deg)\", \"rotate(\" + dist + \"deg)\");\n    var inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);\n    var inverseDelta = minus(plus(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);\n    datas.prevInverseDist = inverseDist;\n    var params = fillParams(moveable, e, _assign({\n      delta: delta,\n      dist: dist,\n      rotate: rotate,\n      beforeDist: beforeDist,\n      beforeDelta: beforeDelta,\n      beforeRotate: beforeRotate,\n      absoluteDist: absoluteDist,\n      absoluteDelta: absoluteDelta,\n      absoluteRotate: absoluteRotate,\n      isPinch: !!isPinch\n    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));\n    triggerEvent(moveable, \"onRotate\", params);\n    return params;\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isRotate) {\n      return false;\n    }\n\n    datas.isRotate = false;\n    triggerEvent(moveable, \"onRotateEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  },\n  dragGroupControlCondition: _dragControlCondition,\n  dragGroupControlStart: function dragGroupControlStart(moveable, e) {\n    var datas = e.datas;\n    var _a = moveable.state,\n        parentLeft = _a.left,\n        parentTop = _a.top,\n        parentBeforeOrigin = _a.beforeOrigin;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    params.set(datas.beforeDirection * moveable.rotation);\n    var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function (child, ev) {\n      var _a = child.state,\n          left = _a.left,\n          top = _a.top,\n          beforeOrigin = _a.beforeOrigin;\n      var childClient = plus(minus([left, top], [parentLeft, parentTop]), minus(beforeOrigin, parentBeforeOrigin));\n      ev.datas.groupClient = childClient;\n      return _assign(_assign({}, ev), {\n        parentRotate: 0\n      });\n    });\n\n    var nextParams = _assign(_assign({}, params), {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n    datas.isRotate = result !== false;\n    return datas.isRotate ? params : false;\n  },\n  dragGroupControl: function dragGroupControl(moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var direction = datas.beforeDirection;\n    var parentRotate = params.beforeDist;\n    var deg = params.beforeDelta;\n    var rad = deg / 180 * Math.PI;\n    var events = triggerChildAbles(moveable, this, \"dragControl\", e, function (_, ev) {\n      var _a = ev.datas.groupClient,\n          prevX = _a[0],\n          prevY = _a[1];\n\n      var _b = rotate([prevX, prevY], rad * direction),\n          clientX = _b[0],\n          clientY = _b[1];\n\n      var delta = [clientX - prevX, clientY - prevY];\n      ev.datas.groupClient = [clientX, clientY];\n      return _assign(_assign({}, ev), {\n        parentRotate: parentRotate,\n        groupDelta: delta\n      });\n    });\n    moveable.rotation = direction * params.beforeRotate;\n\n    var nextParams = _assign({\n      targets: moveable.props.targets,\n      events: events,\n      set: function set(rotation) {\n        moveable.rotation = rotation;\n      }\n    }, params);\n\n    triggerEvent(moveable, \"onRotateGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function dragGroupControlEnd(moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets\n    });\n    triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Rotatable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.deltaRotate=0] -  delta number of rotation\n   * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n   *\n   * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"rotatable\");\n   *\n   * // request\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   *\n   * requester.request({ rotate: 10 });\n   * requester.request({ rotate: 20 });\n   * requester.request({ rotate: 30 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function request(moveable) {\n    var datas = {};\n    var distRotate = 0;\n    var startRotation = moveable.getRotation();\n    return {\n      isControl: true,\n      requestStart: function requestStart() {\n        return {\n          datas: datas\n        };\n      },\n      request: function request(e) {\n        if (\"deltaRotate\" in e) {\n          distRotate += e.deltaRotate;\n        } else if (\"rotate\" in e) {\n          distRotate = e.rotate - startRotation;\n        }\n\n        return {\n          datas: datas,\n          parentDist: distRotate\n        };\n      },\n      requestEnd: function requestEnd() {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n* When rotating, the rotate event is called.\n* @memberof Moveable.Rotatable\n* @event rotate\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { rotatable: true });\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\n*     target.style.transform = transform;\n* });\n*/\n\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n* When the group rotate, the `rotateGroup` event is called.\n* @memberof Moveable.Rotatable\n* @event rotateGroup\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     rotatable: true\n* });\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\n*     console.log(\"onRotateGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group rotate.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const deg = ev.beforeDist;\n*     });\n* });\n*/\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nvar Resizable = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: true,\n  props: {\n    resizable: Boolean,\n    throttleResize: Number,\n    renderDirections: Array,\n    keepRatio: Boolean\n  },\n  events: {\n    onResizeStart: \"resizeStart\",\n    onResize: \"resize\",\n    onResizeEnd: \"resizeEnd\",\n    onResizeGroupStart: \"resizeGroupStart\",\n    onResizeGroup: \"resizeGroup\",\n    onResizeGroupEnd: \"resizeGroupEnd\"\n  },\n  render: function render(moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        edge = _a.edge;\n\n    if (resizable) {\n      if (edge) {\n        return renderDiagonalDirections(moveable, React);\n      }\n\n      return renderAllDirections(moveable, React);\n    }\n  },\n  dragControlCondition: directionCondition,\n  dragControlStart: function dragControlStart(moveable, e) {\n    var _a;\n\n    var inputEvent = e.inputEvent,\n        isPinch = e.isPinch,\n        parentDirection = e.parentDirection,\n        datas = e.datas,\n        parentFlag = e.parentFlag;\n    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n    var _b = moveable.state,\n        target = _b.target,\n        width = _b.width,\n        height = _b.height;\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    !isPinch && setDragStart(moveable, e);\n    datas.datas = {};\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.prevWidth = 0;\n    datas.prevHeight = 0;\n    _a = getCSSSize(target), datas.startWidth = _a[0], datas.startHeight = _a[1];\n    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];\n    datas.minSize = padding;\n    datas.maxSize = [Infinity, Infinity];\n\n    if (!parentFlag) {\n      var style = getComputedStyle(target);\n      var position = style.position,\n          minWidth = style.minWidth,\n          minHeight = style.minHeight,\n          maxWidth = style.maxWidth,\n          maxHeight = style.maxHeight;\n      var isParentElement = position === \"static\" || position === \"relative\";\n      var container = isParentElement ? target.parentElement : target.offsetParent;\n      var containerWidth = width;\n      var containerHeight = height;\n\n      if (container) {\n        containerWidth = container.clientWidth;\n        containerHeight = container.clientHeight;\n\n        if (isParentElement) {\n          var containerStyle = getComputedStyle(container);\n          containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;\n          containerHeight -= parseFloat(containerStyle.paddingTop) || 0;\n        }\n      }\n\n      datas.minSize = plus([convertUnitSize(minWidth, containerWidth) || 0, convertUnitSize(minHeight, containerHeight) || 0], padding);\n      datas.maxSize = plus([convertUnitSize(maxWidth, containerWidth) || Infinity, convertUnitSize(maxHeight, containerHeight) || Infinity], padding);\n    }\n\n    var transformOrigin = moveable.props.transformOrigin || \"% %\";\n    datas.transformOrigin = transformOrigin && isString(transformOrigin) ? transformOrigin.split(\" \") : transformOrigin;\n    datas.isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];\n\n    function setRatio(ratio) {\n      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n    }\n\n    function setFixedDirection(fixedDirection) {\n      datas.fixedDirection = fixedDirection;\n      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);\n    }\n\n    setRatio(width / height);\n    setFixedDirection([-direction[0], -direction[1]]);\n    var params = fillParams(moveable, e, {\n      direction: direction,\n      set: function set(_a) {\n        var startWidth = _a[0],\n            startHeight = _a[1];\n        datas.startWidth = startWidth;\n        datas.startHeight = startHeight;\n      },\n      setMin: function setMin(minSize) {\n        datas.minSize = minSize;\n      },\n      setMax: function setMax(maxSize) {\n        datas.maxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];\n      },\n      setRatio: setRatio,\n      setFixedDirection: setFixedDirection,\n      setOrigin: function setOrigin(origin) {\n        datas.transformOrigin = origin;\n      },\n      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))\n    });\n    var result = triggerEvent(moveable, \"onResizeStart\", params);\n\n    if (result !== false) {\n      datas.isResize = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction: direction\n      };\n    }\n\n    return datas.isResize ? params : false;\n  },\n  dragControl: function dragControl(moveable, e) {\n    var _a;\n\n    var datas = e.datas,\n        distX = e.distX,\n        distY = e.distY,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        parentDistance = e.parentDistance,\n        parentScale = e.parentScale,\n        parentKeepRatio = e.parentKeepRatio,\n        dragClient = e.dragClient,\n        parentDist = e.parentDist,\n        isRequest = e.isRequest;\n    var isResize = datas.isResize,\n        transformOrigin = datas.transformOrigin,\n        fixedDirection = datas.fixedDirection,\n        startWidth = datas.startWidth,\n        startHeight = datas.startHeight,\n        prevWidth = datas.prevWidth,\n        prevHeight = datas.prevHeight,\n        minSize = datas.minSize,\n        maxSize = datas.maxSize,\n        ratio = datas.ratio,\n        isWidth = datas.isWidth,\n        startOffsetWidth = datas.startOffsetWidth,\n        startOffsetHeight = datas.startOffsetHeight;\n\n    if (!isResize) {\n      return;\n    }\n\n    var _b = moveable.props,\n        _c = _b.throttleResize,\n        throttleResize = _c === void 0 ? 0 : _c,\n        parentMoveable = _b.parentMoveable,\n        _d = _b.snapThreshold,\n        snapThreshold = _d === void 0 ? 5 : _d;\n    var direction = datas.direction;\n    var sizeDirection = direction;\n    var distWidth = 0;\n    var distHeight = 0;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n\n    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);\n    var fixedPosition = dragClient;\n\n    if (!dragClient) {\n      if (!parentFlag && isPinch) {\n        fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n      } else {\n        fixedPosition = datas.fixedPosition;\n      }\n    }\n\n    if (parentDist) {\n      distWidth = parentDist[0];\n      distHeight = parentDist[1];\n\n      if (keepRatio) {\n        if (!distWidth) {\n          distWidth = distHeight * ratio;\n        } else if (!distHeight) {\n          distHeight = distWidth / ratio;\n        }\n      }\n    } else if (parentScale) {\n      distWidth = (parentScale[0] - 1) * startOffsetWidth;\n      distHeight = (parentScale[1] - 1) * startOffsetHeight;\n    } else if (isPinch) {\n      if (parentDistance) {\n        distWidth = parentDistance;\n        distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n      }\n    } else {\n      var dist = getDragDist({\n        datas: datas,\n        distX: distX,\n        distY: distY\n      });\n      distWidth = sizeDirection[0] * dist[0];\n      distHeight = sizeDirection[1] * dist[1];\n\n      if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        var rad = getRad([0, 0], dist);\n        var standardRad = getRad([0, 0], sizeDirection);\n        var size = getDistSize([distWidth, distHeight]);\n        var signSize = Math.cos(rad - standardRad) * size;\n\n        if (!sizeDirection[0]) {\n          // top, bottom\n          distHeight = signSize;\n          distWidth = distHeight / ratio;\n        } else if (!sizeDirection[1]) {\n          // left, right\n          distWidth = signSize;\n          distHeight = distWidth * ratio;\n        } else {\n          // two-way\n          var startWidthSize = sizeDirection[0] * 2 * startOffsetWidth;\n          var startHeightSize = sizeDirection[1] * 2 * startOffsetHeight;\n          var distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) - getDistSize([startWidthSize, startHeightSize]);\n          var ratioRad = getRad([0, 0], [ratio, 1]);\n          distWidth = Math.cos(ratioRad) * distSize;\n          distHeight = Math.sin(ratioRad) * distSize;\n        }\n      } else if (!keepRatio) {\n        var nextDirection = __spreadArrays(direction);\n\n        if (!startOffsetWidth) {\n          if (dist[0] < 0) {\n            nextDirection[0] = -1;\n          } else if (dist[0] > 0) {\n            nextDirection[0] = 1;\n          }\n        }\n\n        if (!startOffsetHeight) {\n          if (dist[1] < 0) {\n            nextDirection[1] = -1;\n          } else if (dist[1] > 0) {\n            nextDirection[1] = 1;\n          }\n        }\n\n        direction = nextDirection;\n        sizeDirection = nextDirection;\n        distWidth = sizeDirection[0] * dist[0];\n        distHeight = sizeDirection[1] * dist[1];\n      }\n    }\n\n    var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n    var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\n      // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n      if (isWidth) {\n        nextHeight = nextWidth / ratio;\n      } else {\n        nextWidth = nextHeight * ratio;\n      }\n    }\n\n    var snapDist = [0, 0];\n\n    if (!isPinch) {\n      snapDist = checkSnapResize(moveable, nextWidth, nextHeight, direction, fixedPosition, isRequest, datas);\n    }\n\n    if (parentDist) {\n      !parentDist[0] && (snapDist[0] = 0);\n      !parentDist[1] && (snapDist[1] = 0);\n    }\n\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n\n      var isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        if (isWidth) {\n          nextWidth = throttle(nextWidth, throttleResize);\n        } else {\n          nextHeight = throttle(nextHeight, throttleResize);\n        }\n      }\n\n      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n        nextWidth += snapDist[0];\n        nextHeight = nextWidth / ratio;\n      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n        nextHeight += snapDist[1];\n        nextWidth = nextHeight * ratio;\n      }\n    } else {\n      if (startOffsetWidth + distWidth < -snapThreshold) {\n        snapDist[0] = 0;\n      }\n\n      if (startOffsetWidth + distHeight < -snapThreshold) {\n        snapDist[1] = 0;\n      }\n\n      nextWidth += snapDist[0];\n      nextHeight += snapDist[1];\n\n      if (!snapDist[0]) {\n        nextWidth = throttle(nextWidth, throttleResize);\n      }\n\n      if (!snapDist[1]) {\n        nextHeight = throttle(nextHeight, throttleResize);\n      }\n    }\n\n    _a = calculateBoundSize([nextWidth, nextHeight], minSize, maxSize, keepRatio), nextWidth = _a[0], nextHeight = _a[1];\n    nextWidth = Math.round(nextWidth);\n    nextHeight = Math.round(nextHeight);\n    distWidth = nextWidth - startOffsetWidth;\n    distHeight = nextHeight - startOffsetHeight;\n    var delta = [distWidth - prevWidth, distHeight - prevHeight];\n    datas.prevWidth = distWidth;\n    datas.prevHeight = distHeight;\n    var inverseDelta = getResizeDist(moveable, nextWidth, nextHeight, fixedDirection, fixedPosition, transformOrigin);\n\n    if (!parentMoveable && delta.every(function (num) {\n      return !num;\n    }) && inverseDelta.every(function (num) {\n      return !num;\n    })) {\n      return;\n    }\n\n    var params = fillParams(moveable, e, {\n      width: startWidth + distWidth,\n      height: startHeight + distHeight,\n      offsetWidth: nextWidth,\n      offsetHeight: nextHeight,\n      direction: direction,\n      dist: [distWidth, distHeight],\n      delta: delta,\n      isPinch: !!isPinch,\n      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false))\n    });\n    triggerEvent(moveable, \"onResize\", params);\n    return params;\n  },\n  dragControlAfter: function dragControlAfter(moveable, e) {\n    var datas = e.datas;\n    var isResize = datas.isResize,\n        startOffsetWidth = datas.startOffsetWidth,\n        startOffsetHeight = datas.startOffsetHeight,\n        prevWidth = datas.prevWidth,\n        prevHeight = datas.prevHeight;\n\n    if (!isResize) {\n      return;\n    }\n\n    var _a = moveable.state,\n        width = _a.width,\n        height = _a.height;\n    var errorWidth = width - (startOffsetWidth + prevWidth);\n    var errorHeight = height - (startOffsetHeight + prevHeight);\n    var isErrorWidth = Math.abs(errorWidth) > 3;\n    var isErrorHeight = Math.abs(errorHeight) > 3;\n\n    if (isErrorWidth) {\n      datas.startWidth += errorWidth;\n      datas.startOffsetWidth += errorWidth;\n      datas.prevWidth += errorWidth;\n    }\n\n    if (isErrorHeight) {\n      datas.startHeight += errorHeight;\n      datas.startOffsetHeight += errorHeight;\n      datas.prevHeight += errorHeight;\n    }\n\n    if (isErrorWidth || isErrorHeight) {\n      this.dragControl(moveable, e);\n      return true;\n    }\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isResize) {\n      return false;\n    }\n\n    datas.isResize = false;\n    var params = fillEndParams(moveable, e, {});\n    triggerEvent(moveable, \"onResizeEnd\", params);\n    return isDrag;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function dragGroupControlStart(moveable, e) {\n    var datas = e.datas;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var originalEvents = fillChildEvents(moveable, \"resizable\", e);\n\n    function setDist(child, ev) {\n      var fixedDirection = datas.fixedDirection;\n      var fixedPosition = datas.fixedPosition;\n      var pos = getAbsolutePosition(child, fixedDirection);\n\n      var _a = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),\n          originalX = _a[0],\n          originalY = _a[1];\n\n      ev.datas.originalX = originalX;\n      ev.datas.originalY = originalY;\n      return ev;\n    }\n\n    var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function (child, ev) {\n      return setDist(child, ev);\n    });\n\n    var nextParams = _assign(_assign({}, params), {\n      targets: moveable.props.targets,\n      events: events,\n      setFixedDirection: function setFixedDirection(fixedDirection) {\n        params.setFixedDirection(fixedDirection);\n        events.forEach(function (ev, i) {\n          ev.setFixedDirection(fixedDirection);\n          setDist(moveable.moveables[i], originalEvents[i]);\n        });\n      }\n    });\n\n    var result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n    datas.isResize = result !== false;\n    return datas.isResize ? params : false;\n  },\n  dragGroupControl: function dragGroupControl(moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isResize) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var offsetWidth = params.offsetWidth,\n        offsetHeight = params.offsetHeight,\n        dist = params.dist;\n    var keepRatio = moveable.props.keepRatio;\n    var parentScale = [offsetWidth / (offsetWidth - dist[0]), offsetHeight / (offsetHeight - dist[1])];\n    var fixedPosition = datas.fixedPosition;\n    var events = triggerChildAbles(moveable, this, \"dragControl\", e, function (_, ev) {\n      var _a = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * parentScale[0], ev.datas.originalY * parentScale[1], 1], 3),\n          clientX = _a[0],\n          clientY = _a[1];\n\n      return _assign(_assign({}, ev), {\n        parentDist: null,\n        parentScale: parentScale,\n        dragClient: plus(fixedPosition, [clientX, clientY]),\n        parentKeepRatio: keepRatio\n      });\n    });\n\n    var nextParams = _assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onResizeGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function dragGroupControlEnd(moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isResize) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets\n    });\n    triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Resizable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.direction=[1, 1]] - Direction to resize\n   * @param {number} [e.deltaWidth] - delta number of width\n   * @param {number} [e.deltaHeight] - delta number of height\n   * @param {number} [e.offsetWidth] - offset number of width\n   * @param {number} [e.offsetHeight] - offset number of height\n   * @param {number} [e.isInstant] - Whether to execute the request instantly\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"resizable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n   * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n   * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function request(moveable) {\n    var datas = {};\n    var distWidth = 0;\n    var distHeight = 0;\n    var rect = moveable.getRect();\n    return {\n      isControl: true,\n      requestStart: function requestStart(e) {\n        return {\n          datas: datas,\n          parentDirection: e.direction || [1, 1]\n        };\n      },\n      request: function request(e) {\n        if (\"offsetWidth\" in e) {\n          distWidth = e.offsetWidth - rect.offsetWidth;\n        } else if (\"deltaWidth\" in e) {\n          distWidth += e.deltaWidth;\n        }\n\n        if (\"offsetHeight\" in e) {\n          distHeight = e.offsetHeight - rect.offsetHeight;\n        } else if (\"deltaHeight\" in e) {\n          distHeight += e.deltaHeight;\n        }\n\n        return {\n          datas: datas,\n          parentDist: [distWidth, distHeight]\n        };\n      },\n      requestEnd: function requestEnd() {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * Whether or not target can be resized. (default: false)\n * @name Moveable.Resizable#resizable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize.\n * @name Moveable.Resizable#throttleResize\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 0,\n * });\n *\n * moveable.throttleResize = 1;\n */\n\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Resizable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Resizable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group resize starts, the `resizeGroupStart` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroupStart\n* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroupStart\", ({ targets }) => {\n*     console.log(\"onResizeGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group resize, the `resizeGroup` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroup\n* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroup\", ({ targets, events }) => {\n*     console.log(\"onResizeGroup\", targets);\n*     events.forEach(ev => {\n*         const offset = [\n*             direction[0] < 0 ? -ev.delta[0] : 0,\n*             direction[1] < 0 ? -ev.delta[1] : 0,\n*         ];\n*         // ev.drag is a drag event that occurs when the group resize.\n*         const left = offset[0] + ev.drag.beforeDist[0];\n*         const top = offset[1] + ev.drag.beforeDist[1];\n*         const width = ev.width;\n*         const top = ev.top;\n*     });\n* });\n*/\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\n\nvar Scalable = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: true,\n  props: {\n    scalable: Boolean,\n    throttleScale: Number,\n    renderDirections: String,\n    keepRatio: Boolean\n  },\n  events: {\n    onScaleStart: \"scaleStart\",\n    onScale: \"scale\",\n    onScaleEnd: \"scaleEnd\",\n    onScaleGroupStart: \"scaleGroupStart\",\n    onScaleGroup: \"scaleGroup\",\n    onScaleGroupEnd: \"scaleGroupEnd\"\n  },\n  render: function render(moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        scalable = _a.scalable,\n        edge = _a.edge;\n\n    if (!resizable && scalable) {\n      if (edge) {\n        return renderDiagonalDirections(moveable, React);\n      }\n\n      return renderAllDirections(moveable, React);\n    }\n  },\n  dragControlCondition: directionCondition,\n  dragControlStart: function dragControlStart(moveable, e) {\n    var datas = e.datas,\n        isPinch = e.isPinch,\n        inputEvent = e.inputEvent,\n        parentDirection = e.parentDirection;\n    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n    var _a = moveable.state,\n        width = _a.width,\n        height = _a.height,\n        targetTransform = _a.targetTransform,\n        target = _a.target,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        pos4 = _a.pos4;\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    if (!isPinch) {\n      setDragStart(moveable, e);\n    }\n\n    datas.datas = {};\n    datas.transform = targetTransform;\n    datas.prevDist = [1, 1];\n    datas.direction = direction;\n    datas.width = width;\n    datas.height = height;\n    datas.startValue = [1, 1];\n    var scaleWidth = getDist$1(pos1, pos2);\n    var scaleHeight = getDist$1(pos2, pos4);\n    var isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];\n    datas.scaleWidth = scaleWidth;\n    datas.scaleHeight = scaleHeight;\n    datas.scaleXRatio = scaleWidth / width;\n    datas.scaleYRatio = scaleHeight / height;\n    setDefaultTransformIndex(e, \"scale\");\n    datas.isWidth = isWidth;\n\n    function setRatio(ratio) {\n      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n    }\n\n    function setFixedDirection(fixedDirection) {\n      datas.fixedDirection = fixedDirection;\n      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);\n    }\n\n    setRatio(getDist$1(pos1, pos2) / getDist$1(pos2, pos4));\n    setFixedDirection([-direction[0], -direction[1]]);\n    var params = fillParams(moveable, e, _assign(_assign({\n      direction: direction,\n      set: function set(scale) {\n        datas.startValue = scale;\n      },\n      setRatio: setRatio,\n      setFixedDirection: setFixedDirection\n    }, fillTransformStartEvent(e)), {\n      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))\n    }));\n    var result = triggerEvent(moveable, \"onScaleStart\", params);\n\n    if (result !== false) {\n      datas.isScale = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction: direction\n      };\n    }\n\n    return datas.isScale ? params : false;\n  },\n  dragControl: function dragControl(moveable, e) {\n    resolveTransformEvent(e, \"scale\");\n    var datas = e.datas,\n        distX = e.distX,\n        distY = e.distY,\n        parentScale = e.parentScale,\n        parentDistance = e.parentDistance,\n        parentKeepRatio = e.parentKeepRatio,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        dragClient = e.dragClient,\n        parentDist = e.parentDist,\n        isRequest = e.isRequest;\n    var prevDist = datas.prevDist,\n        direction = datas.direction,\n        width = datas.width,\n        height = datas.height,\n        isScale = datas.isScale,\n        startValue = datas.startValue,\n        isWidth = datas.isWidth,\n        ratio = datas.ratio,\n        fixedDirection = datas.fixedDirection,\n        scaleXRatio = datas.scaleXRatio,\n        scaleYRatio = datas.scaleYRatio;\n\n    if (!isScale) {\n      return false;\n    }\n\n    var _a = moveable.props,\n        throttleScale = _a.throttleScale,\n        parentMoveable = _a.parentMoveable;\n    var sizeDirection = direction;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n\n    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);\n    var state = moveable.state;\n    var scaleX = 1;\n    var scaleY = 1;\n    var fixedPosition = dragClient;\n\n    if (!dragClient) {\n      if (!parentFlag && isPinch) {\n        fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n      } else {\n        fixedPosition = datas.fixedPosition;\n      }\n    }\n\n    if (parentDist) {\n      scaleX = (width + parentDist[0]) / width;\n      scaleY = (height + parentDist[1]) / height;\n    } else if (parentScale) {\n      scaleX = parentScale[0];\n      scaleY = parentScale[1];\n    } else if (isPinch) {\n      if (parentDistance) {\n        scaleX = (width + parentDistance) / width;\n        scaleY = (height + parentDistance * height / width) / height;\n      }\n    } else {\n      var dragDist = getDragDist({\n        datas: datas,\n        distX: distX,\n        distY: distY\n      });\n      var distScaleWidth = sizeDirection[0] * dragDist[0] * scaleXRatio;\n      var distScaleHeight = sizeDirection[1] * dragDist[1] * scaleYRatio;\n\n      if (keepRatio && width && height) {\n        if (!sizeDirection[0]) {\n          // top, bottom\n          // distHeight = signSize;\n          distScaleWidth = distScaleHeight * ratio;\n        } else if (!sizeDirection[1]) {\n          // left, right\n          // distWidth = signSize;\n          distScaleHeight = distScaleWidth / ratio;\n        } else {\n          var size = getDistSize([distScaleWidth, distScaleHeight]); // two-way\n\n          var dragRad = getRad([0, 0], dragDist);\n          var standardRad = getRad([0, 0], sizeDirection);\n          var signSize = Math.cos(dragRad - standardRad) * size;\n          var ratioRad = getRad([0, 0], [ratio, 1]);\n          distScaleWidth = Math.cos(ratioRad) * signSize;\n          distScaleHeight = Math.sin(ratioRad) * signSize;\n        }\n      }\n\n      scaleX = (width + distScaleWidth / scaleXRatio) / width;\n      scaleY = (height + distScaleHeight / scaleYRatio) / height;\n    }\n\n    scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];\n    scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];\n\n    if (scaleX === 0) {\n      scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    if (scaleY === 0) {\n      scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    var dist = [scaleX / startValue[0], scaleY / startValue[1]];\n    var scale = [scaleX, scaleY];\n\n    if (!isPinch && moveable.props.groupable) {\n      var snapRenderInfo = state.snapRenderInfo || {};\n      var stateDirection = snapRenderInfo.direction;\n\n      if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n        state.snapRenderInfo = {\n          direction: direction,\n          request: e.isRequest\n        };\n      }\n    }\n\n    var snapDist = [0, 0];\n\n    if (!isPinch) {\n      snapDist = checkSnapScale(moveable, dist, direction, isRequest, datas);\n    }\n\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (Math.abs(snapDist[0] * width) > Math.abs(snapDist[1] * height)) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n\n      var isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        if (isWidth) {\n          dist[0] = throttle(dist[0] * startValue[0], throttleScale) / startValue[0];\n        } else {\n          dist[1] = throttle(dist[1] * startValue[1], throttleScale) / startValue[1];\n        }\n      }\n\n      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n        dist[0] += snapDist[0];\n        var snapHeight = width * dist[0] * startValue[0] / ratio;\n        dist[1] = snapHeight / height / startValue[1];\n      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n        dist[1] += snapDist[1];\n        var snapWidth = height * dist[1] * startValue[1] * ratio;\n        dist[0] = snapWidth / width / startValue[0];\n      }\n    } else {\n      dist[0] += snapDist[0];\n      dist[1] += snapDist[1];\n\n      if (!snapDist[0]) {\n        dist[0] = throttle(dist[0] * startValue[0], throttleScale) / startValue[0];\n      }\n\n      if (!snapDist[1]) {\n        dist[1] = throttle(dist[1] * startValue[1], throttleScale) / startValue[1];\n      }\n    }\n\n    if (dist[0] === 0) {\n      dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    if (dist[1] === 0) {\n      dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    var delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];\n    scale = multiply2(dist, startValue);\n    var inverseDist = getScaleDist(moveable, dist, fixedDirection, fixedPosition, datas);\n    var inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);\n    datas.prevDist = dist;\n    datas.prevInverseDist = inverseDist;\n\n    if (scaleX === prevDist[0] && scaleY === prevDist[1] && inverseDelta.every(function (num) {\n      return !num;\n    }) && !parentMoveable) {\n      return false;\n    }\n\n    var nextTransform = convertTransformFormat(datas, \"scale(\" + scale.join(\", \") + \")\", \"scale(\" + dist.join(\", \") + \")\");\n    var params = fillParams(moveable, e, _assign({\n      offsetWidth: width,\n      offsetHeight: height,\n      direction: direction,\n      // beforeScale,\n      // beforeDist,\n      // beforeDelta,\n      scale: scale,\n      dist: dist,\n      delta: delta,\n      isPinch: !!isPinch\n    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));\n    triggerEvent(moveable, \"onScale\", params);\n    return params;\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isScale) {\n      return false;\n    }\n\n    datas.isScale = false;\n    triggerEvent(moveable, \"onScaleEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function dragGroupControlStart(moveable, e) {\n    var datas = e.datas;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var originalEvents = fillChildEvents(moveable, \"resizable\", e);\n\n    function setDist(child, ev) {\n      var fixedDirection = datas.fixedDirection;\n      var fixedPosition = datas.fixedPosition;\n      var pos = getAbsolutePosition(child, fixedDirection);\n\n      var _a = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),\n          originalX = _a[0],\n          originalY = _a[1];\n\n      ev.datas.originalX = originalX;\n      ev.datas.originalY = originalY;\n      return ev;\n    }\n\n    datas.moveableScale = moveable.scale;\n    var events = triggerChildAbles(moveable, this, \"dragControlStart\", e, function (child, ev) {\n      return setDist(child, ev);\n    });\n\n    var nextParams = _assign(_assign({}, params), {\n      targets: moveable.props.targets,\n      events: events,\n      setFixedDirection: function setFixedDirection(fixedDirection) {\n        params.setFixedDirection(fixedDirection);\n        events.forEach(function (ev, i) {\n          ev.setFixedDirection(fixedDirection);\n          setDist(moveable.moveables[i], originalEvents[i]);\n        });\n      }\n    });\n\n    var result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n    datas.isScale = result !== false;\n    return datas.isScale ? nextParams : false;\n  },\n  dragGroupControl: function dragGroupControl(moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isScale) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var moveableScale = datas.moveableScale;\n    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];\n    var keepRatio = moveable.props.keepRatio;\n    var dist = params.dist,\n        scale = params.scale;\n    var fixedPosition = datas.fixedPosition;\n    var events = triggerChildAbles(moveable, this, \"dragControl\", e, function (_, ev) {\n      var _a = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1], 3),\n          clientX = _a[0],\n          clientY = _a[1];\n\n      return _assign(_assign({}, ev), {\n        parentDist: null,\n        parentScale: scale,\n        parentKeepRatio: keepRatio,\n        dragClient: plus(fixedPosition, [clientX, clientY])\n      });\n    });\n\n    var nextParams = _assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onScaleGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function dragGroupControlEnd(moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isScale) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets\n    });\n    triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Scalable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.direction=[1, 1]] - Direction to scale\n   * @param {number} [e.deltaWidth] - delta number of width\n   * @param {number} [e.deltaHeight] - delta number of height\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"scalable\");\n   *\n   * // request\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function request() {\n    var datas = {};\n    var distWidth = 0;\n    var distHeight = 0;\n    return {\n      isControl: true,\n      requestStart: function requestStart(e) {\n        return {\n          datas: datas,\n          parentDirection: e.direction || [1, 1]\n        };\n      },\n      request: function request(e) {\n        distWidth += e.deltaWidth;\n        distHeight += e.deltaHeight;\n        return {\n          datas: datas,\n          parentDist: [distWidth, distHeight]\n        };\n      },\n      requestEnd: function requestEnd() {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * Whether or not target can scaled. (default: false)\n * @name Moveable.Scalable#scalable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When scaling, the scale event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the scale event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When the scale finishes, the scaleEnd event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the scaleEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group scale starts, the `scaleGroupStart` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroupStart\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\n*     console.log(\"onScaleGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group scale, the `scaleGroup` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroup\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\n*     console.log(\"onScaleGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group scale.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const scaleX = ev.scale[0];\n*         const scaleY = ev.scale[1];\n*     });\n* });\n*/\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n\nfunction getMiddleLinePos(pos1, pos2) {\n  return pos1.map(function (pos, i) {\n    return dot(pos, pos2[i], 1, 2);\n  });\n}\n\nfunction getTriangleRad(pos1, pos2, pos3) {\n  // pos1 Rad\n  var rad1 = getRad(pos1, pos2);\n  var rad2 = getRad(pos1, pos3);\n  var rad = rad2 - rad1;\n  return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1, poses2) {\n  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n  var pi = Math.PI;\n\n  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\n\n\nvar Warpable = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: {\n    warpable: Boolean,\n    renderDirections: Array\n  },\n  events: {\n    onWarpStart: \"warpStart\",\n    onWarp: \"warp\",\n    onWarpEnd: \"warpEnd\"\n  },\n  render: function render(moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        scalable = _a.scalable,\n        warpable = _a.warpable,\n        zoom = _a.zoom;\n\n    if (resizable || scalable || !warpable) {\n      return [];\n    }\n\n    var _b = moveable.state,\n        pos1 = _b.pos1,\n        pos2 = _b.pos2,\n        pos3 = _b.pos3,\n        pos4 = _b.pos4;\n    var linePosFrom1 = getMiddleLinePos(pos1, pos2);\n    var linePosFrom2 = getMiddleLinePos(pos2, pos1);\n    var linePosFrom3 = getMiddleLinePos(pos1, pos3);\n    var linePosFrom4 = getMiddleLinePos(pos3, pos1);\n    var linePosTo1 = getMiddleLinePos(pos3, pos4);\n    var linePosTo2 = getMiddleLinePos(pos4, pos3);\n    var linePosTo3 = getMiddleLinePos(pos2, pos4);\n    var linePosTo4 = getMiddleLinePos(pos4, pos2);\n    return __spreadArrays([React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine1\",\n      style: getLineStyle(linePosFrom1, linePosTo1, zoom)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine2\",\n      style: getLineStyle(linePosFrom2, linePosTo2, zoom)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine3\",\n      style: getLineStyle(linePosFrom3, linePosTo3, zoom)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine4\",\n      style: getLineStyle(linePosFrom4, linePosTo4, zoom)\n    })], renderAllDirections(moveable, React));\n  },\n  dragControlCondition: function dragControlCondition(moveable, e) {\n    if (e.isRequest) {\n      return false;\n    }\n\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    var datas = e.datas,\n        inputEvent = e.inputEvent;\n    var target = moveable.props.target;\n    var inputTarget = inputEvent.target;\n    var direction = getDirection(inputTarget);\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    var state = moveable.state;\n    var transformOrigin = state.transformOrigin,\n        is3d = state.is3d,\n        targetTransform = state.targetTransform,\n        targetMatrix = state.targetMatrix,\n        width = state.width,\n        height = state.height,\n        left = state.left,\n        top = state.top;\n    datas.datas = {};\n    datas.targetTransform = targetTransform;\n    datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n    datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n    datas.direction = direction;\n    datas.left = left;\n    datas.top = top;\n    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function (p) {\n      return minus(p, transformOrigin);\n    });\n    datas.nextPoses = datas.poses.map(function (_a) {\n      var x = _a[0],\n          y = _a[1];\n      return calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4);\n    });\n    datas.startValue = createIdentityMatrix(4);\n    datas.prevMatrix = createIdentityMatrix(4);\n    datas.absolutePoses = getAbsolutePosesByState(state);\n    datas.posIndexes = getPosIndexesByDirection(direction);\n    setDragStart(moveable, e);\n    setDefaultTransformIndex(e, \"matrix3d\");\n    state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: direction\n    };\n    var params = fillParams(moveable, e, _assign({\n      set: function set(matrix) {\n        datas.startValue = matrix;\n      }\n    }, fillTransformStartEvent(e)));\n    var result = triggerEvent(moveable, \"onWarpStart\", params);\n\n    if (result !== false) {\n      datas.isWarp = true;\n    }\n\n    return datas.isWarp;\n  },\n  dragControl: function dragControl(moveable, e) {\n    var datas = e.datas,\n        isRequest = e.isRequest;\n    var distX = e.distX,\n        distY = e.distY;\n    var targetInverseMatrix = datas.targetInverseMatrix,\n        prevMatrix = datas.prevMatrix,\n        isWarp = datas.isWarp,\n        startValue = datas.startValue,\n        poses = datas.poses,\n        posIndexes = datas.posIndexes,\n        absolutePoses = datas.absolutePoses;\n\n    if (!isWarp) {\n      return false;\n    }\n\n    resolveTransformEvent(e, \"matrix3d\");\n\n    if (hasGuidelines(moveable, \"warpable\")) {\n      var selectedPoses = posIndexes.map(function (index) {\n        return absolutePoses[index];\n      });\n\n      if (selectedPoses.length > 1) {\n        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);\n      }\n\n      var _a = checkMoveableSnapBounds(moveable, isRequest, selectedPoses.map(function (pos) {\n        return [pos[0] + distX, pos[1] + distY];\n      })),\n          horizontalSnapInfo = _a.horizontal,\n          verticalSnapInfo = _a.vertical;\n\n      distY -= horizontalSnapInfo.offset;\n      distX -= verticalSnapInfo.offset;\n    }\n\n    var dist = getDragDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }, true);\n    var nextPoses = datas.nextPoses.slice();\n    posIndexes.forEach(function (index) {\n      nextPoses[index] = plus(nextPoses[index], dist);\n    });\n\n    if (!NEARBY_POS.every(function (nearByPoses) {\n      return isValidPos(nearByPoses.map(function (i) {\n        return poses[i];\n      }), nearByPoses.map(function (i) {\n        return nextPoses[i];\n      }));\n    })) {\n      return false;\n    }\n\n    var h = createWarpMatrix(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);\n\n    if (!h.length) {\n      return false;\n    } // B * A * M\n\n\n    var afterMatrix = multiply(targetInverseMatrix, h, 4); // B * M * A\n\n    var matrix = getTransfromMatrix(datas, afterMatrix, true);\n    var delta = multiply(invert(prevMatrix, 4), matrix, 4);\n    datas.prevMatrix = matrix;\n    var totalMatrix = multiply(startValue, matrix, 4);\n    var nextTransform = convertTransformFormat(datas, \"matrix3d(\" + totalMatrix.join(\", \") + \")\", \"matrix3d(\" + matrix.join(\", \") + \")\");\n    fillOriginalTransform(e, nextTransform);\n    triggerEvent(moveable, \"onWarp\", fillParams(moveable, e, {\n      delta: delta,\n      matrix: totalMatrix,\n      dist: matrix,\n      multiply: multiply,\n      transform: nextTransform\n    }));\n    return true;\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isWarp) {\n      return false;\n    }\n\n    datas.isWarp = false;\n    triggerEvent(moveable, \"onWarpEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  }\n};\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n/**\n* Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n* @name Moveable.Warpable#renderDirections\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     warpable: true,\n*     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n* });\n*\n* moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n*/\n\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable.Warpable\n* @event warpStart\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\nvar AREA_PIECES = /*#__PURE__*/prefix(\"area-pieces\");\nvar AREA_PIECE = /*#__PURE__*/prefix(\"area-piece\");\nvar AVOID = /*#__PURE__*/prefix(\"avoid\");\n\nfunction restoreStyle(moveable) {\n  var el = moveable.areaElement;\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height;\n  removeClass(el, AVOID);\n  el.style.cssText += \"left: 0px; top: 0px; width: \" + width + \"px; height: \" + height + \"px\";\n}\n\nfunction renderPieces(React) {\n  return React.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: AREA_PIECES\n  }, React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }));\n}\n\nvar DragArea = {\n  name: \"dragArea\",\n  props: {\n    dragArea: Boolean,\n    passDragArea: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  render: function render(moveable, React) {\n    var _a = moveable.props,\n        target = _a.target,\n        dragArea = _a.dragArea,\n        groupable = _a.groupable,\n        passDragArea = _a.passDragArea;\n    var _b = moveable.state,\n        width = _b.width,\n        height = _b.height,\n        renderPoses = _b.renderPoses;\n    var className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\n\n    if (groupable) {\n      return [React.createElement(\"div\", {\n        key: \"area\",\n        ref: ref(moveable, \"areaElement\"),\n        className: className\n      }), renderPieces(React)];\n    }\n\n    if (!target || !dragArea) {\n      return [];\n    }\n\n    var h = createWarpMatrix([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);\n    var transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n    return [React.createElement(\"div\", {\n      key: \"area\",\n      ref: ref(moveable, \"areaElement\"),\n      className: className,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: width + \"px\",\n        height: height + \"px\",\n        transformOrigin: \"0 0\",\n        transform: transform\n      }\n    }), renderPieces(React)];\n  },\n  dragStart: function dragStart(moveable, _a) {\n    var datas = _a.datas,\n        clientX = _a.clientX,\n        clientY = _a.clientY,\n        inputEvent = _a.inputEvent;\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    datas.isDragArea = false;\n    var areaElement = moveable.areaElement;\n    var state = moveable.state;\n    var moveableClientRect = state.moveableClientRect,\n        renderPoses = state.renderPoses,\n        rootMatrix = state.rootMatrix,\n        is3d = state.is3d;\n    var left = moveableClientRect.left,\n        top = moveableClientRect.top;\n\n    var _b = getRect(renderPoses),\n        relativeLeft = _b.left,\n        relativeTop = _b.top,\n        width = _b.width,\n        height = _b.height;\n\n    var n = is3d ? 4 : 3;\n\n    var _c = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n),\n        posX = _c[0],\n        posY = _c[1];\n\n    posX -= relativeLeft;\n    posY -= relativeTop;\n    var rects = [{\n      left: relativeLeft,\n      top: relativeTop,\n      width: width,\n      height: posY - 10\n    }, {\n      left: relativeLeft,\n      top: relativeTop,\n      width: posX - 10,\n      height: height\n    }, {\n      left: relativeLeft,\n      top: relativeTop + posY + 10,\n      width: width,\n      height: height - posY - 10\n    }, {\n      left: relativeLeft + posX + 10,\n      top: relativeTop,\n      width: width - posX - 10,\n      height: height\n    }];\n    var children = [].slice.call(areaElement.nextElementSibling.children);\n    rects.forEach(function (rect, i) {\n      children[i].style.cssText = \"left: \" + rect.left + \"px;top: \" + rect.top + \"px; width: \" + rect.width + \"px; height: \" + rect.height + \"px;\";\n    });\n    addClass(areaElement, AVOID);\n    state.disableNativeEvent = true;\n    return;\n  },\n  drag: function drag(moveable, _a) {\n    var datas = _a.datas,\n        inputEvent = _a.inputEvent;\n    this.enableNativeEvent(moveable);\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    if (!datas.isDragArea) {\n      datas.isDragArea = true;\n      restoreStyle(moveable);\n    }\n  },\n  dragEnd: function dragEnd(moveable, e) {\n    this.enableNativeEvent(moveable);\n    var inputEvent = e.inputEvent,\n        datas = e.datas;\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    if (!datas.isDragArea) {\n      restoreStyle(moveable);\n    }\n  },\n  dragGroupStart: function dragGroupStart(moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragGroup: function dragGroup(moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragGroupEnd: function dragGroupEnd(moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  unset: function unset(moveable) {\n    restoreStyle(moveable);\n    moveable.state.disableNativeEvent = false;\n  },\n  enableNativeEvent: function enableNativeEvent(moveable) {\n    var state = moveable.state;\n\n    if (state.disableNativeEvent) {\n      requestAnimationFrame(function () {\n        state.disableNativeEvent = false;\n      });\n    }\n  }\n};\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n\n/**\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\n * @name Moveable#passDragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n\nvar Origin = makeAble(\"origin\", {\n  render: function render(moveable, React) {\n    var zoom = moveable.props.zoom;\n    var _a = moveable.state,\n        beforeOrigin = _a.beforeOrigin,\n        rotation = _a.rotation;\n    return [React.createElement(\"div\", {\n      className: prefix(\"control\", \"origin\"),\n      style: getControlTransform(rotation, zoom, beforeOrigin),\n      key: \"beforeOrigin\"\n    })];\n  }\n});\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n\nfunction getDefaultScrollPosition(e) {\n  var scrollContainer = e.scrollContainer;\n  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\n\n\nvar Scrollable = {\n  name: \"scrollable\",\n  canPinch: true,\n  props: {\n    scrollable: Boolean,\n    scrollContainer: Object,\n    scrollThreshold: Number,\n    getScrollPosition: Function\n  },\n  events: {\n    onScroll: \"scroll\",\n    onScrollGroup: \"scrollGroup\"\n  },\n  dragStart: function dragStart(moveable, e) {\n    var props = moveable.props;\n    var _a = props.scrollContainer,\n        scrollContainer = _a === void 0 ? moveable.getContainer() : _a;\n    var dragScroll = new DragScroll();\n    var scrollContainerElement = getRefTarget(scrollContainer, true);\n    e.datas.dragScroll = dragScroll;\n    var gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n    var targets = e.targets;\n    dragScroll.on(\"scroll\", function (_a) {\n      var container = _a.container,\n          direction = _a.direction;\n      var params = fillParams(moveable, e, {\n        scrollContainer: container,\n        direction: direction\n      });\n      var eventName = targets ? \"onScrollGroup\" : \"onScroll\";\n\n      if (targets) {\n        params.targets = targets;\n      }\n\n      triggerEvent(moveable, eventName, params);\n    }).on(\"move\", function (_a) {\n      var offsetX = _a.offsetX,\n          offsetY = _a.offsetY;\n      moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n    });\n    dragScroll.dragStart(e, {\n      container: scrollContainerElement\n    });\n  },\n  checkScroll: function checkScroll(moveable, e) {\n    var dragScroll = e.datas.dragScroll;\n\n    if (!dragScroll) {\n      return;\n    }\n\n    var _a = moveable.props,\n        _b = _a.scrollContainer,\n        scrollContainer = _b === void 0 ? moveable.getContainer() : _b,\n        _c = _a.scrollThreshold,\n        scrollThreshold = _c === void 0 ? 0 : _c,\n        _d = _a.getScrollPosition,\n        _getScrollPosition = _d === void 0 ? getDefaultScrollPosition : _d;\n\n    dragScroll.drag(e, {\n      container: scrollContainer,\n      threshold: scrollThreshold,\n      getScrollPosition: function getScrollPosition(ev) {\n        return _getScrollPosition({\n          scrollContainer: ev.container,\n          direction: ev.direction\n        });\n      }\n    });\n    return true;\n  },\n  drag: function drag(moveable, e) {\n    return this.checkScroll(moveable, e);\n  },\n  dragEnd: function dragEnd(moveable, e) {\n    e.datas.dragScroll.dragEnd();\n    e.datas.dragScroll = null;\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    return this.dragStart(moveable, _assign(_assign({}, e), {\n      isControl: true\n    }));\n  },\n  dragControl: function dragControl(moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupStart: function dragGroupStart(moveable, e) {\n    return this.dragStart(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroup: function dragGroup(moveable, e) {\n    return this.drag(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupEnd: function dragGroupEnd(moveable, e) {\n    return this.dragEnd(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupControlStart: function dragGroupControlStart(moveable, e) {\n    return this.dragStart(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets,\n      isControl: true\n    }));\n  },\n  dragGroupContro: function dragGroupContro(moveable, e) {\n    return this.drag(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupControEnd: function dragGroupControEnd(moveable, e) {\n    return this.dragEnd(moveable, _assign(_assign({}, e), {\n      targets: moveable.props.targets\n    }));\n  }\n};\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable.Scrollable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable.Scrollable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable.Scrollable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable.Scrollable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\nvar Default = {\n  name: \"\",\n  props: {\n    target: Object,\n    dragTarget: Object,\n    container: Object,\n    portalContainer: Object,\n    rootContainer: Object,\n    zoom: Number,\n    transformOrigin: Array,\n    edge: Boolean,\n    ables: Array,\n    className: String,\n    pinchThreshold: Number,\n    pinchOutside: Boolean,\n    triggerAblesSimultaneously: Boolean,\n    checkInput: Boolean,\n    cspNonce: String,\n    translateZ: Number,\n    props: Object\n  },\n  events: {}\n};\nvar Padding = makeAble(\"padding\", {\n  render: function render(moveable, React) {\n    var props = moveable.props;\n\n    if (props.dragArea) {\n      return [];\n    }\n\n    var padding = props.padding || {};\n    var _a = padding.left,\n        left = _a === void 0 ? 0 : _a,\n        _b = padding.top,\n        top = _b === void 0 ? 0 : _b,\n        _c = padding.right,\n        right = _c === void 0 ? 0 : _c,\n        _d = padding.bottom,\n        bottom = _d === void 0 ? 0 : _d;\n    var _e = moveable.state,\n        renderPoses = _e.renderPoses,\n        pos1 = _e.pos1,\n        pos2 = _e.pos2,\n        pos3 = _e.pos3,\n        pos4 = _e.pos4;\n    var poses = [pos1, pos2, pos3, pos4];\n    var paddingDirections = [];\n\n    if (left > 0) {\n      paddingDirections.push([0, 2]);\n    }\n\n    if (top > 0) {\n      paddingDirections.push([0, 1]);\n    }\n\n    if (right > 0) {\n      paddingDirections.push([1, 3]);\n    }\n\n    if (bottom > 0) {\n      paddingDirections.push([2, 3]);\n    }\n\n    return paddingDirections.map(function (_a, i) {\n      var dir1 = _a[0],\n          dir2 = _a[1];\n      var paddingPos1 = poses[dir1];\n      var paddingPos2 = poses[dir2];\n      var paddingPos3 = renderPoses[dir1];\n      var paddingPos4 = renderPoses[dir2];\n      var h = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);\n\n      if (!h.length) {\n        return undefined;\n      }\n\n      return React.createElement(\"div\", {\n        key: \"padding\" + i,\n        className: prefix(\"padding\"),\n        style: {\n          transform: makeMatrixCSS(h, true)\n        }\n      });\n    });\n  }\n});\n/**\n * Add padding around the target to increase the drag area. (default: null)\n * @name Moveable#padding\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n\nvar RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"];\n\nfunction calculateRatio(values, size) {\n  var sumSize = values[0] + values[1];\n  var sumRatio = sumSize > size ? size / sumSize : 1;\n  values[0] *= sumRatio;\n  values[1] = size - values[1] * sumRatio;\n  return values;\n}\n\nvar HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nvar VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nvar HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];\nvar VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];\n\nfunction getRadiusStyles(poses, controlPoses, isRelative, width, height, left, top, right, bottom) {\n  if (left === void 0) {\n    left = 0;\n  }\n\n  if (top === void 0) {\n    top = 0;\n  }\n\n  if (right === void 0) {\n    right = width;\n  }\n\n  if (bottom === void 0) {\n    bottom = height;\n  }\n\n  var clipStyles = [];\n  var isVertical = false;\n  var raws = poses.map(function (pos, i) {\n    var _a = controlPoses[i],\n        horizontal = _a.horizontal,\n        vertical = _a.vertical;\n\n    if (vertical && !isVertical) {\n      isVertical = true;\n      clipStyles.push(\"/\");\n    }\n\n    if (isVertical) {\n      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n      clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n      return rawPos;\n    } else {\n      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n      clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n      return rawPos;\n    }\n  });\n  return {\n    styles: clipStyles,\n    raws: raws\n  };\n}\n\nfunction getRadiusRange(controlPoses) {\n  // [start, length]\n  var horizontalRange = [0, 0];\n  var verticalRange = [0, 0];\n  var length = controlPoses.length;\n\n  for (var i = 0; i < length; ++i) {\n    var clipPose = controlPoses[i];\n\n    if (!clipPose.sub) {\n      continue;\n    }\n\n    if (clipPose.horizontal) {\n      if (horizontalRange[1] === 0) {\n        horizontalRange[0] = i;\n      }\n\n      horizontalRange[1] = i - horizontalRange[0] + 1;\n      verticalRange[0] = i + 1;\n    }\n\n    if (clipPose.vertical) {\n      if (verticalRange[1] === 0) {\n        verticalRange[0] = i;\n      }\n\n      verticalRange[1] = i - verticalRange[0] + 1;\n    }\n  }\n\n  return {\n    horizontalRange: horizontalRange,\n    verticalRange: verticalRange\n  };\n}\n\nfunction getRadiusValues(values, width, height, left, top, minCounts) {\n  var _a, _b, _c, _d;\n\n  if (minCounts === void 0) {\n    minCounts = [0, 0];\n  }\n\n  var splitIndex = values.indexOf(\"/\");\n  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n  var horizontalValues = values.slice(0, splitLength);\n  var verticalValues = values.slice(splitLength + 1);\n  var _e = horizontalValues[0],\n      nwValue = _e === void 0 ? \"0px\" : _e,\n      _f = horizontalValues[1],\n      neValue = _f === void 0 ? nwValue : _f,\n      _g = horizontalValues[2],\n      seValue = _g === void 0 ? nwValue : _g,\n      _h = horizontalValues[3],\n      swValue = _h === void 0 ? neValue : _h;\n  var _j = verticalValues[0],\n      wnValue = _j === void 0 ? nwValue : _j,\n      _k = verticalValues[1],\n      enValue = _k === void 0 ? wnValue : _k,\n      _l = verticalValues[2],\n      esValue = _l === void 0 ? wnValue : _l,\n      _m = verticalValues[3],\n      wsValue = _m === void 0 ? enValue : _m;\n  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function (pos) {\n    return convertUnitSize(pos, width);\n  });\n  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function (pos) {\n    return convertUnitSize(pos, height);\n  });\n  var horizontalPoses = horizontalRawPoses.slice();\n  var verticalPoses = verticalRawPoses.slice();\n  _a = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a[0], horizontalPoses[1] = _a[1];\n  _b = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];\n  _c = calculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];\n  _d = calculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];\n  var nextHorizontalPoses = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));\n  var nextVerticalPoses = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));\n  return __spreadArrays(nextHorizontalPoses.map(function (pos, i) {\n    var direction = RADIUS_DIRECTIONS[i];\n    return {\n      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n      vertical: 0,\n      pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n      sub: true,\n      raw: horizontalRawPoses[i],\n      direction: direction\n    };\n  }), nextVerticalPoses.map(function (pos, i) {\n    var direction = RADIUS_DIRECTIONS[i];\n    return {\n      horizontal: 0,\n      vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n      pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n      sub: true,\n      raw: verticalRawPoses[i],\n      direction: direction\n    };\n  }));\n}\n\nfunction removeRadiusPos(controlPoses, poses, index, startIndex, length) {\n  if (length === void 0) {\n    length = poses.length;\n  }\n\n  var _a = getRadiusRange(controlPoses.slice(startIndex)),\n      horizontalRange = _a.horizontalRange,\n      verticalRange = _a.verticalRange;\n\n  var radiuslIndex = index - startIndex;\n  var deleteCount = 0;\n\n  if (radiuslIndex === 0) {\n    deleteCount = length;\n  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n    deleteCount = horizontalRange[1] - radiuslIndex;\n  } else if (radiuslIndex >= verticalRange[0]) {\n    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n  } else {\n    return;\n  }\n\n  controlPoses.splice(index, deleteCount);\n  poses.splice(index, deleteCount);\n}\n\nfunction addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {\n  if (left === void 0) {\n    left = 0;\n  }\n\n  if (top === void 0) {\n    top = 0;\n  }\n\n  var _a = getRadiusRange(controlPoses.slice(startIndex)),\n      horizontalRange = _a.horizontalRange,\n      verticalRange = _a.verticalRange;\n\n  if (horizontalIndex > -1) {\n    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;\n\n    for (var i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n      var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n      var x = 0;\n\n      if (horizontalIndex === i) {\n        x = distX;\n      } else if (i === 0) {\n        x = left + radiusX;\n      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n        x = right - (poses[startIndex][0] - left);\n      }\n\n      controlPoses.splice(startIndex + i, 0, {\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n        vertical: 0,\n        pos: [x, y]\n      });\n      poses.splice(startIndex + i, 0, [x, y]);\n\n      if (i === 0) {\n        break;\n      }\n    }\n  } else if (verticalIndex > -1) {\n    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;\n\n    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n      var pos = [left + radiusY, top];\n      controlPoses.push({\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n        vertical: 0,\n        pos: pos\n      });\n      poses.push(pos);\n    }\n\n    var startVerticalIndex = verticalRange[0];\n\n    for (var i = verticalRange[1]; i <= verticalIndex; ++i) {\n      var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n      var y = 0;\n\n      if (verticalIndex === i) {\n        y = distY;\n      } else if (i === 0) {\n        y = top + radiusY;\n      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n        y = poses[startIndex + startVerticalIndex][1];\n      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n        y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n      }\n\n      controlPoses.push({\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n        pos: [x, y]\n      });\n      poses.push([x, y]);\n\n      if (i === 0) {\n        break;\n      }\n    }\n  }\n}\n\nfunction splitRadiusPoses(controlPoses, raws) {\n  if (raws === void 0) {\n    raws = controlPoses.map(function (pos) {\n      return pos.raw;\n    });\n  }\n\n  var horizontals = controlPoses.map(function (pos, i) {\n    return pos.horizontal ? raws[i] : null;\n  }).filter(function (pos) {\n    return pos != null;\n  });\n  var verticals = controlPoses.map(function (pos, i) {\n    return pos.vertical ? raws[i] : null;\n  }).filter(function (pos) {\n    return pos != null;\n  });\n  return {\n    horizontals: horizontals,\n    verticals: verticals\n  };\n}\n\nvar CLIP_DIRECTIONS = [[0, -1, \"n\"], [1, 0, \"e\"]];\nvar CLIP_RECT_DIRECTIONS = [[-1, -1, \"nw\"], [0, -1, \"n\"], [1, -1, \"ne\"], [1, 0, \"e\"], [1, 1, \"se\"], [0, 1, \"s\"], [-1, 1, \"sw\"], [-1, 0, \"w\"]]; // 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nfunction getClipStyles(moveable, clipPath, poses) {\n  var clipRelative = moveable.props.clipRelative;\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height;\n  var _b = clipPath,\n      clipType = _b.type,\n      clipPoses = _b.poses;\n  var isRect = clipType === \"rect\";\n  var isCircle = clipType === \"circle\";\n\n  if (clipType === \"polygon\") {\n    return poses.map(function (pos) {\n      return convertCSSSize(pos[0], width, clipRelative) + \" \" + convertCSSSize(pos[1], height, clipRelative);\n    });\n  } else if (isRect || clipType === \"inset\") {\n    var top = poses[1][1];\n    var right = poses[3][0];\n    var left = poses[7][0];\n    var bottom = poses[5][1];\n\n    if (isRect) {\n      return [top, right, bottom, left].map(function (pos) {\n        return pos + \"px\";\n      });\n    }\n\n    var clipStyles = [top, width - right, height - bottom, left].map(function (pos, i) {\n      return convertCSSSize(pos, i % 2 ? width : height, clipRelative);\n    });\n\n    if (poses.length > 8) {\n      var _c = minus(poses[4], poses[0]),\n          subWidth = _c[0],\n          subHeight = _c[1];\n\n      clipStyles.push.apply(clipStyles, __spreadArrays([\"round\"], getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left, top, right, bottom).styles));\n    }\n\n    return clipStyles;\n  } else if (isCircle || clipType === \"ellipse\") {\n    var center = poses[0];\n    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);\n    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n    clipStyles.push(\"at\", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));\n    return clipStyles;\n  }\n}\n\nfunction getRectPoses(top, right, bottom, left) {\n  var xs = [left, (left + right) / 2, right];\n  var ys = [top, (top + bottom) / 2, bottom];\n  return CLIP_RECT_DIRECTIONS.map(function (_a) {\n    var dirx = _a[0],\n        diry = _a[1],\n        dir = _a[2];\n    var x = xs[dirx + 1];\n    var y = ys[diry + 1];\n    return {\n      vertical: Math.abs(diry),\n      horizontal: Math.abs(dirx),\n      direction: dir,\n      pos: [x, y]\n    };\n  });\n}\n\nfunction getClipPath(target, width, height, defaultClip, customClip) {\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  var clipText = customClip;\n\n  if (!clipText) {\n    var style = getComputedStyle(target);\n    var clipPath = style.clipPath;\n    clipText = clipPath !== \"none\" ? clipPath : style.clip;\n  }\n\n  if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n    clipText = defaultClip;\n\n    if (!clipText) {\n      return;\n    }\n  }\n\n  var _h = splitBracket(clipText),\n      _j = _h.prefix,\n      clipPrefix = _j === void 0 ? clipText : _j,\n      _k = _h.value,\n      value = _k === void 0 ? \"\" : _k;\n\n  var isCircle = clipPrefix === \"circle\";\n  var splitter = \" \";\n\n  if (clipPrefix === \"polygon\") {\n    var values = splitComma(value || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n    splitter = \",\";\n    var poses = values.map(function (pos) {\n      var _a = pos.split(\" \"),\n          xPos = _a[0],\n          yPos = _a[1];\n\n      return {\n        vertical: 1,\n        horizontal: 1,\n        pos: [convertUnitSize(xPos, width), convertUnitSize(yPos, height)]\n      };\n    });\n    return {\n      type: clipPrefix,\n      clipText: clipText,\n      poses: poses,\n      splitter: splitter\n    };\n  } else if (isCircle || clipPrefix === \"ellipse\") {\n    var xPos = \"\";\n    var yPos = \"\";\n    var radiusX_1 = 0;\n    var radiusY_1 = 0;\n    var values = splitSpace(value);\n\n    if (isCircle) {\n      var radius = \"\";\n      _a = values[0], radius = _a === void 0 ? \"50%\" : _a, _b = values[2], xPos = _b === void 0 ? \"50%\" : _b, _c = values[3], yPos = _c === void 0 ? \"50%\" : _c;\n      radiusX_1 = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n      radiusY_1 = radiusX_1;\n    } else {\n      var xRadius = \"\";\n      var yRadius = \"\";\n      _d = values[0], xRadius = _d === void 0 ? \"50%\" : _d, _e = values[1], yRadius = _e === void 0 ? \"50%\" : _e, _f = values[3], xPos = _f === void 0 ? \"50%\" : _f, _g = values[4], yPos = _g === void 0 ? \"50%\" : _g;\n      radiusX_1 = convertUnitSize(xRadius, width);\n      radiusY_1 = convertUnitSize(yRadius, height);\n    }\n\n    var centerPos_1 = [convertUnitSize(xPos, width), convertUnitSize(yPos, height)];\n\n    var poses = __spreadArrays([{\n      vertical: 1,\n      horizontal: 1,\n      pos: centerPos_1,\n      direction: \"nesw\"\n    }], CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function (dir) {\n      return {\n        vertical: Math.abs(dir[1]),\n        horizontal: dir[0],\n        direction: dir[2],\n        sub: true,\n        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]\n      };\n    }));\n\n    return {\n      type: clipPrefix,\n      clipText: clipText,\n      radiusX: radiusX_1,\n      radiusY: radiusY_1,\n      left: centerPos_1[0] - radiusX_1,\n      top: centerPos_1[1] - radiusY_1,\n      poses: poses,\n      splitter: splitter\n    };\n  } else if (clipPrefix === \"inset\") {\n    var values = splitSpace(value || \"0 0 0 0\");\n    var roundIndex = values.indexOf(\"round\");\n    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n    var radiusValues = values.slice(rectLength + 1);\n\n    var _l = values.slice(0, rectLength),\n        topValue = _l[0],\n        _m = _l[1],\n        rightValue = _m === void 0 ? topValue : _m,\n        _o = _l[2],\n        bottomValue = _o === void 0 ? topValue : _o,\n        _p = _l[3],\n        leftValue = _p === void 0 ? rightValue : _p;\n\n    var _q = [topValue, bottomValue].map(function (pos) {\n      return convertUnitSize(pos, height);\n    }),\n        top = _q[0],\n        bottom = _q[1];\n\n    var _r = [leftValue, rightValue].map(function (pos) {\n      return convertUnitSize(pos, width);\n    }),\n        left = _r[0],\n        right = _r[1];\n\n    var nextRight = width - right;\n    var nextBottom = height - bottom;\n    var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top, left, top);\n\n    var poses = __spreadArrays(getRectPoses(top, nextRight, nextBottom, left), radiusPoses);\n\n    return {\n      type: \"inset\",\n      clipText: clipText,\n      poses: poses,\n      top: top,\n      left: left,\n      right: nextRight,\n      bottom: nextBottom,\n      radius: radiusValues,\n      splitter: splitter\n    };\n  } else if (clipPrefix === \"rect\") {\n    // top right bottom left\n    var values = splitComma(value || \"0px, \" + width + \"px, \" + height + \"px, 0px\");\n    splitter = \",\";\n\n    var _s = values.map(function (pos) {\n      var posValue = splitUnit(pos).value;\n      return posValue;\n    }),\n        top = _s[0],\n        right = _s[1],\n        bottom = _s[2],\n        left = _s[3];\n\n    var poses = getRectPoses(top, right, bottom, left);\n    return {\n      type: \"rect\",\n      clipText: clipText,\n      poses: poses,\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left,\n      values: values,\n      splitter: splitter\n    };\n  }\n\n  return;\n}\n\nfunction addClipPath(moveable, e) {\n  var _a = calculatePointerDist(moveable, e),\n      distX = _a[0],\n      distY = _a[1];\n\n  var _b = e.datas,\n      clipPath = _b.clipPath,\n      index = _b.index;\n  var _c = clipPath,\n      clipType = _c.type,\n      clipPoses = _c.poses,\n      splitter = _c.splitter;\n  var poses = clipPoses.map(function (pos) {\n    return pos.pos;\n  });\n\n  if (clipType === \"polygon\") {\n    poses.splice(index, 0, [distX, distY]);\n  } else if (clipType === \"inset\") {\n    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);\n    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);\n    var length = clipPoses.length;\n    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);\n\n    if (length === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n\n  var clipStyles = getClipStyles(moveable, clipPath, poses);\n  triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n    clipEventType: \"added\",\n    clipType: clipType,\n    poses: poses,\n    clipStyles: clipStyles,\n    clipStyle: clipType + \"(\" + clipStyles.join(splitter) + \")\",\n    distX: 0,\n    distY: 0\n  }));\n}\n\nfunction removeClipPath(moveable, e) {\n  var _a = e.datas,\n      clipPath = _a.clipPath,\n      index = _a.index;\n  var _b = clipPath,\n      clipType = _b.type,\n      clipPoses = _b.poses,\n      splitter = _b.splitter;\n  var poses = clipPoses.map(function (pos) {\n    return pos.pos;\n  });\n  var length = poses.length;\n\n  if (clipType === \"polygon\") {\n    clipPoses.splice(index, 1);\n    poses.splice(index, 1);\n  } else if (clipType === \"inset\") {\n    if (index < 8) {\n      return;\n    }\n\n    removeRadiusPos(clipPoses, poses, index, 8, length);\n\n    if (length === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n\n  var clipStyles = getClipStyles(moveable, clipPath, poses);\n  triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n    clipEventType: \"removed\",\n    clipType: clipType,\n    poses: poses,\n    clipStyles: clipStyles,\n    clipStyle: clipType + \"(\" + clipStyles.join(splitter) + \")\",\n    distX: 0,\n    distY: 0\n  }));\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\n\nvar Clippable = {\n  name: \"clippable\",\n  props: {\n    clippable: Boolean,\n    defaultClipPath: String,\n    customClipPath: String,\n    clipRelative: Boolean,\n    clipArea: Boolean,\n    dragWithClip: Boolean,\n    clipTargetBounds: Boolean,\n    clipVerticalGuidelines: Array,\n    clipHorizontalGuidelines: Array,\n    clipSnapThreshold: Boolean\n  },\n  events: {\n    onClipStart: \"clipStart\",\n    onClip: \"clip\",\n    onClipEnd: \"clipEnd\"\n  },\n  css: [\".control.clip-control {\\n    background: #6d6;\\n    cursor: pointer;\\n}\\n.control.clip-control.clip-radius {\\n    background: #d66;\\n}\\n.line.clip-line {\\n    background: #6e6;\\n    cursor: move;\\n    z-index: 1;\\n}\\n.clip-area {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n}\\n.clip-ellipse {\\n    position: absolute;\\n    cursor: move;\\n    border: 1px solid #6d6;\\n    border: var(--zoompx) solid #6d6;\\n    border-radius: 50%;\\n    transform-origin: 0px 0px;\\n}\", \":host {\\n    --bounds-color: #d66;\\n}\", \".guideline {\\n    pointer-events: none;\\n    z-index: 2;\\n}\", \".line.guideline.bounds {\\n    background: #d66;\\n    background: var(--bounds-color);\\n}\"],\n  render: function render(moveable, React) {\n    var _a = moveable.props,\n        customClipPath = _a.customClipPath,\n        defaultClipPath = _a.defaultClipPath,\n        clipArea = _a.clipArea,\n        zoom = _a.zoom;\n    var _b = moveable.state,\n        target = _b.target,\n        width = _b.width,\n        height = _b.height,\n        allMatrix = _b.allMatrix,\n        is3d = _b.is3d,\n        left = _b.left,\n        top = _b.top,\n        pos1 = _b.pos1,\n        pos2 = _b.pos2,\n        pos3 = _b.pos3,\n        pos4 = _b.pos4,\n        clipPathState = _b.clipPathState,\n        snapBoundInfos = _b.snapBoundInfos;\n\n    if (!target) {\n      return [];\n    }\n\n    var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n\n    if (!clipPath) {\n      return [];\n    }\n\n    var n = is3d ? 4 : 3;\n    var type = clipPath.type;\n    var clipPoses = clipPath.poses;\n    var poses = clipPoses.map(function (pos) {\n      // return [x, y];\n      var calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n      return [calculatedPos[0] - left, calculatedPos[1] - top];\n    });\n    var controls = [];\n    var lines = [];\n    var isRect = type === \"rect\";\n    var isInset = type === \"inset\";\n    var isPolygon = type === \"polygon\";\n\n    if (isRect || isInset || isPolygon) {\n      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;\n      lines = linePoses_1.map(function (to, i) {\n        var from = i === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i - 1];\n        var rad = getRad(from, to);\n        var dist = getDiagonalSize(from, to);\n        return React.createElement(\"div\", {\n          key: \"clipLine\" + i,\n          className: prefix(\"line\", \"clip-line\", \"snap-control\"),\n          \"data-clip-index\": i,\n          style: {\n            width: dist + \"px\",\n            transform: \"translate(\" + from[0] + \"px, \" + from[1] + \"px) rotate(\" + rad + \"rad) scaleY(\" + zoom + \")\"\n          }\n        });\n      });\n    }\n\n    controls = poses.map(function (pos, i) {\n      return React.createElement(\"div\", {\n        key: \"clipControl\" + i,\n        className: prefix(\"control\", \"clip-control\", \"snap-control\"),\n        \"data-clip-index\": i,\n        style: {\n          transform: \"translate(\" + pos[0] + \"px, \" + pos[1] + \"px) scale(\" + zoom + \")\"\n        }\n      });\n    });\n\n    if (isInset) {\n      controls.push.apply(controls, poses.slice(8).map(function (pos, i) {\n        return React.createElement(\"div\", {\n          key: \"clipRadiusControl\" + i,\n          className: prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"),\n          \"data-clip-index\": 8 + i,\n          style: {\n            transform: \"translate(\" + pos[0] + \"px, \" + pos[1] + \"px) scale(\" + zoom + \")\"\n          }\n        });\n      }));\n    }\n\n    if (type === \"circle\" || type === \"ellipse\") {\n      var clipLeft = clipPath.left,\n          clipTop = clipPath.top,\n          radiusX = clipPath.radiusX,\n          radiusY = clipPath.radiusY;\n\n      var _c = minus(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)),\n          distLeft = _c[0],\n          distTop = _c[1];\n\n      var ellipseClipPath = \"none\";\n\n      if (!clipArea) {\n        var piece = Math.max(10, radiusX / 5, radiusY / 5);\n        var areaPoses = [];\n\n        for (var i = 0; i <= piece; ++i) {\n          var rad = Math.PI * 2 / piece * i;\n          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);\n        }\n\n        areaPoses.push([radiusX, -2]);\n        areaPoses.push([-2, -2]);\n        areaPoses.push([-2, radiusY * 2 + 2]);\n        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);\n        areaPoses.push([radiusX * 2 + 2, -2]);\n        areaPoses.push([radiusX, -2]);\n        ellipseClipPath = \"polygon(\" + areaPoses.map(function (pos) {\n          return pos[0] + \"px \" + pos[1] + \"px\";\n        }).join(\", \") + \")\";\n      }\n\n      controls.push(React.createElement(\"div\", {\n        key: \"clipEllipse\",\n        className: prefix(\"clip-ellipse\", \"snap-control\"),\n        style: {\n          width: radiusX * 2 + \"px\",\n          height: radiusY * 2 + \"px\",\n          clipPath: ellipseClipPath,\n          transform: \"translate(\" + (-left + distLeft) + \"px, \" + (-top + distTop) + \"px) \" + makeMatrixCSS(allMatrix)\n        }\n      }));\n    }\n\n    if (clipArea) {\n      var _d = getRect(__spreadArrays([pos1, pos2, pos3, pos4], poses)),\n          allWidth = _d.width,\n          allHeight = _d.height,\n          allLeft_1 = _d.left,\n          allTop_1 = _d.top;\n\n      if (isPolygon || isRect || isInset) {\n        var areaPoses = isInset ? poses.slice(0, 8) : poses;\n        controls.push(React.createElement(\"div\", {\n          key: \"clipArea\",\n          className: prefix(\"clip-area\", \"snap-control\"),\n          style: {\n            width: allWidth + \"px\",\n            height: allHeight + \"px\",\n            transform: \"translate(\" + allLeft_1 + \"px, \" + allTop_1 + \"px)\",\n            clipPath: \"polygon(\" + areaPoses.map(function (pos) {\n              return pos[0] - allLeft_1 + \"px \" + (pos[1] - allTop_1) + \"px\";\n            }).join(\", \") + \")\"\n          }\n        }));\n      }\n    }\n\n    if (snapBoundInfos) {\n      [\"vertical\", \"horizontal\"].forEach(function (directionType) {\n        var info = snapBoundInfos[directionType];\n        var isHorizontal = directionType === \"horizontal\";\n\n        if (info.isSnap) {\n          lines.push.apply(lines, info.snap.posInfos.map(function (_a, i) {\n            var pos = _a.pos;\n            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n            return renderLine(React, \"\", snapPos1, snapPos2, zoom, \"clip\" + directionType + \"snap\" + i, \"guideline\");\n          }));\n        }\n\n        if (info.isBound) {\n          lines.push.apply(lines, info.bounds.map(function (_a, i) {\n            var pos = _a.pos;\n            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n            return renderLine(React, \"\", snapPos1, snapPos2, zoom, \"clip\" + directionType + \"bounds\" + i, \"guideline\", \"bounds\", \"bold\");\n          }));\n        }\n      });\n    }\n\n    return __spreadArrays(controls, lines);\n  },\n  dragControlCondition: function dragControlCondition(moveable, e) {\n    return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart: function dragStart(moveable, e) {\n    var props = moveable.props;\n    var _a = props.dragWithClip,\n        dragWithClip = _a === void 0 ? true : _a;\n\n    if (dragWithClip) {\n      return false;\n    }\n\n    return this.dragControlStart(moveable, e);\n  },\n  drag: function drag(moveable, e) {\n    return this.dragControl(moveable, e);\n  },\n  dragEnd: function dragEnd(moveable, e) {\n    return this.dragControlEnd(moveable, e);\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    var state = moveable.state;\n    var _a = moveable.props,\n        defaultClipPath = _a.defaultClipPath,\n        customClipPath = _a.customClipPath;\n    var target = state.target,\n        width = state.width,\n        height = state.height;\n    var inputTarget = e.inputEvent ? e.inputEvent.target : null;\n    var className = inputTarget ? inputTarget.getAttribute(\"class\") : \"\";\n    var datas = e.datas;\n    var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", customClipPath);\n\n    if (!clipPath) {\n      return false;\n    }\n\n    var clipText = clipPath.clipText,\n        type = clipPath.type,\n        poses = clipPath.poses;\n    var result = triggerEvent(moveable, \"onClipStart\", fillParams(moveable, e, {\n      clipType: type,\n      clipStyle: clipText,\n      poses: poses.map(function (pos) {\n        return pos.pos;\n      })\n    }));\n\n    if (result === false) {\n      datas.isClipStart = false;\n      return false;\n    }\n\n    datas.isControl = className.indexOf(\"clip-control\") > -1;\n    datas.isLine = className.indexOf(\"clip-line\") > -1;\n    datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n    datas.index = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n    datas.clipPath = clipPath;\n    datas.isClipStart = true;\n    state.clipPathState = clipText;\n    setDragStart(moveable, e);\n    return true;\n  },\n  dragControl: function dragControl(moveable, e) {\n    var datas = e.datas,\n        originalDatas = e.originalDatas;\n\n    if (!datas.isClipStart) {\n      return false;\n    }\n\n    var draggableData = originalDatas && originalDatas.draggable || {};\n    var _a = datas,\n        isControl = _a.isControl,\n        isLine = _a.isLine,\n        isArea = _a.isArea,\n        index = _a.index,\n        clipPath = _a.clipPath;\n\n    if (!clipPath) {\n      return false;\n    }\n\n    var _b = draggableData.isDrag ? draggableData.prevDist : getDragDist(e),\n        distX = _b[0],\n        distY = _b[1];\n\n    var props = moveable.props;\n    var state = moveable.state;\n    var width = state.width,\n        height = state.height;\n    var isDragWithTarget = !isArea && !isControl && !isLine;\n    var clipType = clipPath.type,\n        clipPoses = clipPath.poses,\n        splitter = clipPath.splitter;\n    var poses = clipPoses.map(function (pos) {\n      return pos.pos;\n    });\n\n    if (isDragWithTarget) {\n      distX = -distX;\n      distY = -distY;\n    }\n\n    var isAll = !isControl || clipPoses[index].direction === \"nesw\";\n    var isRect = clipType === \"inset\" || clipType === \"rect\";\n    var dists = clipPoses.map(function () {\n      return [0, 0];\n    });\n\n    if (isControl && !isAll) {\n      var _c = clipPoses[index],\n          horizontal = _c.horizontal,\n          vertical = _c.vertical;\n      var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];\n      dists = moveControlPos(clipPoses, index, dist, isRect);\n    } else if (isAll) {\n      dists = poses.map(function () {\n        return [distX, distY];\n      });\n    }\n\n    var nextPoses = poses.map(function (pos, i) {\n      return plus(pos, dists[i]);\n    });\n\n    var guidePoses = __spreadArrays(nextPoses);\n\n    state.snapBoundInfos = null;\n    var isCircle = clipPath.type === \"circle\";\n    var isEllipse = clipPath.type === \"ellipse\";\n\n    if (isCircle || isEllipse) {\n      var guideRect = getRect(nextPoses);\n      var ry = Math.abs(guideRect.bottom - guideRect.top);\n      var rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);\n      var bottom = nextPoses[0][1] + ry;\n      var left = nextPoses[0][0] - rx;\n      var right = nextPoses[0][0] + rx; // right\n\n      if (isCircle) {\n        guidePoses.push([right, guideRect.bottom]);\n        dists.push([1, 0]);\n      } // bottom\n\n\n      guidePoses.push([guideRect.left, bottom]);\n      dists.push([0, 1]); // left\n\n      guidePoses.push([left, guideRect.bottom]);\n      dists.push([1, 0]);\n    }\n\n    var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function (v) {\n      return convertUnitSize(\"\" + v, height);\n    }), (props.clipVerticalGuidelines || []).map(function (v) {\n      return convertUnitSize(\"\" + v, width);\n    }), width, height);\n    var guideXPoses = [];\n    var guideYPoses = [];\n\n    if (isCircle || isEllipse) {\n      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n    } else if (isRect) {\n      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n      var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];\n      guideXPoses = rectPoses.filter(function (_, i) {\n        return rectDists_1[i][0];\n      }).map(function (pos) {\n        return pos[0];\n      });\n      guideYPoses = rectPoses.filter(function (_, i) {\n        return rectDists_1[i][1];\n      }).map(function (pos) {\n        return pos[1];\n      });\n    } else {\n      guideXPoses = guidePoses.filter(function (_, i) {\n        return dists[i][0];\n      }).map(function (pos) {\n        return pos[0];\n      });\n      guideYPoses = guidePoses.filter(function (_, i) {\n        return dists[i][1];\n      }).map(function (pos) {\n        return pos[1];\n      });\n    }\n\n    var _loop_1 = function _loop_1(i) {\n      var _a = checkSnapBounds(guidelines, props.clipTargetBounds && {\n        left: 0,\n        top: 0,\n        right: width,\n        bottom: height\n      }, guideXPoses, guideYPoses, {\n        snapThreshold: 5\n      }),\n          horizontalSnapInfo = _a.horizontal,\n          verticalSnapInfo = _a.vertical;\n\n      var snapOffsetY = horizontalSnapInfo.offset;\n      var snapOffsetX = verticalSnapInfo.offset;\n\n      if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n        var guideRect = getRect(nextPoses);\n        var cy = guideRect.bottom - guideRect.top;\n        var cx = isEllipse ? guideRect.right - guideRect.left : cy;\n        var distSnapX = verticalSnapInfo.isBound ? Math.abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;\n        var distSnapY = horizontalSnapInfo.isBound ? Math.abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;\n        cx -= distSnapX;\n        cy -= distSnapY;\n\n        if (isCircle) {\n          cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;\n          cx = cy;\n        }\n\n        var center = guidePoses[0];\n        guidePoses[1][1] = center[1] - cy;\n        guidePoses[2][0] = center[0] + cx;\n        guidePoses[3][1] = center[1] + cy;\n        guidePoses[4][0] = center[0] - cx;\n      } else {\n        guidePoses.forEach(function (pos, j) {\n          var dist = dists[j];\n\n          if (dist[0]) {\n            pos[0] -= snapOffsetX;\n          }\n\n          if (dist[1]) {\n            pos[1] -= snapOffsetY;\n          }\n        });\n        return \"break\";\n      }\n    };\n\n    for (var i = 0; i < 2; ++i) {\n      var state_1 = _loop_1();\n\n      if (state_1 === \"break\") break;\n    }\n\n    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);\n    var clipStyle = clipType + \"(\" + nextClipStyles.join(splitter) + \")\";\n    state.clipPathState = clipStyle;\n\n    if (isCircle || isEllipse) {\n      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n    } else if (isRect) {\n      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n      guideXPoses = rectPoses.map(function (pos) {\n        return pos[0];\n      });\n      guideYPoses = rectPoses.map(function (pos) {\n        return pos[1];\n      });\n    } else {\n      guideXPoses = guidePoses.map(function (pos) {\n        return pos[0];\n      });\n      guideYPoses = guidePoses.map(function (pos) {\n        return pos[1];\n      });\n    }\n\n    state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    }, guideXPoses, guideYPoses, {\n      snapThreshold: 1\n    });\n    triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n      clipEventType: \"changed\",\n      clipType: clipType,\n      poses: nextPoses,\n      clipStyle: clipStyle,\n      clipStyles: nextClipStyles,\n      distX: distX,\n      distY: distY\n    }));\n    return true;\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    this.unset(moveable);\n    var isDrag = e.isDrag,\n        datas = e.datas,\n        isDouble = e.isDouble;\n    var isLine = datas.isLine,\n        isClipStart = datas.isClipStart,\n        isControl = datas.isControl;\n\n    if (!isClipStart) {\n      return false;\n    }\n\n    triggerEvent(moveable, \"onClipEnd\", fillEndParams(moveable, e, {}));\n\n    if (isDouble) {\n      if (isControl) {\n        removeClipPath(moveable, e);\n      } else if (isLine) {\n        // add\n        addClipPath(moveable, e);\n      }\n    }\n\n    return isDouble || isDrag;\n  },\n  unset: function unset(moveable) {\n    moveable.state.clipPathState = \"\";\n    moveable.state.snapBoundInfos = null;\n  }\n};\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea. (default: false)\n * @name Moveable.Clippable#clipArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n* Whether the clip is bound to the target. (default: false)\n* @name Moveable.Clippable#clipTargetBounds\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipTargetBounds: true,\n* });\n* moveable.on(\"clipStart\", e => {\n*     console.log(e);\n* }).on(\"clip\", e => {\n*     if (e.clipType === \"rect\") {\n*         e.target.style.clip = e.clipStyle;\n*     } else {\n*         e.target.style.clipPath = e.clipStyle;\n*     }\n* }).on(\"clipEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* Add clip guidelines in the vertical direction. (default: [])\n* @name Moveable.Clippable#clipVerticalGuidelines\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n\n/**\n* Add clip guidelines in the horizontal direction. (default: [])\n* @name Moveable.Clippable#clipHorizontalGuidelines\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n\n/**\n* istance value that can snap to clip guidelines. (default: 5)\n* @name Moveable.Clippable#clipSnapThreshold\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\n\nvar OriginDraggable = {\n  name: \"originDraggable\",\n  props: {\n    originDraggable: Boolean,\n    originRelative: Boolean\n  },\n  events: {\n    onDragOriginStart: \"dragOriginStart\",\n    onDragOrigin: \"dragOrigin\",\n    onDragOriginEnd: \"dragOriginEnd\"\n  },\n  css: [\":host[data-able-origindraggable] .control.origin {\\n    pointer-events: auto;\\n}\"],\n  dragControlCondition: function dragControlCondition(_, e) {\n    if (e.isRequest) {\n      return e.requestAble === \"originDraggable\";\n    }\n\n    return hasClass(e.inputEvent.target, prefix(\"origin\"));\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    var datas = e.datas;\n    setDragStart(moveable, e);\n    var params = fillParams(moveable, e, {\n      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))\n    });\n    var result = triggerEvent(moveable, \"onDragOriginStart\", params);\n    datas.startOrigin = moveable.state.transformOrigin;\n    datas.startTargetOrigin = moveable.state.targetOrigin;\n    datas.prevOrigin = [0, 0];\n    datas.isDragOrigin = true;\n\n    if (result === false) {\n      datas.isDragOrigin = false;\n      return false;\n    }\n\n    return params;\n  },\n  dragControl: function dragControl(moveable, e) {\n    var datas = e.datas,\n        isPinch = e.isPinch,\n        isRequest = e.isRequest;\n\n    if (!datas.isDragOrigin) {\n      return false;\n    }\n\n    var _a = getDragDist(e),\n        distX = _a[0],\n        distY = _a[1];\n\n    var state = moveable.state;\n    var width = state.width,\n        height = state.height,\n        offsetMatrix = state.offsetMatrix,\n        targetMatrix = state.targetMatrix,\n        is3d = state.is3d;\n    var _b = moveable.props.originRelative,\n        originRelative = _b === void 0 ? true : _b;\n    var n = is3d ? 4 : 3;\n    var dist = [distX, distY];\n\n    if (isRequest) {\n      var distOrigin = e.distOrigin;\n\n      if (distOrigin[0] || distOrigin[1]) {\n        dist = distOrigin;\n      }\n    }\n\n    var origin = plus(datas.startOrigin, dist);\n    var targetOrigin = plus(datas.startTargetOrigin, dist);\n    var delta = minus(dist, datas.prevOrigin);\n    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);\n    var rect = moveable.getRect();\n    var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];\n    datas.prevOrigin = dist;\n    var transformOrigin = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(\" \");\n    var params = fillParams(moveable, e, {\n      width: width,\n      height: height,\n      origin: origin,\n      dist: dist,\n      delta: delta,\n      transformOrigin: transformOrigin,\n      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false))\n    });\n    triggerEvent(moveable, \"onDragOrigin\", params);\n    return params;\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isDragOrigin) {\n      return false;\n    }\n\n    triggerEvent(moveable, \"onDragOriginEnd\", fillEndParams(moveable, e, {}));\n    return true;\n  },\n  dragGroupControlCondition: function dragGroupControlCondition(moveable, e) {\n    return this.dragControlCondition(moveable, e);\n  },\n  dragGroupControlStart: function dragGroupControlStart(moveable, e) {\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    return true;\n  },\n  dragGroupControl: function dragGroupControl(moveable, e) {\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    moveable.transformOrigin = params.transformOrigin;\n    return true;\n  },\n\n  /**\n  * @method Moveable.OriginDraggable#request\n  * @param {object} e - the OriginDraggable's request parameter\n  * @param {number} [e.x] - x position\n  * @param {number} [e.y] - y position\n  * @param {number} [e.deltaX] - x number to move\n  * @param {number} [e.deltaY] - y number to move\n  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n  * @param {array} [e.origin] - transform-origin position\n  * @param {number} [e.isInstant] - Whether to execute the request instantly\n  * @return {Moveable.Requester} Moveable Requester\n  * @example\n   * // Instantly Request (requestStart - request - requestEnd)\n  * // Use Relative Value\n  * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n  * // Use Absolute Value\n  * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n  * // Use Transform Value\n  * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n  * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n  * // requestStart\n  * const requester = moveable.request(\"originDraggable\");\n  *\n  * // request\n  * // Use Relative Value\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * // Use Absolute Value\n  * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n  * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n  * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n  *\n  * // requestEnd\n  * requester.requestEnd();\n  */\n  request: function request(moveable) {\n    var datas = {};\n    var rect = moveable.getRect();\n    var distX = 0;\n    var distY = 0;\n    var transformOrigin = rect.transformOrigin;\n    var distOrigin = [0, 0];\n    return {\n      isControl: true,\n      requestStart: function requestStart() {\n        return {\n          datas: datas\n        };\n      },\n      request: function request(e) {\n        if (\"deltaOrigin\" in e) {\n          distOrigin[0] += e.deltaOrigin[0];\n          distOrigin[1] += e.deltaOrigin[1];\n        } else if (\"origin\" in e) {\n          distOrigin[0] = e.origin[0] - transformOrigin[0];\n          distOrigin[1] = e.origin[1] - transformOrigin[1];\n        } else {\n          if (\"x\" in e) {\n            distX = e.x - rect.left;\n          } else if (\"deltaX\" in e) {\n            distX += e.deltaX;\n          }\n\n          if (\"y\" in e) {\n            distY = e.y - rect.top;\n          } else if (\"deltaY\" in e) {\n            distY += e.deltaY;\n          }\n        }\n\n        return {\n          datas: datas,\n          distX: distX,\n          distY: distY,\n          distOrigin: distOrigin\n        };\n      },\n      requestEnd: function requestEnd() {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\nfunction addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {\n  var _a = splitRadiusPoses(controlPoses),\n      horizontals = _a.horizontals,\n      verticals = _a.verticals;\n\n  var horizontalsLength = horizontals.length;\n  var verticalsLength = verticals.length; // lineIndex\n  // 0 top\n  // 1 right\n  // 2 left\n  // 3 bottom\n  // 0 top - left\n  // 1 top - right\n  // 2 bottom - right\n  // 3 bottom - left\n  // 0 left - top\n  // 1 right - top\n  // 2 right - bottom\n  // 3 left - bottom\n\n  var horizontalIndex = -1;\n  var verticalIndex = -1;\n\n  if (lineIndex === 0) {\n    if (horizontalsLength === 0) {\n      horizontalIndex = 0;\n    } else if (horizontalsLength === 1) {\n      horizontalIndex = 1;\n    }\n  } else if (lineIndex === 3) {\n    if (horizontalsLength <= 2) {\n      horizontalIndex = 2;\n    } else if (horizontalsLength <= 3) {\n      horizontalIndex = 3;\n    }\n  }\n\n  if (lineIndex === 2) {\n    if (verticalsLength === 0) {\n      verticalIndex = 0;\n    } else if (verticalsLength < 4) {\n      verticalIndex = 3;\n    }\n  } else if (lineIndex === 1) {\n    if (verticalsLength <= 1) {\n      verticalIndex = 1;\n    } else if (verticalsLength <= 2) {\n      verticalIndex = 2;\n    }\n  }\n\n  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);\n}\n\nfunction getBorderRadius(target, width, height, minCounts, state) {\n  if (minCounts === void 0) {\n    minCounts = [0, 0];\n  }\n\n  var borderRadius;\n  var values = [];\n\n  if (!state) {\n    var style = getComputedStyle(target);\n    borderRadius = style && style.borderRadius || \"\";\n  } else {\n    borderRadius = state;\n  }\n\n  if (!borderRadius || !state && borderRadius === \"0px\") {\n    values = [];\n  } else {\n    values = splitSpace(borderRadius);\n  }\n\n  return getRadiusValues(values, width, height, 0, 0, minCounts);\n}\n\nfunction triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses) {\n  var state = moveable.state;\n  var width = state.width,\n      height = state.height;\n\n  var _a = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height),\n      raws = _a.raws,\n      styles = _a.styles;\n\n  var _b = splitRadiusPoses(controlPoses, raws),\n      horizontals = _b.horizontals,\n      verticals = _b.verticals;\n\n  var borderRadius = styles.join(\" \");\n  state.borderRadiusState = borderRadius;\n  triggerEvent(moveable, \"onRound\", fillParams(moveable, e, {\n    horizontals: horizontals,\n    verticals: verticals,\n    borderRadius: borderRadius,\n    width: width,\n    height: height,\n    delta: delta,\n    dist: dist\n  }));\n}\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\n\nvar Roundable = {\n  name: \"roundable\",\n  props: {\n    roundable: Boolean,\n    roundRelative: Boolean,\n    minRoundControls: Array,\n    maxRoundControls: Array,\n    roundClickable: Boolean\n  },\n  events: {\n    onRoundStart: \"roundStart\",\n    onRound: \"round\",\n    onRoundEnd: \"roundEnd\"\n  },\n  css: [\".control.border-radius {\\n    background: #d66;\\n    cursor: pointer;\\n}\", \":host[data-able-roundable] .line.direction {\\n    cursor: pointer;\\n}\"],\n  render: function render(moveable, React) {\n    var _a = moveable.state,\n        target = _a.target,\n        width = _a.width,\n        height = _a.height,\n        allMatrix = _a.allMatrix,\n        is3d = _a.is3d,\n        left = _a.left,\n        top = _a.top,\n        borderRadiusState = _a.borderRadiusState;\n    var _b = moveable.props,\n        _c = _b.minRoundControls,\n        minRoundControls = _c === void 0 ? [0, 0] : _c,\n        _d = _b.maxRoundControls,\n        maxRoundControls = _d === void 0 ? [4, 4] : _d,\n        zoom = _b.zoom;\n\n    if (!target) {\n      return null;\n    }\n\n    var n = is3d ? 4 : 3;\n    var radiusValues = getBorderRadius(target, width, height, minRoundControls, borderRadiusState);\n\n    if (!radiusValues) {\n      return null;\n    }\n\n    var verticalCount = 0;\n    var horizontalCount = 0;\n    return radiusValues.map(function (v, i) {\n      horizontalCount += Math.abs(v.horizontal);\n      verticalCount += Math.abs(v.vertical);\n      var pos = minus(calculatePosition(allMatrix, v.pos, n), [left, top]);\n      var isDisplay = v.vertical ? verticalCount <= maxRoundControls[1] : horizontalCount <= maxRoundControls[0];\n      return React.createElement(\"div\", {\n        key: \"borderRadiusControl\" + i,\n        className: prefix(\"control\", \"border-radius\"),\n        \"data-radius-index\": i,\n        style: {\n          display: isDisplay ? \"block\" : \"none\",\n          transform: \"translate(\" + pos[0] + \"px, \" + pos[1] + \"px) scale(\" + zoom + \")\"\n        }\n      });\n    });\n  },\n  dragControlCondition: function dragControlCondition(moveable, e) {\n    if (!e.inputEvent || e.isRequest) {\n      return false;\n    }\n\n    var className = e.inputEvent.target.getAttribute(\"class\") || \"\";\n    return className.indexOf(\"border-radius\") > -1 || className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    var inputEvent = e.inputEvent,\n        datas = e.datas;\n    var inputTarget = inputEvent.target;\n    var className = inputTarget.getAttribute(\"class\") || \"\";\n    var isControl = className.indexOf(\"border-radius\") > -1;\n    var isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n    var controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n    var lineIndex = isLine ? parseInt(inputTarget.getAttribute(\"data-line-index\"), 10) : -1;\n\n    if (!isControl && !isLine) {\n      return false;\n    }\n\n    var result = triggerEvent(moveable, \"onRoundStart\", fillParams(moveable, e, {}));\n\n    if (result === false) {\n      return false;\n    }\n\n    datas.lineIndex = lineIndex;\n    datas.controlIndex = controlIndex;\n    datas.isControl = isControl;\n    datas.isLine = isLine;\n    setDragStart(moveable, e);\n    var _a = moveable.props,\n        roundRelative = _a.roundRelative,\n        _b = _a.minRoundControls,\n        minRoundControls = _b === void 0 ? [0, 0] : _b;\n    var state = moveable.state;\n    var target = state.target,\n        width = state.width,\n        height = state.height;\n    datas.isRound = true;\n    datas.prevDist = [0, 0];\n    var controlPoses = getBorderRadius(target, width, height, minRoundControls) || [];\n    datas.controlPoses = controlPoses;\n    state.borderRadiusState = getRadiusStyles(controlPoses.map(function (pos) {\n      return pos.pos;\n    }), controlPoses, roundRelative, width, height).styles.join(\" \");\n    return true;\n  },\n  dragControl: function dragControl(moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {\n      return false;\n    }\n\n    var index = datas.controlIndex;\n    var controlPoses = datas.controlPoses;\n\n    var _a = getDragDist(e),\n        distX = _a[0],\n        distY = _a[1];\n\n    var dist = [distX, distY];\n    var delta = minus(dist, datas.prevDist);\n    var _b = moveable.props.maxRoundControls,\n        maxRoundControls = _b === void 0 ? [4, 4] : _b;\n    var _c = moveable.state,\n        width = _c.width,\n        height = _c.height;\n    var selectedControlPose = controlPoses[index];\n    var selectedVertical = selectedControlPose.vertical;\n    var selectedHorizontal = selectedControlPose.horizontal; // 0: [0, 1, 2, 3] maxCount === 1\n    // 0: [0, 2] maxCount === 2\n    // 1: [1, 3] maxCount === 2\n    // 0: [0] maxCount === 3\n    // 1: [1, 3] maxCount === 3\n\n    var dists = controlPoses.map(function (pose) {\n      var horizontal = pose.horizontal,\n          vertical = pose.vertical;\n      var poseDist = [horizontal * selectedHorizontal * dist[0], vertical * selectedVertical * dist[1]];\n\n      if (horizontal) {\n        if (maxRoundControls[0] === 1) {\n          return poseDist;\n        } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\n          return poseDist;\n        }\n      } else if (maxRoundControls[1] === 0) {\n        poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\n        return poseDist;\n      } else if (selectedVertical) {\n        if (maxRoundControls[1] === 1) {\n          return poseDist;\n        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n          return poseDist;\n        }\n      }\n\n      return [0, 0];\n    });\n    dists[index] = dist;\n    var nextPoses = controlPoses.map(function (pos, i) {\n      return plus(pos.pos, dists[i]);\n    });\n    datas.prevDist = [distX, distY];\n    triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses);\n    return true;\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    var state = moveable.state;\n    state.borderRadiusState = \"\";\n    var datas = e.datas,\n        isDouble = e.isDouble;\n\n    if (!datas.isRound) {\n      return false;\n    }\n\n    var width = state.width,\n        height = state.height;\n    var isControl = datas.isControl,\n        controlIndex = datas.controlIndex,\n        isLine = datas.isLine,\n        lineIndex = datas.lineIndex;\n    var controlPoses = datas.controlPoses;\n    var poses = controlPoses.map(function (pos) {\n      return pos.pos;\n    });\n    var length = poses.length;\n    var _a = moveable.props.roundClickable,\n        roundClickable = _a === void 0 ? true : _a;\n\n    if (isDouble && roundClickable) {\n      if (isControl) {\n        removeRadiusPos(controlPoses, poses, controlIndex, 0);\n      } else if (isLine) {\n        var _b = calculatePointerDist(moveable, e),\n            distX = _b[0],\n            distY = _b[1];\n\n        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);\n      }\n\n      if (length !== controlPoses.length) {\n        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses, poses);\n      }\n    }\n\n    triggerEvent(moveable, \"onRoundEnd\", fillEndParams(moveable, e, {}));\n    state.borderRadiusState = \"\";\n    return true;\n  },\n  unset: function unset(moveable) {\n    moveable.state.borderRadiusState = \"\";\n  }\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\n * @name Moveable.Roundable#minRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     minRoundControls: [0, 0],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n\n/**\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\n * @name Moveable.Roundable#maxRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     maxRoundControls: [4, 4],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n\n/**\n * @property - Whether you can add/delete round controls by double-clicking a line or control. (default: true)\n * @name Moveable.Roundable#roundClickable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     roundClickable: true,\n * });\n * moveable.roundClickable = false;\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\nvar BeforeRenderable = {\n  isPinch: true,\n  name: \"beforeRenderable\",\n  props: {},\n  events: {\n    onBeforeRenderStart: \"beforeRenderStart\",\n    onBeforeRender: \"beforeRender\",\n    onBeforeRenderEnd: \"beforeRenderEnd\",\n    onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n    onBeforeRenderGroup: \"beforeRenderGroup\",\n    onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\"\n  },\n  setTransform: function setTransform(moveable, e) {\n    var _a = moveable.state,\n        is3d = _a.is3d,\n        target = _a.target,\n        targetMatrix = _a.targetMatrix;\n    var transform = target === null || target === void 0 ? void 0 : target.style.transform;\n    var cssMatrix = is3d ? \"matrix3d(\" + targetMatrix.join(\",\") + \")\" : \"matrix(\" + convertMatrixtoCSS(targetMatrix, true) + \")\";\n    e.datas.startTransforms = !transform || transform === \"none\" ? [cssMatrix] : splitSpace(transform);\n  },\n  resetTransform: function resetTransform(moveable, e) {\n    e.datas.nextTransforms = e.datas.startTransforms;\n    e.datas.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams: function fillDragStartParams(moveable, e) {\n    return fillParams(moveable, e, {\n      setTransform: function setTransform(transform) {\n        e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n      },\n      isPinch: !!e.isPinch\n    });\n  },\n  fillDragParams: function fillDragParams(moveable, e) {\n    return fillParams(moveable, e, {\n      isPinch: !!e.isPinch\n    });\n  },\n  dragStart: function dragStart(moveable, e) {\n    this.setTransform(moveable, e);\n    triggerEvent(moveable, \"onBeforeRenderStart\", this.fillDragStartParams(moveable, e));\n  },\n  drag: function drag(moveable, e) {\n    this.resetTransform(moveable, e);\n    triggerEvent(moveable, \"onBeforeRender\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch\n    }));\n  },\n  dragEnd: function dragEnd(moveable, e) {\n    triggerEvent(moveable, \"onBeforeRenderEnd\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag\n    }));\n  },\n  dragGroupStart: function dragGroupStart(moveable, e) {\n    var _this = this;\n\n    this.dragStart(moveable, e);\n    var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    var moveables = moveable.moveables;\n    var params = events.map(function (childEvent, i) {\n      var childMoveable = moveables[i];\n\n      _this.setTransform(childMoveable, childEvent);\n\n      return _this.fillDragStartParams(childMoveable, childEvent);\n    });\n    triggerEvent(moveable, \"onBeforeRenderGroupStart\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      targets: moveable.props.targets,\n      setTransform: function setTransform() {},\n      events: params\n    }));\n  },\n  dragGroup: function dragGroup(moveable, e) {\n    var _this = this;\n\n    this.drag(moveable, e);\n    var events = fillChildEvents(moveable, \"beforeRenderable\", e);\n    var moveables = moveable.moveables;\n    var params = events.map(function (childEvent, i) {\n      var childMoveable = moveables[i];\n\n      _this.resetTransform(childMoveable, childEvent);\n\n      return _this.fillDragParams(childMoveable, childEvent);\n    });\n    triggerEvent(moveable, \"onBeforeRenderGroup\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      targets: moveable.props.targets,\n      events: params\n    }));\n  },\n  dragGroupEnd: function dragGroupEnd(moveable, e) {\n    this.dragEnd(moveable, e);\n    triggerEvent(moveable, \"onBeforeRenderGroupEnd\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag,\n      targets: moveable.props.targets\n    }));\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragControl: function dragControl(moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupControlStart: function dragGroupControlStart(moveable, e) {\n    return this.dragGroupStart(moveable, e);\n  },\n  dragGroupControl: function dragGroupControl(moveable, e) {\n    return this.dragGroup(moveable, e);\n  },\n  dragGroupControlEnd: function dragGroupControlEnd(moveable, e) {\n    return this.dragGroupEnd(moveable, e);\n  }\n};\nvar Renderable = {\n  name: \"renderable\",\n  props: {},\n  events: {\n    onRenderStart: \"renderStart\",\n    onRender: \"render\",\n    onRenderEnd: \"renderEnd\",\n    onRenderGroupStart: \"renderGroupStart\",\n    onRenderGroup: \"renderGroup\",\n    onRenderGroupEnd: \"renderGroupEnd\"\n  },\n  dragStart: function dragStart(moveable, e) {\n    triggerEvent(moveable, \"onRenderStart\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch\n    }));\n  },\n  drag: function drag(moveable, e) {\n    triggerEvent(moveable, \"onRender\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch\n    }));\n  },\n  dragEnd: function dragEnd(moveable, e) {\n    triggerEvent(moveable, \"onRenderEnd\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag\n    }));\n  },\n  dragGroupStart: function dragGroupStart(moveable, e) {\n    triggerEvent(moveable, \"onRenderGroupStart\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroup: function dragGroup(moveable, e) {\n    triggerEvent(moveable, \"onRenderGroup\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupEnd: function dragGroupEnd(moveable, e) {\n    triggerEvent(moveable, \"onRenderGroupEnd\", fillParams(moveable, e, {\n      isPinch: !!e.isPinch,\n      isDrag: e.isDrag,\n      targets: moveable.props.targets\n    }));\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragControl: function dragControl(moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupControlStart: function dragGroupControlStart(moveable, e) {\n    return this.dragGroupStart(moveable, e);\n  },\n  dragGroupControl: function dragGroupControl(moveable, e) {\n    return this.dragGroup(moveable, e);\n  },\n  dragGroupControlEnd: function dragGroupControlEnd(moveable, e) {\n    return this.dragGroupEnd(moveable, e);\n  }\n};\n\nfunction triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, requestInstant) {\n  var isStart = eventType === \"Start\";\n  var target = moveable.state.target;\n  var isRequest = e.isRequest;\n\n  if (!target || isStart && eventAffix.indexOf(\"Control\") > -1 && !isRequest && moveable.areaElement === e.inputEvent.target) {\n    return false;\n  }\n\n  var eventName = \"\" + eventOperation + eventAffix + eventType;\n  var conditionName = \"\" + eventOperation + eventAffix + \"Condition\";\n  var isEnd = eventType === \"End\";\n  var isAfter = eventType.indexOf(\"After\") > -1;\n  var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());\n\n  if (isFirstStart) {\n    moveable.updateRect(eventType, true, false);\n  }\n\n  if (eventType === \"\" && !isAfter && !isRequest) {\n    convertDragDist(moveable.state, e);\n  } // const isGroup = eventAffix.indexOf(\"Group\") > -1;\n\n\n  var ables = __spreadArrays([BeforeRenderable], moveable[ableType].slice(), [Renderable]);\n\n  if (isRequest) {\n    var requestAble_1 = e.requestAble;\n\n    if (!ables.some(function (able) {\n      return able.name === requestAble_1;\n    })) {\n      ables.push.apply(ables, moveable.props.ables.filter(function (able) {\n        return able.name === requestAble_1;\n      }));\n    }\n  }\n\n  if (!ables.length) {\n    return false;\n  }\n\n  var events = ables.filter(function (able) {\n    return able[eventName];\n  });\n  var datas = e.datas;\n\n  if (isFirstStart) {\n    events.forEach(function (able) {\n      able.unset && able.unset(moveable);\n    });\n  }\n\n  var inputEvent = e.inputEvent;\n  var inputTarget;\n\n  if (isEnd && inputEvent) {\n    inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n  }\n\n  var results = events.filter(function (able) {\n    var ableName = able.name;\n    var nextDatas = datas[ableName] || (datas[ableName] = {});\n\n    if (isStart) {\n      nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);\n    }\n\n    if (nextDatas.isEventStart) {\n      return able[eventName](moveable, _assign(_assign({}, e), {\n        datas: nextDatas,\n        originalDatas: datas,\n        inputTarget: inputTarget\n      }));\n    }\n\n    return false;\n  });\n  var isUpdate = results.length;\n  var isForceEnd = isStart && events.length && !isUpdate;\n\n  if (isEnd || isForceEnd) {\n    moveable.state.gesto = null;\n\n    if (moveable.moveables) {\n      moveable.moveables.forEach(function (childMoveable) {\n        childMoveable.state.gesto = null;\n      });\n    }\n  }\n\n  if (isFirstStart && isForceEnd) {\n    events.forEach(function (able) {\n      able.unset && able.unset(moveable);\n    });\n  }\n\n  if (moveable.isUnmounted || isForceEnd) {\n    return false;\n  }\n\n  if (!isStart && isUpdate && !requestInstant || isEnd) {\n    moveable.updateRect(eventType, true, false);\n    moveable.forceUpdate();\n  }\n\n  if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {\n    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n  }\n\n  return true;\n}\n\nfunction getTargetAbleGesto(moveable, moveableTarget, eventAffix) {\n  var controlBox = moveable.controlBox.getElement();\n  var targets = [];\n  targets.push(controlBox);\n\n  if (!moveable.props.dragArea || moveable.props.dragTarget) {\n    targets.push(moveableTarget);\n  }\n\n  var startFunc = function startFunc(e) {\n    var eventTarget = e.inputEvent.target;\n    var areaElement = moveable.areaElement;\n    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) || hasClass(eventTarget, \"moveable-area\") || hasClass(eventTarget, \"moveable-padding\");\n  };\n\n  return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n    dragStart: startFunc,\n    pinchStart: startFunc\n  });\n}\n\nfunction getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {\n  if (conditionFunctions === void 0) {\n    conditionFunctions = {};\n  }\n\n  var _a = moveable.props,\n      pinchOutside = _a.pinchOutside,\n      pinchThreshold = _a.pinchThreshold;\n  var options = {\n    container: window,\n    pinchThreshold: pinchThreshold,\n    pinchOutside: pinchOutside\n  };\n  var gesto = new Gesto(target, options);\n  [\"drag\", \"pinch\"].forEach(function (eventOperation) {\n    [\"Start\", \"\", \"End\"].forEach(function (eventType) {\n      gesto.on(\"\" + eventOperation + eventType, function (e) {\n        var eventName = e.eventType;\n\n        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n          e.stop();\n          return;\n        }\n\n        var result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n\n        if (!result) {\n          e.stop();\n        }\n      });\n    });\n  });\n  return gesto;\n}\n\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager(target, moveable, eventName) {\n    var _this = this;\n\n    this.target = target;\n    this.moveable = moveable;\n    this.eventName = eventName;\n    this.ables = [];\n\n    this.onEvent = function (e) {\n      var eventName = _this.eventName;\n      var moveable = _this.moveable;\n\n      if (moveable.state.disableNativeEvent) {\n        return;\n      }\n\n      _this.ables.forEach(function (able) {\n        able[eventName](moveable, {\n          inputEvent: e\n        });\n      });\n    };\n\n    this.target.addEventListener(this.eventName.toLowerCase(), this.onEvent);\n  }\n\n  var __proto = EventManager.prototype;\n\n  __proto.setAbles = function (ables) {\n    this.ables = ables;\n  };\n\n  __proto.destroy = function () {\n    this.target.removeEventListener(this.eventName.toLowerCase(), this.onEvent);\n    this.target = null;\n    this.moveable = null;\n  };\n\n  return EventManager;\n}();\n\nvar MoveableManager = /*#__PURE__*/function (_super) {\n  __extends(MoveableManager, _super);\n\n  function MoveableManager() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = _assign({\n      container: null,\n      target: null,\n      gesto: null,\n      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      disableNativeEvent: false\n    }, getTargetInfo(null));\n    _this.enabledAbles = [];\n    _this.targetAbles = [];\n    _this.controlAbles = [];\n    _this.rotation = 0;\n    _this.scale = [1, 1];\n    _this.isUnmounted = false;\n    _this.events = {\n      \"mouseEnter\": null,\n      \"mouseLeave\": null\n    };\n\n    _this.onPreventClick = function (e) {\n      e.stopPropagation();\n      removeEvent(window, \"click\", _this.onPreventClick, true);\n    };\n\n    return _this;\n  }\n\n  var __proto = MoveableManager.prototype;\n\n  __proto.render = function () {\n    var props = this.props;\n    var state = this.state;\n    var edge = props.edge,\n        parentPosition = props.parentPosition,\n        className = props.className,\n        propsTarget = props.target,\n        zoom = props.zoom,\n        cspNonce = props.cspNonce,\n        translateZ = props.translateZ,\n        ControlBoxElement = props.cssStyled,\n        portalContainer = props.portalContainer;\n    this.checkUpdate();\n    this.updateRenderPoses();\n\n    var _a = parentPosition || {\n      left: 0,\n      top: 0\n    },\n        parentLeft = _a.left,\n        parentTop = _a.top;\n\n    var left = state.left,\n        top = state.top,\n        stateTarget = state.target,\n        direction = state.direction,\n        renderPoses = state.renderPoses;\n    var groupTargets = props.targets;\n    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;\n    var isDragging = this.isDragging();\n    var ableAttributes = {};\n    var Renderer = {\n      createElement: createElement\n    };\n    this.getEnabledAbles().forEach(function (able) {\n      ableAttributes[\"data-able-\" + able.name.toLowerCase()] = true;\n    });\n    return createElement(ControlBoxElement, _assign({\n      cspNonce: cspNonce,\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\") + \" \" + className\n    }, ableAttributes, {\n      onClick: this.onPreventClick,\n      portalContainer: portalContainer,\n      style: {\n        \"position\": \"absolute\",\n        \"display\": isDisplay ? \"block\" : \"none\",\n        \"transform\": \"translate3d(\" + (left - parentLeft) + \"px, \" + (top - parentTop) + \"px, \" + translateZ + \")\",\n        \"--zoom\": zoom,\n        \"--zoompx\": zoom + \"px\"\n      }\n    }), this.renderAbles(), renderLine(Renderer, edge ? \"n\" : \"\", renderPoses[0], renderPoses[1], zoom, 0), renderLine(Renderer, edge ? \"e\" : \"\", renderPoses[1], renderPoses[3], zoom, 1), renderLine(Renderer, edge ? \"w\" : \"\", renderPoses[0], renderPoses[2], zoom, 2), renderLine(Renderer, edge ? \"s\" : \"\", renderPoses[2], renderPoses[3], zoom, 3));\n  };\n\n  __proto.componentDidMount = function () {\n    this.controlBox.getElement();\n    var props = this.props;\n    var parentMoveable = props.parentMoveable,\n        container = props.container,\n        wrapperMoveable = props.wrapperMoveable;\n    this.updateEvent(props);\n    this.updateNativeEvents(props);\n\n    if (!container && !parentMoveable && !wrapperMoveable) {\n      this.updateRect(\"\", false, true);\n    }\n\n    this.updateCheckInput();\n  };\n\n  __proto.componentDidUpdate = function (prevProps) {\n    this.updateNativeEvents(prevProps);\n    this.updateEvent(prevProps);\n    this.updateCheckInput();\n  };\n\n  __proto.componentWillUnmount = function () {\n    this.isUnmounted = true;\n    unset(this, \"targetGesto\");\n    unset(this, \"controlGesto\");\n    var events = this.events;\n\n    for (var name in events) {\n      var manager = events[name];\n      manager && manager.destroy();\n    }\n  };\n\n  __proto.getContainer = function () {\n    var _a = this.props,\n        parentMoveable = _a.parentMoveable,\n        wrapperMoveable = _a.wrapperMoveable,\n        container = _a.container;\n    return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;\n  };\n  /**\n   * Check if the target is an element included in the moveable.\n   * @method Moveable#isMoveableElement\n   * @param - the target\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"click\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *         moveable.target = e.target;\n   *     }\n   * });\n   */\n\n\n  __proto.isMoveableElement = function (target) {\n    return target && (target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1;\n  };\n  /**\n   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n   * @method Moveable#dragStart\n   * @param - external `MouseEvent`or `TouchEvent`\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *          moveable.dragStart(e);\n   *     }\n   * });\n   */\n\n\n  __proto.dragStart = function (e) {\n    if (this.targetGesto) {\n      this.targetGesto.triggerDragStart(e);\n    }\n\n    return this;\n  };\n  /**\n   * Hit test an element or rect on a moveable target.\n   * @method Moveable#hitTest\n   * @param - element or rect to test\n   * @return - Get hit test rate (rate > 0 is hitted)\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.hitTest(e.target) > 0) {\n   *          console.log(\"hiited\");\n   *     }\n   * });\n   */\n\n\n  __proto.hitTest = function (el) {\n    var _a = this.state,\n        target = _a.target,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        pos3 = _a.pos3,\n        pos4 = _a.pos4,\n        targetClientRect = _a.targetClientRect;\n\n    if (!target) {\n      return 0;\n    }\n\n    var rect;\n\n    if (el instanceof Element) {\n      var clientRect = el.getBoundingClientRect();\n      rect = {\n        left: clientRect.left,\n        top: clientRect.top,\n        width: clientRect.width,\n        height: clientRect.height\n      };\n    } else {\n      rect = _assign({\n        width: 0,\n        height: 0\n      }, el);\n    }\n\n    var rectLeft = rect.left,\n        rectTop = rect.top,\n        rectWidth = rect.width,\n        rectHeight = rect.height;\n    var points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);\n    var size = getOverlapSize(points, [[rectLeft, rectTop], [rectLeft + rectWidth, rectTop], [rectLeft + rectWidth, rectTop + rectHeight], [rectLeft, rectTop + rectHeight]]);\n    var totalSize = getAreaSize(points);\n\n    if (!size || !totalSize) {\n      return 0;\n    }\n\n    return Math.min(100, size / totalSize * 100);\n  };\n  /**\n   * Whether the coordinates are inside Moveable\n   * @method Moveable#isInside\n   * @param - x coordinate\n   * @param - y coordinate\n   * @return - True if the coordinate is in moveable or false\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.isInside(e.clientX, e.clientY)) {\n   *          console.log(\"inside\");\n   *     }\n   * });\n   */\n\n\n  __proto.isInside = function (clientX, clientY) {\n    var _a = this.state,\n        target = _a.target,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        pos3 = _a.pos3,\n        pos4 = _a.pos4,\n        targetClientRect = _a.targetClientRect;\n\n    if (!target) {\n      return false;\n    }\n\n    return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));\n  };\n  /**\n   * If the width, height, left, and top of all elements change, update the shape of the moveable.\n   * @method Moveable#updateRect\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"resize\", e => {\n   *     moveable.updateRect();\n   * });\n   */\n\n\n  __proto.updateRect = function (type, isTarget, isSetState) {\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n\n    var props = this.props;\n    var parentMoveable = props.parentMoveable;\n    var state = this.state;\n    var target = state.target || this.props.target;\n    var container = this.getContainer();\n    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;\n    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container), parentMoveable ? false : isSetState);\n  };\n\n  __proto.isTargetChanged = function (prevProps, useDragArea) {\n    var props = this.props;\n    var target = props.dragTarget || props.target;\n    var prevTarget = prevProps.dragTarget || prevProps.target;\n    var dragArea = props.dragArea;\n    var prevDragArea = prevProps.dragArea;\n    var isTargetChanged = !dragArea && prevTarget !== target;\n    return isTargetChanged || (useDragArea || dragArea) && prevDragArea !== dragArea;\n  };\n\n  __proto.updateNativeEvents = function (prevProps) {\n    var _this = this;\n\n    var props = this.props;\n    var target = props.dragArea ? this.areaElement : this.state.target;\n    var events = this.events;\n    var eventKeys = getKeys(events);\n\n    if (this.isTargetChanged(prevProps)) {\n      for (var eventName in events) {\n        var manager = events[eventName];\n        manager && manager.destroy();\n        events[eventName] = null;\n      }\n    }\n\n    if (!target) {\n      return;\n    }\n\n    var enabledAbles = this.enabledAbles;\n    eventKeys.forEach(function (eventName) {\n      var ables = filterAbles(enabledAbles, [eventName]);\n      var hasAbles = ables.length > 0;\n      var manager = events[eventName];\n\n      if (!hasAbles) {\n        if (manager) {\n          manager.destroy();\n          events[eventName] = null;\n        }\n\n        return;\n      }\n\n      if (!manager) {\n        manager = new EventManager(target, _this, eventName);\n        events[eventName] = manager;\n      }\n\n      manager.setAbles(ables);\n    });\n  };\n\n  __proto.updateEvent = function (prevProps) {\n    var controlBoxElement = this.controlBox.getElement();\n    var hasTargetAble = this.targetAbles.length;\n    var hasControlAble = this.controlAbles.length;\n    var props = this.props;\n    var target = props.dragTarget || props.target;\n    var isTargetChanged = this.isTargetChanged(prevProps, true);\n    var isUnset = !hasTargetAble && this.targetGesto || isTargetChanged;\n\n    if (isUnset) {\n      unset(this, \"targetGesto\");\n      this.updateState({\n        gesto: null\n      });\n    }\n\n    if (!hasControlAble) {\n      unset(this, \"controlGesto\");\n    }\n\n    if (target && hasTargetAble && !this.targetGesto) {\n      this.targetGesto = getTargetAbleGesto(this, target, \"\");\n    }\n\n    if (!this.controlGesto && hasControlAble) {\n      this.controlGesto = getAbleGesto(this, controlBoxElement, \"controlAbles\", \"Control\");\n    }\n\n    if (isUnset) {\n      this.unsetAbles();\n    }\n  };\n  /**\n   * Check if the moveable state is being dragged.\n   * @method Moveable#isDragging\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // false\n   * console.log(moveable.isDragging());\n   *\n   * moveable.on(\"drag\", () => {\n   *   // true\n   *   console.log(moveable.isDragging());\n   * });\n   */\n\n\n  __proto.isDragging = function () {\n    return (this.targetGesto ? this.targetGesto.isFlag() : false) || (this.controlGesto ? this.controlGesto.isFlag() : false);\n  };\n  /**\n   * If the width, height, left, and top of the only target change, update the shape of the moveable.\n   * @method Moveable#updateTarget\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.updateTarget();\n   */\n\n\n  __proto.updateTarget = function (type) {\n    this.updateRect(type, true);\n  };\n  /**\n   * You can get the vertex information, position and offset size information of the target based on the container.\n   * @method Moveable#getRect\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const rectInfo = moveable.getRect();\n   */\n\n\n  __proto.getRect = function () {\n    var state = this.state;\n    var poses = getAbsolutePosesByState(this.state);\n    var pos1 = poses[0],\n        pos2 = poses[1],\n        pos3 = poses[2],\n        pos4 = poses[3];\n    var rect = getRect(poses);\n    var offsetWidth = state.width,\n        offsetHeight = state.height;\n    var width = rect.width,\n        height = rect.height,\n        left = rect.left,\n        top = rect.top;\n    var statePos = [state.left, state.top];\n    var origin = plus(statePos, state.origin);\n    var beforeOrigin = plus(statePos, state.beforeOrigin);\n    var transformOrigin = state.transformOrigin;\n    return {\n      width: width,\n      height: height,\n      left: left,\n      top: top,\n      pos1: pos1,\n      pos2: pos2,\n      pos3: pos3,\n      pos4: pos4,\n      offsetWidth: offsetWidth,\n      offsetHeight: offsetHeight,\n      beforeOrigin: beforeOrigin,\n      origin: origin,\n      transformOrigin: transformOrigin,\n      rotation: this.getRotation()\n    };\n  };\n  /**\n   * Get a manager that manages the moveable's state and props.\n   * @method Moveable#getManager\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const manager = moveable.getManager(); // real moveable class instance\n   */\n\n\n  __proto.getManager = function () {\n    return this;\n  };\n\n  __proto.getRotation = function () {\n    var _a = this.state,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        direction = _a.direction;\n    return getAbsoluteRotation(pos1, pos2, direction);\n  };\n  /**\n   * Request able through a method rather than an event.\n   * At the moment of execution, requestStart is executed,\n   * and then request and requestEnd can be executed through Requester.\n   * @method Moveable#request\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n   * @param - ableName\n   * @param - request to be able params.\n   * @param - If isInstant is true, request and requestEnd are executed immediately.\n   * @return - Able Requester. If there is no request in able, nothing will work.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   *\n   * // Start move\n   * const requester = moveable.request(\"draggable\");\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.requestEnd();\n   */\n\n\n  __proto.request = function (ableName, param, isInstant) {\n    if (param === void 0) {\n      param = {};\n    }\n\n    var _a = this.props,\n        ables = _a.ables,\n        groupable = _a.groupable;\n    var requsetAble = ables.filter(function (able) {\n      return able.name === ableName;\n    })[0];\n\n    if (this.isDragging() || !requsetAble || !requsetAble.request) {\n      return {\n        request: function request() {\n          return this;\n        },\n        requestEnd: function requestEnd() {\n          return this;\n        }\n      };\n    }\n\n    var self = this;\n    var ableRequester = requsetAble.request(this);\n    var requestInstant = isInstant || param.isInstant;\n    var ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n    var eventAffix = \"\" + (groupable ? \"Group\" : \"\") + (ableRequester.isControl ? \"Control\" : \"\");\n    var requester = {\n      request: function request(ableParam) {\n        triggerAble(self, ableType, \"drag\", eventAffix, \"\", _assign(_assign({}, ableRequester.request(ableParam)), {\n          requestAble: ableName,\n          isRequest: true\n        }), requestInstant);\n        return this;\n      },\n      requestEnd: function requestEnd() {\n        triggerAble(self, ableType, \"drag\", eventAffix, \"End\", _assign(_assign({}, ableRequester.requestEnd()), {\n          requestAble: ableName,\n          isRequest: true\n        }), requestInstant);\n        return this;\n      }\n    };\n    triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", _assign(_assign({}, ableRequester.requestStart(param)), {\n      requestAble: ableName,\n      isRequest: true\n    }), requestInstant);\n    return requestInstant ? requester.request(param).requestEnd() : requester;\n  };\n  /**\n   * Remove the Moveable object and the events.\n   * @method Moveable#destroy\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.destroy();\n   */\n\n\n  __proto.destroy = function () {\n    this.componentWillUnmount();\n  };\n\n  __proto.updateRenderPoses = function () {\n    var state = this.state;\n    var props = this.props;\n    var originalBeforeOrigin = state.originalBeforeOrigin,\n        transformOrigin = state.transformOrigin,\n        allMatrix = state.allMatrix,\n        is3d = state.is3d,\n        pos1 = state.pos1,\n        pos2 = state.pos2,\n        pos3 = state.pos3,\n        pos4 = state.pos4,\n        stateLeft = state.left,\n        stateTop = state.top;\n\n    var _a = props.padding || {},\n        _b = _a.left,\n        left = _b === void 0 ? 0 : _b,\n        _c = _a.top,\n        top = _c === void 0 ? 0 : _c,\n        _d = _a.bottom,\n        bottom = _d === void 0 ? 0 : _d,\n        _e = _a.right,\n        right = _e === void 0 ? 0 : _e;\n\n    var n = is3d ? 4 : 3;\n    var absoluteOrigin = props.groupable ? originalBeforeOrigin : plus(originalBeforeOrigin, [stateLeft, stateTop]);\n    state.renderPoses = [plus(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)), plus(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)), plus(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)), plus(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n))];\n  };\n\n  __proto.checkUpdate = function () {\n    var _a = this.props,\n        target = _a.target,\n        container = _a.container,\n        parentMoveable = _a.parentMoveable;\n    var _b = this.state,\n        stateTarget = _b.target,\n        stateContainer = _b.container;\n\n    if (!stateTarget && !target) {\n      return;\n    }\n\n    this.updateAbles();\n    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n    if (!isChanged) {\n      return;\n    }\n\n    this.updateState({\n      target: target,\n      container: container\n    });\n\n    if (!parentMoveable && (container || this.controlBox)) {\n      this.updateRect(\"End\", false, false);\n    }\n  };\n\n  __proto.triggerEvent = function (name, e) {\n    var callback = this.props[name];\n    return callback && callback(e);\n  };\n\n  __proto.useCSS = function (tag, css) {\n    var customStyleMap = this.props.customStyledMap;\n    var key = tag + css;\n\n    if (!customStyleMap[key]) {\n      customStyleMap[key] = styled(tag, css);\n    }\n\n    return customStyleMap[key];\n  };\n\n  __proto.unsetAbles = function () {\n    var _this = this;\n\n    if (this.targetAbles.filter(function (able) {\n      if (able.unset) {\n        able.unset(_this);\n        return true;\n      }\n\n      return false;\n    }).length) {\n      this.forceUpdate();\n    }\n  };\n\n  __proto.updateAbles = function (ables, eventAffix) {\n    if (ables === void 0) {\n      ables = this.props.ables;\n    }\n\n    if (eventAffix === void 0) {\n      eventAffix = \"\";\n    }\n\n    var props = this.props;\n    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    var enabledAbles = ables.filter(function (able) {\n      return able && (able.always || props[able.name]);\n    });\n    var dragStart = \"drag\" + eventAffix + \"Start\";\n    var pinchStart = \"pinch\" + eventAffix + \"Start\";\n    var dragControlStart = \"drag\" + eventAffix + \"ControlStart\";\n    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n    this.enabledAbles = enabledAbles;\n    this.targetAbles = targetAbles;\n    this.controlAbles = controlAbles;\n  };\n\n  __proto.updateState = function (nextState, isSetState) {\n    if (isSetState) {\n      this.setState(nextState);\n    } else {\n      var state = this.state;\n\n      for (var name in nextState) {\n        state[name] = nextState[name];\n      }\n    }\n  };\n\n  __proto.getEnabledAbles = function () {\n    var props = this.props;\n    var ables = props.ables;\n    return ables.filter(function (able) {\n      return able && props[able.name];\n    });\n  };\n\n  __proto.renderAbles = function () {\n    var _this = this;\n\n    var props = this.props;\n    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    var Renderer = {\n      createElement: createElement\n    };\n    return groupByMap(flat(filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(function (_a) {\n      var render = _a.render;\n      return render(_this, Renderer) || [];\n    })).filter(function (el) {\n      return el;\n    }), function (_a) {\n      var key = _a.key;\n      return key;\n    }).map(function (group) {\n      return group[0];\n    });\n  };\n\n  __proto.updateCheckInput = function () {\n    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n  };\n\n  MoveableManager.defaultProps = {\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: true,\n    edge: false,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    parentPosition: null,\n    portalContainer: null,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: false,\n    passDragArea: false,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: false,\n    padding: {},\n    pinchOutside: true,\n    checkInput: false,\n    groupable: false,\n    cspNonce: \"\",\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {}\n  };\n  return MoveableManager;\n}(PureComponent);\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n\n/**\n * Zooms in the elements of a moveable. (default: 1)\n * @name Moveable#zoom\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox. (default: \"\")\n * @name Moveable#className\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s) (default: target)\n * @name Moveable#dragTarget\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n\n\nvar Groupable = {\n  name: \"groupable\",\n  props: {\n    defaultGroupRotate: Number,\n    defaultGroupOrigin: String,\n    groupable: Boolean\n  },\n  events: {},\n  render: function render(moveable, React) {\n    var targets = moveable.props.targets || [];\n    moveable.moveables = [];\n    var _a = moveable.state,\n        left = _a.left,\n        top = _a.top;\n    var position = {\n      left: left,\n      top: top\n    };\n    return targets.map(function (target, i) {\n      return React.createElement(MoveableManager, {\n        key: \"moveable\" + i,\n        ref: refs(moveable, \"moveables\", i),\n        target: target,\n        origin: false,\n        cssStyled: moveable.props.cssStyled,\n        customStyledMap: moveable.props.customStyledMap,\n        parentMoveable: moveable,\n        parentPosition: position\n      });\n    });\n  }\n};\nvar Clickable = makeAble(\"clickable\", {\n  props: {},\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  always: true,\n  dragStart: function dragStart(moveable, e) {\n    if (!e.isRequest) {\n      addEvent(window, \"click\", moveable.onPreventClick, true);\n    }\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    this.dragStart(moveable, e);\n  },\n  dragGroupStart: function dragGroupStart(moveable, e) {\n    this.dragStart(moveable, e);\n    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n  },\n  dragEnd: function dragEnd(moveable, e) {\n    this.endEvent(moveable);\n    var target = moveable.state.target;\n    var inputEvent = e.inputEvent;\n    var inputTarget = e.inputTarget;\n\n    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) // External event duplicate target or dragAreaElement\n    ) {\n      return;\n    }\n\n    var containsTarget = target.contains(inputTarget);\n    triggerEvent(moveable, \"onClick\", fillParams(moveable, e, {\n      isDouble: e.isDouble,\n      inputTarget: inputTarget,\n      isTarget: target === inputTarget,\n      containsTarget: containsTarget\n    }));\n  },\n  dragGroupEnd: function dragGroupEnd(moveable, e) {\n    this.endEvent(moveable);\n    var inputEvent = e.inputEvent;\n    var inputTarget = e.inputTarget;\n\n    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) // External event duplicate target or dragAreaElement\n    || e.datas.inputTarget === inputTarget) {\n      return;\n    }\n\n    var targets = moveable.props.targets;\n    var targetIndex = targets.indexOf(inputTarget);\n    var isTarget = targetIndex > -1;\n    var containsTarget = false;\n\n    if (targetIndex === -1) {\n      targetIndex = findIndex(targets, function (parentTarget) {\n        return parentTarget.contains(inputTarget);\n      });\n      containsTarget = targetIndex > -1;\n    }\n\n    triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n      isDouble: e.isDouble,\n      targets: targets,\n      inputTarget: inputTarget,\n      targetIndex: targetIndex,\n      isTarget: isTarget,\n      containsTarget: containsTarget\n    }));\n  },\n  dragControlEnd: function dragControlEnd(moveable) {\n    this.endEvent(moveable);\n  },\n  dragGroupControlEnd: function dragGroupControlEnd(moveable) {\n    this.endEvent(moveable);\n  },\n  endEvent: function endEvent(moveable) {\n    var _this = this;\n\n    requestAnimationFrame(function () {\n      _this.unset(moveable);\n    });\n  },\n  unset: function unset(moveable) {\n    removeEvent(window, \"click\", moveable.onPreventClick, true);\n  }\n});\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n\nfunction getDraggableEvent(e) {\n  var datas = e.originalDatas.draggable;\n\n  if (!datas) {\n    e.originalDatas.draggable = {};\n    datas = e.originalDatas.draggable;\n  }\n\n  return _assign(_assign({}, e), {\n    datas: datas\n  });\n}\n\nvar edgeDraggable = makeAble(\"edgeDraggable\", {\n  dragControlCondition: function dragControlCondition(moveable, e) {\n    if (!moveable.props.edgeDraggable || !e.inputEvent) {\n      return false;\n    }\n\n    var target = e.inputEvent.target;\n    return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n  },\n  dragControlStart: function dragControlStart(moveable, e) {\n    return Draggable.dragStart(moveable, getDraggableEvent(e));\n  },\n  dragControl: function dragControl(moveable, e) {\n    return Draggable.drag(moveable, getDraggableEvent(e));\n  },\n  dragControlEnd: function dragControlEnd(moveable, e) {\n    return Draggable.dragEnd(moveable, getDraggableEvent(e));\n  },\n  dragGroupControlCondition: function dragGroupControlCondition(moveable, e) {\n    if (!moveable.props.edgeDraggable || !e.inputEvent) {\n      return false;\n    }\n\n    var target = e.inputEvent.target;\n    return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n  },\n  dragGroupControlStart: function dragGroupControlStart(moveable, e) {\n    return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n  },\n  dragGroupControl: function dragGroupControl(moveable, e) {\n    return Draggable.dragGroup(moveable, getDraggableEvent(e));\n  },\n  dragGroupControlEnd: function dragGroupControlEnd(moveable, e) {\n    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n  },\n  unset: function unset(moveable) {\n    moveable.state.dragInfo = null;\n  }\n});\n/**\n * Whether to move by dragging the edge line (default: false)\n * @name Moveable.Draggable#edgeDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  draggable: true,\n *  edgeDraggable: false,\n * });\n *\n * moveable.edgeDraggable = true;\n */\n\nvar IndividualGroupable = {\n  name: \"individualGroupable\",\n  props: {\n    individualGroupable: Boolean\n  },\n  events: {}\n};\nvar MOVEABLE_ABLES = /*#__PURE__*/[BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable];\nvar MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {\n  return _assign(_assign({}, current), \"events\" in able ? able.events : {});\n}, {});\nvar MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce(function (current, able) {\n  return _assign(_assign({}, current), able.props);\n}, {});\nvar MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);\nvar MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);\nvar MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);\n\nfunction getMaxPos(poses, index) {\n  return Math.max.apply(Math, poses.map(function (_a) {\n    var pos1 = _a[0],\n        pos2 = _a[1],\n        pos3 = _a[2],\n        pos4 = _a[3];\n    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n  }));\n}\n\nfunction getMinPos(poses, index) {\n  return Math.min.apply(Math, poses.map(function (_a) {\n    var pos1 = _a[0],\n        pos2 = _a[1],\n        pos3 = _a[2],\n        pos4 = _a[3];\n    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n  }));\n}\n\nfunction getGroupRect(moveables, rotation) {\n  if (!moveables.length) {\n    return [0, 0, 0, 0];\n  }\n\n  var moveablePoses = moveables.map(function (_a) {\n    var state = _a.state;\n    return getAbsolutePosesByState(state);\n  });\n  var minX = MAX_NUM;\n  var minY = MAX_NUM;\n  var groupWidth = 0;\n  var groupHeight = 0;\n  var fixedRotation = throttle(rotation, TINY_NUM);\n\n  if (fixedRotation % 90) {\n    var rad_1 = fixedRotation / 180 * Math.PI;\n    var a1_1 = Math.tan(rad_1);\n    var a2_1 = -1 / a1_1;\n    var b1MinMax_1 = [MIN_NUM, MAX_NUM];\n    var b2MinMax_1 = [MIN_NUM, MAX_NUM];\n    moveablePoses.forEach(function (poses) {\n      poses.forEach(function (pos) {\n        // ax + b = y\n        // b = y - ax\n        var b1 = pos[1] - a1_1 * pos[0];\n        var b2 = pos[1] - a2_1 * pos[0];\n        b1MinMax_1[0] = Math.max(b1MinMax_1[0], b1);\n        b1MinMax_1[1] = Math.min(b1MinMax_1[1], b1);\n        b2MinMax_1[0] = Math.max(b2MinMax_1[0], b2);\n        b2MinMax_1[1] = Math.min(b2MinMax_1[1], b2);\n      });\n    });\n    b1MinMax_1.forEach(function (b1) {\n      // a1x + b1 = a2x + b2\n      b2MinMax_1.forEach(function (b2) {\n        // (a1 - a2)x = b2 - b1\n        var x = (b2 - b1) / (a1_1 - a2_1);\n        var y = a1_1 * x + b1;\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n      });\n    });\n    var rotatePoses = moveablePoses.map(function (_a) {\n      var pos1 = _a[0],\n          pos2 = _a[1],\n          pos3 = _a[2],\n          pos4 = _a[3];\n      return [rotate(pos1, -rad_1), rotate(pos2, -rad_1), rotate(pos3, -rad_1), rotate(pos4, -rad_1)];\n    });\n    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n  } else {\n    minX = getMinPos(moveablePoses, 0);\n    minY = getMinPos(moveablePoses, 1);\n    groupWidth = getMaxPos(moveablePoses, 0) - minX;\n    groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n    if (fixedRotation % 180) {\n      var changedWidth = groupWidth;\n      groupWidth = groupHeight;\n      groupHeight = changedWidth;\n    }\n  }\n\n  return [minX, minY, groupWidth, groupHeight];\n}\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\n\n\nvar MoveableGroup = /*#__PURE__*/function (_super) {\n  __extends(MoveableGroup, _super);\n\n  function MoveableGroup() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.differ = new ChildrenDiffer();\n    _this.moveables = [];\n    _this.transformOrigin = \"50% 50%\";\n    return _this;\n  }\n\n  var __proto = MoveableGroup.prototype;\n\n  __proto.updateEvent = function (prevProps) {\n    var state = this.state;\n    var props = this.props;\n    var prevTarget = prevProps.dragTarget || state.target;\n    var nextTarget = props.dragTarget || this.areaElement;\n\n    if (prevTarget !== nextTarget) {\n      unset(this, \"targetGesto\");\n      unset(this, \"controlGesto\");\n      state.target = null;\n    }\n\n    if (!state.target) {\n      state.target = this.areaElement;\n      this.controlBox.getElement().style.display = \"block\";\n      this.targetGesto = getTargetAbleGesto(this, nextTarget, \"Group\");\n      this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n    }\n\n    var isContainerChanged = !equals(prevProps.container, props.container);\n\n    if (isContainerChanged) {\n      state.container = props.container;\n    }\n\n    var _a = this.differ.update(props.targets),\n        added = _a.added,\n        changed = _a.changed,\n        removed = _a.removed;\n\n    if (isContainerChanged || added.length || changed.length || removed.length) {\n      this.updateRect();\n    }\n  };\n\n  __proto.checkUpdate = function () {\n    this.updateAbles();\n  };\n\n  __proto.updateRect = function (type, isTarget, isSetState) {\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n\n    if (!this.controlBox) {\n      return;\n    }\n\n    this.moveables.forEach(function (moveable) {\n      moveable.updateRect(type, false, false);\n    });\n    var state = this.state;\n    var props = this.props;\n    var target = state.target || props.target;\n\n    if (!isTarget || type !== \"\" && props.updateGroup) {\n      // reset rotataion\n      this.rotation = props.defaultGroupRotate;\n      this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n      this.scale = [1, 1];\n    }\n\n    var rotation = this.rotation;\n    var scale = this.scale;\n\n    var _a = getGroupRect(this.moveables, rotation),\n        left = _a[0],\n        top = _a[1],\n        width = _a[2],\n        height = _a[3]; // tslint:disable-next-line: max-line-length\n\n\n    var transform = \"rotate(\" + rotation + \"deg) scale(\" + (scale[0] >= 0 ? 1 : -1) + \", \" + (scale[1] >= 0 ? 1 : -1) + \")\";\n    target.style.cssText += \"left:0px;top:0px; transform-origin: \" + this.transformOrigin + \"; width:\" + width + \"px; height:\" + height + \"px;\" + (\"transform:\" + transform);\n    state.width = width;\n    state.height = height;\n    var container = this.getContainer();\n    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container);\n    var pos = [info.left, info.top];\n\n    var _b = getAbsolutePosesByState(info),\n        pos1 = _b[0],\n        pos2 = _b[1],\n        pos3 = _b[2],\n        pos4 = _b[3]; // info.left + info.pos(1 ~ 4)\n\n\n    var minPos = getMinMaxs([pos1, pos2, pos3, pos4]);\n    var delta = [minPos.minX, minPos.minY];\n    info.pos1 = minus(pos1, delta);\n    info.pos2 = minus(pos2, delta);\n    info.pos3 = minus(pos3, delta);\n    info.pos4 = minus(pos4, delta);\n    info.left = left - info.left + delta[0];\n    info.top = top - info.top + delta[1];\n    info.origin = minus(plus(pos, info.origin), delta);\n    info.beforeOrigin = minus(plus(pos, info.beforeOrigin), delta);\n    info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin); // info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);\n\n    var clientRect = info.targetClientRect;\n    var direction = scale[0] * scale[1] > 0 ? 1 : -1;\n    clientRect.top += info.top - state.top;\n    clientRect.left += info.left - state.left;\n    target.style.transform = \"translate(\" + -delta[0] + \"px, \" + -delta[1] + \"px) \" + transform;\n    this.updateState(_assign(_assign({}, info), {\n      direction: direction,\n      beforeDirection: direction\n    }), isSetState);\n  };\n\n  __proto.getRect = function () {\n    return _assign(_assign({}, _super.prototype.getRect.call(this)), {\n      children: this.moveables.map(function (child) {\n        return child.getRect();\n      })\n    });\n  };\n\n  __proto.triggerEvent = function (name, e, isManager) {\n    if (isManager || name.indexOf(\"Group\") > -1) {\n      return _super.prototype.triggerEvent.call(this, name, e);\n    }\n  };\n\n  __proto.updateAbles = function () {\n    _super.prototype.updateAbles.call(this, __spreadArrays(this.props.ables, [Groupable]), \"Group\");\n  };\n\n  MoveableGroup.defaultProps = _assign(_assign({}, MoveableManager.defaultProps), {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: true,\n    dragArea: true,\n    keepRatio: true,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\"\n  });\n  return MoveableGroup;\n}(MoveableManager);\n/**\n * @namespace Moveable.IndividualGroup\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\n */\n\n\nvar MoveableIndividualGroup = /*#__PURE__*/function (_super) {\n  __extends(MoveableIndividualGroup, _super);\n\n  function MoveableIndividualGroup() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.moveables = [];\n    return _this;\n  }\n\n  var __proto = MoveableIndividualGroup.prototype;\n\n  __proto.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        cspNonce = _a.cspNonce,\n        ControlBoxElement = _a.cssStyled,\n        targets = _a.targets;\n    return createElement(ControlBoxElement, {\n      cspNonce: cspNonce,\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\")\n    }, targets.map(function (target, i) {\n      return createElement(MoveableManager, _assign({\n        key: \"moveable\" + i,\n        ref: refs(_this, \"moveables\", i)\n      }, _this.props, {\n        target: target,\n        wrapperMoveable: _this\n      }));\n    }));\n  };\n\n  __proto.componentDidUpdate = function () {};\n\n  __proto.updateRect = function (type, isTarget, isSetState) {\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n\n    this.moveables.forEach(function (moveable) {\n      moveable.updateRect(type, isTarget, isSetState);\n    });\n  };\n\n  __proto.getRect = function () {\n    return _assign(_assign({}, _super.prototype.getRect.call(this)), {\n      children: this.moveables.map(function (child) {\n        return child.getRect();\n      })\n    });\n  };\n\n  __proto.request = function () {\n    return {\n      request: function request() {\n        return this;\n      },\n      requestEnd: function requestEnd() {\n        return this;\n      }\n    };\n  };\n\n  __proto.dragStart = function () {\n    return this;\n  };\n\n  __proto.hitTest = function () {\n    return 0;\n  };\n\n  __proto.isInside = function () {\n    return false;\n  };\n\n  __proto.isDragging = function () {\n    return false;\n  };\n\n  __proto.updateRenderPoses = function () {};\n\n  __proto.updateEvent = function () {};\n\n  __proto.checkUpdate = function () {};\n\n  __proto.triggerEvent = function () {};\n\n  __proto.updateAbles = function () {};\n\n  return MoveableIndividualGroup;\n}(MoveableManager);\n\nvar InitialMoveable = /*#__PURE__*/function (_super) {\n  __extends(InitialMoveable, _super);\n\n  function InitialMoveable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.refTargets = [];\n    _this.selectorMap = {};\n    return _this;\n  }\n\n  var __proto = InitialMoveable.prototype;\n\n  InitialMoveable.makeStyled = function () {\n    var cssMap = {};\n    var ables = this.getTotalAbles();\n    ables.forEach(function (_a) {\n      var css = _a.css;\n\n      if (!css) {\n        return;\n      }\n\n      css.forEach(function (text) {\n        cssMap[text] = true;\n      });\n    });\n    var style = getKeys(cssMap).join(\"\\n\");\n    this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + style));\n  };\n\n  InitialMoveable.getTotalAbles = function () {\n    return __spreadArrays([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles);\n  };\n\n  __proto.render = function () {\n    var moveableContructor = this.constructor;\n\n    if (!moveableContructor.defaultStyled) {\n      moveableContructor.makeStyled();\n    }\n\n    var _a = this.props,\n        userAbles = _a.ables,\n        userProps = _a.props,\n        props = __rest(_a, [\"ables\", \"props\"]);\n\n    var refTargets = getRefTargets(props.target || props.targets);\n    var elementTargets = getElementTargets(refTargets, this.selectorMap);\n    this.refTargets = refTargets;\n    var isGroup = elementTargets.length > 1;\n    var totalAbles = moveableContructor.getTotalAbles();\n\n    var ables = __spreadArrays(totalAbles, userAbles || []);\n\n    var nextProps = _assign(_assign(_assign({}, props), userProps || {}), {\n      ables: ables,\n      cssStyled: moveableContructor.defaultStyled,\n      customStyledMap: moveableContructor.customStyledMap\n    });\n\n    if (isGroup) {\n      if (props.individualGroupable) {\n        return createElement(MoveableIndividualGroup, _assign({\n          key: \"individual-group\",\n          ref: ref(this, \"moveable\")\n        }, nextProps, {\n          target: null,\n          targets: elementTargets\n        }));\n      }\n\n      return createElement(MoveableGroup, _assign({\n        key: \"group\",\n        ref: ref(this, \"moveable\")\n      }, nextProps, {\n        target: null,\n        targets: elementTargets\n      }));\n    } else {\n      return createElement(MoveableManager, _assign({\n        key: \"single\",\n        ref: ref(this, \"moveable\")\n      }, nextProps, {\n        target: elementTargets[0]\n      }));\n    }\n  };\n\n  __proto.componentDidMount = function () {\n    this.updateRefs();\n  };\n\n  __proto.componentDidUpdate = function () {\n    this.updateRefs();\n  };\n\n  __proto.updateRefs = function (isReset) {\n    var refTargets = getRefTargets(this.props.target || this.props.targets);\n    var isUpdate = this.refTargets.some(function (target, i) {\n      var nextTarget = refTargets[i];\n\n      if (!target && !nextTarget) {\n        return false;\n      } else if (target !== nextTarget) {\n        return true;\n      }\n\n      return false;\n    });\n    var selectorMap = isReset ? {} : this.selectorMap;\n    var nextSelectorMap = {};\n    this.refTargets.forEach(function (target) {\n      if (isString(target)) {\n        if (!selectorMap[target]) {\n          isUpdate = true;\n          nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));\n        } else {\n          nextSelectorMap[target] = selectorMap[target];\n        }\n      }\n    });\n    this.selectorMap = nextSelectorMap;\n\n    if (isUpdate) {\n      this.forceUpdate();\n    }\n  };\n\n  __proto.getManager = function () {\n    return this.moveable;\n  };\n\n  InitialMoveable.defaultAbles = [];\n  InitialMoveable.customStyledMap = {};\n  InitialMoveable.defaultStyled = null;\n\n  __decorate([withMethods(MOVEABLE_METHODS)], InitialMoveable.prototype, \"moveable\", void 0);\n\n  return InitialMoveable;\n}(PureComponent);\n\nvar Moveable = /*#__PURE__*/function (_super) {\n  __extends(Moveable, _super);\n\n  function Moveable() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Moveable.defaultAbles = MOVEABLE_ABLES;\n  return Moveable;\n}(InitialMoveable);\n\nfunction makeMoveable(ables) {\n  var _a;\n\n  return _a = /*#__PURE__*/function (_super) {\n    __extends(Moveable, _super);\n\n    function Moveable() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    return Moveable;\n  }(InitialMoveable), _a.defaultAbles = ables, _a;\n}\n\nexport default Moveable;\nexport { Clippable, Draggable, edgeDraggable as EdgeDraggable, InitialMoveable, MOVEABLE_ABLES, MOVEABLE_EVENTS, MOVEABLE_EVENTS_MAP, MOVEABLE_EVENTS_PROPS_MAP, MOVEABLE_METHODS, MOVEABLE_PROPS, MOVEABLE_PROPS_MAP, Pinchable, Resizable, Rotatable, Roundable, Scalable, Snappable, Warpable, getElementInfo, makeAble, makeMoveable };","map":{"version":3,"sources":["../src/react-moveable/ables/AbleManager.ts","../src/react-moveable/consts.ts","../src/react-moveable/utils.tsx","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/gesto/CustomGesto.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/gesto/GestoUtils.ts","../src/react-moveable/ables/snappable/snap.ts","../src/react-moveable/ables/snappable/innerBounds.ts","../src/react-moveable/ables/snappable/bounds.ts","../src/react-moveable/ables/snappable/render.tsx","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/ables/Draggable.tsx","../src/react-moveable/renderDirections.tsx","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/Default.ts","../src/react-moveable/ables/Padding.tsx","../src/react-moveable/ables/roundable/borderRadius.tsx","../src/react-moveable/ables/Clippable.tsx","../src/react-moveable/ables/OriginDraggable.tsx","../src/react-moveable/ables/Roundable.tsx","../src/react-moveable/ables/BeforeRenderable.ts","../src/react-moveable/ables/Renderable.ts","../src/react-moveable/gesto/getAbleGesto.ts","../src/react-moveable/EventManager.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/ables/Clickable.ts","../src/react-moveable/ables/edgeDraggable.tsx","../src/react-moveable/ables/IndividualGroupable.tsx","../src/react-moveable/ables/consts.ts","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/MoveableIndividualGroup.tsx","../src/react-moveable/InitialMoveable.tsx","../src/react-moveable/Moveable.tsx","../src/react-moveable/makeMoveable.ts"],"names":["makeAble","name","able","__assign","events","props","_a","x1","getSVGCursor","x2","degree45","Math","degree","defaultCursor","agent","getAgent","IS_WEBKIT","IS_WEBKIT605","res","navigator","parseFloat","PREFIX","MOVEABLE_CSS","getCursorCSS","NEARBY_POS","FLOAT_POINT_NUM","TINY_NUM","MIN_SCALE","MAX_NUM","MIN_NUM","DIRECTIONS","DIRECTION_INDEXES","n","s","w","e","nw","ne","sw","se","DIRECTION_ROTATIONS","MOVEABLE_METHODS","multiply2","pos1","pos2","prefix","prefixNames","getTransformMatrix","transform","isObject","value","splitBracket","getAbsoluteMatrix","matrix","origin","multiplies","createOriginMatrix","measureSVGSize","el","unit","isHorizontal","viewBox","getSVGViewBox","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","splitUnit","i","style","transformOrigin","getOffsetInfo","lastParent","isParent","body","document","target","isEnd","position","isStatic","offsetParent","getOffsetPosInfo","container","isFixed","tagName","offsetLeft","offsetTop","containerClientRect","isSVG","isUndefined","hasOffset","targetOrigin","getSVGGraphicsOffset","offset","getBodyOffset","bodyStyle","bodyPosition","marginLeft","parseInt","marginTop","convert3DMatrixes","matrixes","info","convertDimension","getMatrixStackInfo","is3d","offsetContainer","convertCSStoMatrix","length","offsetPos","type","getSVGMatrix","createIdentityMatrix","isOffsetEnd","parentClientLeft","parentClientTop","margin","targetMatrix","targetTransformOrigin","calculateElementInfo","isAbsolute3d","width","height","rotation","allResult","getSize","result","calculateMatrixStack","calculateMoveablePosition","rotationPosition","getRotationRad","rootMatrix","beforeMatrix","offsetMatrix","allMatrix","targetTransform","left","top","right","bottom","pos3","pos4","direction","getElementInfo","prevTargetMatrix","rootMatrixes","isRoot3d","isNext3d","isSVGGraphicElement","originalRootContainer","rootContainer","endContainer","multiply","nextInfo","getSVGOffset","isMatrix3d","makeMatrixCSS","ignoreDimension","convertMatrixtoCSS","clientWidth","clientHeight","x","y","baseVal","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","scale","translate","xAlign","yAlign","scaleDimension","scaleMatrix","createScaleMatrix","bbox","calculatePosition","pos","calculate","convertPositionMatrix","calculatePoses","getRect","poses","posesX","posesY","rectWidth","rectHeight","calculateRect","offsetInfo","targetInfo","rect","rectLeft","rectTop","mat","prevLeft","prevTop","prevWidth","prevHeight","posOrigin","prevOrigin","minus","rectOrigin","count","inverseBeforeMatrix","invert","mat2","nextLeft","nextTop","distLeft","distTop","y1","_b","y2","_c","x3","y3","_d","x4","y4","originX","originY","getShapeDirection","getDistSize","vec","getDiagonalSize","getLineStyle","getRad","getControlTransform","zoom","getCSSSize","isOffset","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","getTargetInfo","moveableElement","parentContainer","beforeDirection","beforeOrigin","targetClientRect","resetClientRect","moveableClientRect","beforePosition","plus","getOrigin","getClientRect","originalBeforeOrigin","clientLeft","clientTop","scrollWidth","scrollHeight","isExtends","window","clientRect","getDirection","direciton","dir","getAbsolutePoses","dist","getAbsolutePosesByState","roundSign","num","unset","self","fillParams","moveable","params","datas","nextParams","clientX","clientY","inputEvent","currentTarget","fillEndParams","isDrag","lastEvent","isDouble","triggerEvent","isManager","pseudoElt","filterAbles","ables","methods","triggerAblesSimultaneously","enabledAbles","ableGroups","equals","a1","a2","selectValue","values","groupBy","arr","func","groups","groupKeys","groupKey","keyIndex","group","groupByMap","flat","prev","maxOffset","args","minOffset","calculateInversePosition","convertDragDist","state","calculatePadding","convertCSSSize","size","isRelative","moveControlPos","controlPoses","index","isRect","sub","dists","directions","verticalDirection_1","horizontalDirection_1","controlDir","controlPose","isVertical","dirDir","dirHorizontal","dirVertical","getTinyDist","v","directionCondition","hasClass","invertObject","obj","nextObj","getTransform","transforms","beforeFunctionTexts","beforeFunctionTexts2","targetFunctionText","afterFunctionTexts","afterFunctionTexts2","beforeFunctions","parse","beforeFunctions2","targetFunctions","afterFunctions","afterFunctions2","beforeFunctionMatrix","toMat","beforeFunctionMatrix2","afterFunctionMatrix","afterFunctionMatrix2","allFunctionMatrix","targetFunctionMatrix","targetFunction","isArrayFormat","isArray","getRefTarget","isSelector","isString","isFunction","getRefTargets","targets","userTargets","getElementTargets","selectorMap","elementTargets","getAbsoluteRotation","deg","getDragDistByState","inverseMatrix","calculateMatrixDist","onPinchStart","onPinch","onPinchEnd","onPinchGroupStart","onPinchGroup","onPinchGroupEnd","dragStart","pinchStart","angle","originalDatas","pinchable","eventName","controlEventName","pinchAbles","isPinch","ableEvent","parentRotate","request","pinch","pinchScale","distance","parentDistance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","setCustomDrag","delta","isConvert","draggableDatas","parentEvent","draggable","client","distX","distY","deltaX","deltaY","parentGesto","fillChildEvents","groupableDatas","childDatas","triggerChildGesto","isStart","moveables","childs","childMoveable","childEvent","parentFlag","triggerChildAbles","_","ev","callback","eachEvent","calculatePointerDist","posX","posY","getDragDist","setDragStart","getTransformDirection","resolveTransformEvent","event","functionName","nextTransforms","nextTransformAppendedIndexes","nextIndex","matFunctionName","convertTransformFormat","getTransformDist","bx","by","getBeforeDragDist","getTransfromMatrix","fromTranslation","isAfter","afterTransform","beforeTransform2","afterTransform2","targetAllTransform","nextTargetMatrix","res1","afterTargetMatrix","startDragBeforeDist","absoluteOrigin","isBefore","startDragDist","getInverseDragDist","calculateTransformOrigin","prevSize","isNaN","measureRatio","getPosIndexesByDirection","indexes","getPosesByDirection","getPosByDirection","nextPoses","average","getPosByReverseDirection","fixedPos","startPos","getNextMatrix","getNextTransformMatrix","parseMat","fillTransformStartEvent","setTransform","splitSpace","setTransformIndex","setDefaultTransformIndex","property","startTransforms","findIndex","fillOriginalTransform","fillTransformEvent","nextTransform","drag","Draggable","getTranslateDist","fixedDirection","fixedPosition","groupable","nextMatrix","groupLeft","groupTop","nextFixedPosition","getDirectionOffset","getScaleDist","scaleDist","getOriginDirection","nextFixedOffset","getRotateDist","rotateDist","getResizeDist","nextOrigin","getDist","getAbsolutePosition","calculateContainerPos","containerRect","clientPos","getGapGuidelines","guidelines","snapThreshold","start","end","otherStart","otherEnd","totalGuidelines","otherIndex","otherType","elementGuidelines","guidelineType","element","sizes","elementStart","guideline1","elementEnd","guideline2Pos","guideline2Sizes","guideline2Element","guidline2ClassName","guideline2","targetStart","targetEnd","gap","canSnap","className","gapGuidelines","centerPos","throttle","getDefaultGuidelines","horizontalGuidelines","verticalGuidelines","snapOffsetLeft","snapOffsetTop","snapOffsetBottom","snapOffsetRight","snapOffset","snapWidth","snapHeight","calculateElementGuidelines","containerLeft","containerTop","targetLeft","targetTop","getMinMaxs","topValue","leftValue","rightValue","bottomValue","elementLeft","elementTop","elementRight","elementBottom","center","getElementGuidelines","isRefresh","prevValues","nextValues","added","removed","diff","removedElements","addedGuidelines","guideline","getTotalGuidelines","staticGuidelines","overflow","containerHeight","containerWidth","containerClientHeight","containerClientWidth","_e","_f","_g","_h","_j","getGridGuidelines","snapHorizontal","snapVertical","snapGridWidth","snapGridHeight","hide","checkMoveableSnapPoses","snapCenter","customSnapThreshold","checkSnapPoses","snapElement","options","vertical","checkSnap","horizontal","checkSnapKeepRatio","endPos","endY","startY","dx","dy","isBottom","isRight","verticalInfo","isSnap","horizontalInfo","verticalSnapInfo","horizontalSnapInfo","isVerticalSnap","verticalGuideline","getNearestSnapGuidelineInfo","isHorizontalSnap","horizontalGuideline","horizontalPos","verticalPos","endX","a","b","checkSnaps","isCenter","isSnapCenter","verticalNames","horizontalNames","snapInfo","posInfo","guidelineInfo","posInfos","targetType","posType","snapPosInfos","guidelineInfos","targetPos","snapPosInfo","getSnapInfosByDirection","snapDirection","alignPoses","checkSnapBoundPriority","aDist","bDist","getNearOffsetInfo","offsets","aSign","bSign","aOffset","bOffset","isBound","cx","line","cy","dot","test1","test2","centerSign","hitTestLine","dots","sign","bounds","isAllBound","isVerticalBound","isHorizontalBound","leftLine","topLine","rightLine","bottomLine","isHorizontalStart","isVerticalStart","isStartLine","isSameStartLine","topBoundInfo","checkLineBoundCollision","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isAllHorizontalBound","verticalOffset","horizontalOffset","dot1","dot2","boundDot1","boundLine","boundDot2","dy1","dx1","dy2","dx2","isRender","checkInnerBoundDot","threshold","getInnerBoundInfo","lines","multiple","checkInnerBound","sizeOffset","getInnerBoundDragInfo","innerBoundInfo","widthOffsetInfo","heightOffsetInfo","getCheckSnapLineDirections","keepRatio","lineDirections","getCheckInnerBoundLines","dir1","dir2","rad","checkRotateInnerBounds","prevPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","isBoundRotate","dotInfos","lineRad","solveReverseLine","lineDist","getDistPointLine","dotDist","dotRad","distRad","nextRad1","nextRad2","nextRad","checkInnerBoundPoses","innerBounds","horizontalPoses","verticalPoses","boundMap","checkBoundPoses","Infinity","nextBounds","checkBounds","getBounds","externalBounds","isCSS","checkBoundKeepRatio","startBoundPos","endBoundPos","minPos","maxPos","boundInfos","relativePoses","boundRect","boundRotate","boundPos","r","nextPos","checkRotateBounds","relativeRad1","DIRECTION_NAMES","groupByElementGuidelines","groupInfos","elementPos","groupInfo","find","groupElement","groupPos","getElementGuidelineDist","elementSize","targetSize","relativePos","renderGuideline","React","classNames","key","scaleDirection","renderInnerGuideline","renderElementGroups","clientSize","snapDigit","snapDistFormat","posName1","posName2","sizeName","isFirstRenderSize","linePos","lineSize","isRenderSize","snapSize","isDisplaySnapDigit","j","posValue","sizeValue","renderSnapPoses","snapPoses","renderPos","filterElementInnerGuidelines","targetSizes","targetContentPos","targetContentSize","nextGuidelines","isDisplayInnerSnapDigit","contentPos","inlinePos","inner","element1","size1","contentPos1","element2","size2","contentPos2","groupGuideline","renderGuidelines","renderGapGuidelines","absGap","snapStart","snapContainer","snapContainerTarget","snapContainerRect","offset1","offset2","hasGuidelines","ableName","snappable","enableSnap","solveEquation","isOutside","dist1","dist2","widthOffset","heightOffset","boundInfo","checkSnapBoundsKeepRatio","isRequest","horizontalBoundInfo","verticalBoundInfo","getSnapBoundOffset","horizontalDist","verticalDist","checkMoveableSnapBounds","horizontalBoundInfos","verticalBoundInfos","getSnapBound","snapIndex","snap","checkSnapBounds","guideines","checkMaxBounds","maxWidth","maxHeight","isCheckVertical","otherDirection","isCheckHorizontal","otherPos","nextOtherPos","isHeightOutside","solveNextOffset","isWidthOutside","snapBoundInfo","rad180","isHorizontalLine","isVerticalLine","startDirection","endDirection","otherStartPos","otherEndPos","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","snapLine","checkSnapRightLine","getCheckSnapDirections","getSizeOffsetInfo","getSnapBoundInfo","recheckSizeByTwoDirection","snapPos","nextWidthOffset","nextHeightOffset","nextWidth","nextHeight","checkSizeDist","getNextPoses","isWidthBound","isHeightBound","widthDist","heightDist","isGetWidthOffset","checkSnapRotate","checkSnapResize","getNextFixedPoses","checkSnapScale","sizeDist","startCheckSnapDrag","checkThrottleDragRotate","throttleDragRotate","offsetX","offsetY","adjustPoses","adjustPos","prevDistY","checkSnapDrag","verticalSnapBoundInfo","horizontalSnapBoundInfo","verticalInnerBoundInfo","horizontalInnerBoundInfo","guidelinePos","gapPos","aPos","bPos","gapSizes","gapGuideline","minSize","getGapGuidelinesToStart","getGapGuidelinesToEnd","verticalSnapPoses","horizontalSnapPoses","verticalInnerBoundPoses","horizontalInnerBoundPoses","innerPos","snapGap","Function","onSnap","css","render","snapRenderInfo","minLeft","minTop","containerPos","externalPoses","snapInfos","hasExternalPoses","externalRect","verticalPosInfos","horizontalPosInfos","getSnapGuidelines","addBoundGuidelines","gapHorizontalGuidelines","gapVerticalGuidelines","allGuidelines","elements","gaps","nextHorizontalGuidelines","elementHorizontalGroups","innerGapHorizontalGuidelines","nextVerticalGuidelines","elementVerticalGroups","innerGapVerticalGuidelines","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlStart","dragControl","dragControlEnd","dragGroupStart","dragGroup","dragGroupEnd","dragGroupControlStart","dragGroupControl","dragGroupControlEnd","throttleDrag","startDragRotate","edgeDraggable","Boolean","onDragStart","onDrag","onDragEnd","onDragGroupStart","onDragGroup","onDragGroupEnd","dragInfo","gesto","set","startRect","prevDist","prevBeforeDist","startValue","parentMoveable","dragRotateRad","ry","rx","beforeTranslate","throttleArray","beforeDist","beforeDelta","passDeltaX","passDeltaY","isControl","requestStart","requestEnd","renderDirectionControls","defaultDirections","renderPoses","radRotation","directionMap","renderDirections","degRotation","directionRotation","renderLine","renderAllDirections","renderDiagonalDirections","startAbsoluteOrigin","prevSnapDeg","startDeg","prevLoop","prevDeg","loop","absolutePrevSnapDeg","absoluteDeg","getDeg","getRotationPositions","radPoses","isReverse","rotationTarget","canPinch","rotatable","throttleRotate","Object","onRotateStart","onRotate","onRotateEnd","onRotateGroupStart","onRotateGroup","onRotateGroupEnd","positions","jsxs","setRotateStartInfo","externalRotate","rotatation","groupDelta","beforeInfo","afterInfo","absoluteInfo","isRotate","targetDirection","_l","absoluteStartDeg","parentDist","rotate","getParentDeg","beforeRotate","absoluteDelta","absoluteDist","absoluteRotate","getRotateInfo","inverseDist","inverseDelta","dragGroupControlCondition","parentLeft","parentTop","parentBeforeOrigin","child","childClient","prevX","prevY","rotateMatrix","distRotate","startRotation","ableGroup","resizable","throttleResize","onResizeStart","onResize","onResizeEnd","onResizeGroupStart","onResizeGroup","onResizeGroupEnd","edge","parentDirection","padding","minWidth","minHeight","isParentElement","containerStyle","convertUnitSize","ratio","isFinite","setRatio","setFixedDirection","startWidth","startHeight","setMin","setMax","maxSize","setOrigin","parentScale","parentKeepRatio","dragClient","isWidth","startOffsetWidth","startOffsetHeight","sizeDirection","distWidth","distHeight","standardRad","signSize","startWidthSize","startHeightSize","distSize","ratioRad","nextDirection","snapDist","isNoSnap","calculateBoundSize","offsetWidth","offsetHeight","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","originalEvents","originalX","originalY","createRotateMatrix","setDist","scalable","throttleScale","onScaleStart","onScale","onScaleEnd","onScaleGroupStart","onScaleGroup","onScaleGroupEnd","scaleWidth","scaleHeight","isScale","scaleXRatio","scaleYRatio","dragDist","distScaleWidth","distScaleHeight","dragRad","stateDirection","moveableScale","rad1","rad2","getTriangleRad","poses1","poses2","pi","warpable","Array","onWarpStart","onWarp","onWarpEnd","linePosFrom1","getMiddleLinePos","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","inputTarget","prevMatrix","isWarp","posIndexes","absolutePoses","selectedPoses","h","createWarpMatrix","afterMatrix","totalMatrix","AREA_PIECES","AREA_PIECE","AVOID","removeClass","dragArea","passDragArea","onClick","onClickGroup","ref","renderPieces","areaElement","rects","children","addClass","restoreStyle","enableNativeEvent","requestAnimationFrame","scrollContainer","scrollable","scrollThreshold","getScrollPosition","onScroll","onScrollGroup","dragScroll","scrollContainerElement","gestoName","checkScroll","getDefaultScrollPosition","dragGroupContro","dragGroupControEnd","dragTarget","portalContainer","pinchThreshold","pinchOutside","checkInput","cspNonce","translateZ","paddingDirections","paddingPos1","paddingPos2","paddingPos3","paddingPos4","RADIUS_DIRECTIONS","sumSize","sumRatio","HORIZONTAL_RADIUS_ORDER","VERTICAL_RADIUS_ORDER","HORIZONTAL_RADIUS_DIRECTIONS","VERTICAL_RADIUS_DIRECTIONS","getRadiusStyles","clipStyles","raws","rawPos","styles","getRadiusRange","horizontalRange","verticalRange","clipPose","getRadiusValues","splitIndex","splitLength","horizontalValues","verticalValues","nwValue","neValue","_k","wnValue","_m","enValue","horizontalRawPoses","verticalRawPoses","calculateRatio","nextHorizontalPoses","minCounts","nextVerticalPoses","raw","removeRadiusPos","startIndex","radiuslIndex","deleteCount","addRadiusPos","horizontalIndex","verticalIndex","radiusX","radiusY","startVerticalIndex","splitRadiusPoses","horizontals","verticals","CLIP_DIRECTIONS","CLIP_RECT_DIRECTIONS","clipType","clipPoses","isCircle","subWidth","subHeight","xs","ys","dirx","diry","clipText","clipPath","clipPrefix","splitter","splitComma","xPos","yPos","radiusX_1","radiusY_1","radius","xRadius","yRadius","centerPos_1","roundIndex","rectLength","radiusValues","_o","_p","nextRight","nextBottom","radiusPoses","getRectPoses","getClipStyles","clipEventType","clipStyle","clippable","defaultClipPath","customClipPath","clipRelative","clipArea","dragWithClip","clipTargetBounds","clipVerticalGuidelines","clipHorizontalGuidelines","clipSnapThreshold","onClipStart","onClip","onClipEnd","clipPathState","snapBoundInfos","getClipPath","calculatedPos","controls","isInset","isPolygon","linePoses_1","from","clipLeft","clipTop","ellipseClipPath","piece","areaPoses","allWidth","allHeight","allLeft_1","allTop_1","directionType","snapPos1","snapPos2","draggableData","isLine","isArea","isDragWithTarget","isAll","guidePoses","isEllipse","guideRect","guideXPoses","guideYPoses","rectPoses","rectDists_1","snapOffsetY","snapOffsetX","distSnapX","distSnapY","nextClipStyles","isClipStart","removeClipPath","addClipPath","originDraggable","originRelative","onDragOriginStart","onDragOrigin","onDragOriginEnd","distOrigin","nextRect","dragDelta","horizontalsLength","verticalsLength","lineIndex","borderRadius","roundable","roundRelative","minRoundControls","maxRoundControls","roundClickable","onRoundStart","onRound","onRoundEnd","borderRadiusState","getBorderRadius","verticalCount","horizontalCount","isDisplay","display","controlIndex","selectedControlPose","selectedVertical","selectedHorizontal","pose","poseDist","triggerRoundEvent","addBorderRadius","onBeforeRenderStart","onBeforeRender","onBeforeRenderEnd","onBeforeRenderGroupStart","onBeforeRenderGroup","onBeforeRenderGroupEnd","cssMatrix","resetTransform","fillDragStartParams","fillDragParams","_this","onRenderStart","onRender","onRenderEnd","onRenderGroupStart","onRenderGroup","onRenderGroupEnd","triggerAble","ableType","eventOperation","eventAffix","eventType","requestInstant","conditionName","isFirstStart","BeforeRenderable","requestAble_1","results","nextDatas","isUpdate","isForceEnd","getTargetAbleGesto","moveableTarget","controlBox","startFunc","eventTarget","getAbleGesto","conditionFunctions","__extends","MoveableManager","wrapperMoveable","parentPosition","cssStyled","customStyledMap","disableNativeEvent","propsTarget","ControlBoxElement","stateTarget","groupTargets","isDragging","ableAttributes","Renderer","createElement","onPreventClick","manager","points","fitPoints","getOverlapSize","totalSize","getAreaSize","isInside","prevTarget","prevProps","prevDragArea","isTargetChanged","useDragArea","eventKeys","getKeys","hasAbles","controlBoxElement","hasTargetAble","hasControlAble","isUnset","statePos","requsetAble","ableRequester","isInstant","param","requester","requestAble","stateLeft","stateTop","stateContainer","isChanged","customStyleMap","tag","styled","removeEvent","targetAbles","controlAbles","nextState","defaultGroupRotate","defaultGroupOrigin","refs","always","addEvent","containsTarget","isTarget","targetIndex","endEvent","getDraggableEvent","individualGroupable","MOVEABLE_ABLES","MOVEABLE_EVENTS_PROPS_MAP","current","MOVEABLE_PROPS_MAP","MOVEABLE_EVENTS_MAP","MOVEABLE_EVENTS","MOVEABLE_PROPS","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","a2_1","b1MinMax_1","b2MinMax_1","b1","b2","rotatePoses","getMaxPos","getMinPos","changedWidth","MoveableGroup","defaultProps","nextTarget","isContainerChanged","changed","getGroupRect","_super","InitialMoveable","cssMap","prefixCSS","Default","Groupable","IndividualGroupable","DragArea","withMethods","__decorate","moveableContructor","userAbles","userProps","refTargets","isGroup","totalAbles","nextProps","defaultStyled","isReset","nextSelectorMap","Moveable","makeMoveable"],"mappings":"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","sourcesContent":["import { Able, DefaultProps } from \"../types\";\n\nexport function makeAble<\n    Name extends string,\n    AbleObject extends Partial<Able<any, any>>,\n    Props extends DefaultProps<Name, AbleObject>,\n>(name: Name, able: AbleObject) {\n    return {\n        events: {} as const,\n        props: {\n            [name]: Boolean,\n        } as Props,\n        name,\n        ...able,\n    } as const;\n}\n","import getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableInterface } from \"./types\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    let defaultCursor = \"ns-resize\";\n\n    if (degree45 === 135) {\n        defaultCursor = \"nwse-resize\";\n    } else if (degree45 === 45) {\n        defaultCursor = \"nesw-resize\";\n    } else if (degree45 === 90) {\n        defaultCursor = \"ew-resize\";\n    }\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};cursor: -webkit-image-set(url('${x1}') 1x, url('${x2}') 2x) 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const IS_WEBKIT = agent.browser.webkit;\nexport const IS_WEBKIT605 = IS_WEBKIT && (() => {\n    const res = /applewebkit\\/([^\\s]+)/g.exec(navigator.userAgent.toLowerCase());\n\n    return res ? parseFloat(res[1]) < 605 : false;\n})();\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = `\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"] {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n${IS_WEBKIT605 ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`;\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const FLOAT_POINT_NUM = 0.0001;\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    s: [2, 3],\n    w: [2, 0],\n    e: [1, 3],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n\nexport const MOVEABLE_METHODS: Array<keyof MoveableInterface> = [\n    \"isMoveableElement\",\n    \"updateRect\",\n    \"updateTarget\",\n    \"destroy\",\n    \"dragStart\",\n    \"isInside\",\n    \"hitTest\",\n    \"setState\",\n    \"getRect\",\n    \"request\",\n    \"isDragging\",\n    \"getManager\",\n];\n","import { PREFIX, IS_WEBKIT605, TINY_NUM, IS_WEBKIT } from \"./consts\";\nimport { prefixNames, InvertObject } from \"framework-utils\";\nimport {\n    splitBracket, isUndefined, isObject, splitUnit,\n    IObject, hasClass, isArray, isString, getRad,\n    getShapeDirection, isFunction,\n} from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, calculate,\n    multiplies,\n    minus,\n    getOrigin,\n    createScaleMatrix,\n    plus,\n    ignoreDimension,\n    convertCSStoMatrix,\n    convertMatrixtoCSS,\n} from \"@scena/matrix\";\nimport {\n    MoveableManagerState, Able, MoveableClientRect,\n    MoveableProps, ControlPose, ArrayFormat, MoveableRefType,\n    MatrixInfo, ExcludeEndParams, ExcludeParams,\n} from \"./types\";\nimport { parse, toMat, calculateMatrixDist } from \"css-to-mat\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    const value = splitBracket(transform).value!;\n    return value.split(/s*,\\s*/g).map(v => parseFloat(v));\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = getSVGViewBox(el.ownerSVGElement!);\n\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent ? el : el.parentElement;\n    let isEnd = el === lastParent || target === lastParent;\n    let position = \"relative\";\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const transform = style.transform;\n        position = style.position!;\n\n        if (target.tagName.toLowerCase() === \"svg\" || position !== \"static\" || (transform && transform !== \"none\")) {\n            break;\n        }\n        target = target.parentElement;\n        position = \"relative\";\n    }\n    return {\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function getOffsetPosInfo(\n    el: HTMLElement | SVGElement,\n    container: SVGElement | HTMLElement | null | undefined,\n    style: CSSStyleDeclaration,\n    isFixed: boolean,\n) {\n    const tagName = el.tagName.toLowerCase();\n    let offsetLeft = (el as HTMLElement).offsetLeft;\n    let offsetTop = (el as HTMLElement).offsetTop;\n\n    if (isFixed) {\n        const containerClientRect = (container || document.documentElement).getBoundingClientRect();\n\n        offsetLeft -= containerClientRect.left;\n        offsetTop -= containerClientRect.top;\n    }\n    // svg\n    const isSVG = isUndefined(offsetLeft);\n    let hasOffset = !isSVG;\n    let origin: number[];\n    let targetOrigin: number[];\n    // inner svg element\n    if (!hasOffset && tagName !== \"svg\") {\n        origin = IS_WEBKIT605\n            ? getBeforeTransformOrigin(el as SVGElement)\n            : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n        targetOrigin = origin.slice();\n        hasOffset = true;\n\n        [\n            offsetLeft, offsetTop, origin[0], origin[1],\n        ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n    } else {\n        origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        targetOrigin = origin.slice();\n    }\n    return {\n        tagName,\n        isSVG,\n        hasOffset,\n        offset: [offsetLeft || 0, offsetTop || 0],\n        origin,\n        targetOrigin,\n    };\n}\nexport function getBodyOffset(\n    el: HTMLElement | SVGElement,\n    isSVG: boolean,\n    style: CSSStyleDeclaration = getComputedStyle(el),\n) {\n    const bodyStyle = getComputedStyle(document.body);\n    const bodyPosition = bodyStyle.position;\n    if (!isSVG && (!bodyPosition || bodyPosition === \"static\")) {\n        return [0, 0];\n    }\n\n    let marginLeft = parseInt(bodyStyle.marginLeft, 10);\n    let marginTop = parseInt(bodyStyle.marginTop, 10);\n\n    if (style.position === \"absolute\") {\n        if (style.top !== \"auto\" || style.bottom !== \"auto\") {\n            marginTop = 0;\n        }\n        if (style.left !== \"auto\" || style.right !== \"auto\") {\n            marginLeft = 0;\n        }\n    }\n\n    return [marginLeft, marginTop];\n}\nexport function convert3DMatrixes(matrixes: MatrixInfo[]) {\n    matrixes.forEach(info => {\n        const matrix = info.matrix;\n\n        if (matrix) {\n            info.matrix = convertDimension(matrix, 3, 4);\n        }\n    });\n}\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    // prevMatrix?: number[],\n) {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: MatrixInfo[] = [];\n    let isEnd =  target === container;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetTransformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    const offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    // if (prevMatrix) {\n    //     isEnd = target === container;\n    //     if (prevMatrix.length > 10) {\n    //         is3d = true;\n    //         n = 4;\n    //     }\n    //     container = target.parentElement;\n    // }\n\n    while (el && !isEnd) {\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const position = style.position;\n        const isFixed = position === \"fixed\";\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(style.transform!));\n\n        // convert 3 to 4\n        const length = matrix.length;\n        if (!is3d && length === 16) {\n            is3d = true;\n            n = 4;\n\n            convert3DMatrixes(matrixes);\n        }\n        if (is3d && length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            tagName,\n            hasOffset,\n            isSVG,\n            origin,\n            targetOrigin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, container, style, isFixed);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n        if (tagName === \"svg\" && targetMatrix) {\n            // scale matrix for svg's SVGElements.\n            matrixes.push({\n                type: \"target\",\n                target: el,\n                matrix: getSVGMatrix(el as SVGSVGElement, n),\n            });\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createIdentityMatrix(n),\n            });\n        } else if (tagName === \"g\" && target !== el) {\n            offsetLeft = 0;\n            offsetTop = 0;\n        }\n        const {\n            offsetParent,\n            isEnd: isOffsetEnd,\n            isStatic,\n        } = getOffsetInfo(el, container);\n\n        if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === \"relative\" || position === \"static\")) {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            isEnd = isEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n\n        if (hasOffset && offsetContainer !== offsetParent) {\n            // border\n            parentClientLeft = offsetParent.clientLeft;\n            parentClientTop = offsetParent.clientTop;\n        }\n        if (hasOffset && offsetParent === document.body) {\n            const margin = getBodyOffset(el, false, style);\n            offsetLeft += margin[0];\n            offsetTop += margin[1];\n        }\n        matrixes.push({\n            type: \"target\",\n            target: el,\n            matrix: getAbsoluteMatrix(matrix, n, origin),\n        });\n        if (hasOffset) {\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createOriginMatrix([\n                    offsetLeft - el.scrollLeft + parentClientLeft,\n                    offsetTop - el.scrollTop + parentClientTop,\n                ], n),\n            });\n        } else {\n            // svg\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                origin,\n            });\n        }\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (!targetTransformOrigin) {\n            targetTransformOrigin = targetOrigin;\n        }\n\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            isEnd = isOffsetEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    if (!targetTransformOrigin) {\n        targetTransformOrigin = [0, 0];\n    }\n\n    return {\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        targetOrigin: targetTransformOrigin,\n        is3d,\n    };\n}\nexport function calculateElementInfo(\n    target?: SVGElement | HTMLElement | null,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: HTMLElement | SVGElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n    // state?: Partial<MoveableManagerState> | false,\n) {\n    // const prevMatrix = state ? state.beforeMatrix : undefined;\n    // const prevRootMatrix = state ? state.rootMatrix : undefined;\n    // const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n    let width = 0;\n    let height = 0;\n    let rotation = 0;\n    let allResult: {} = {};\n\n    if (target) {\n        const style = getComputedStyle(target);\n\n        width = (target as HTMLElement).offsetWidth;\n        height = (target as HTMLElement).offsetHeight;\n\n        if (isUndefined(width)) {\n            [width, height] = getSize(target, style, true);\n        }\n    }\n\n    if (target) {\n        const result = calculateMatrixStack(\n            target, container, rootContainer, isAbsolute3d,\n            // prevMatrix, prevRootMatrix, prevN,\n        );\n        const position = calculateMoveablePosition(\n            result.allMatrix,\n            result.transformOrigin,\n            width, height,\n        );\n        allResult = {\n            ...result,\n            ...position,\n        };\n        const rotationPosition = calculateMoveablePosition(\n            result.allMatrix, [50, 50], 100, 100,\n        );\n        rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);\n    }\n    const n = isAbsolute3d ? 4 : 3;\n    return {\n        width,\n        height,\n        rotation,\n        // rootMatrix: number[];\n        // beforeMatrix: number[];\n        // offsetMatrix: number[];\n        // allMatrix: number[];\n        // targetMatrix: number[];\n        // targetTransform: string;\n        // transformOrigin: number[];\n        // targetOrigin: number[];\n        // is3d: boolean;\n        rootMatrix: createIdentityMatrix(n),\n        beforeMatrix: createIdentityMatrix(n),\n        offsetMatrix: createIdentityMatrix(n),\n        allMatrix: createIdentityMatrix(n),\n        targetMatrix: createIdentityMatrix(n),\n        targetTransform: \"\",\n        transformOrigin: [0, 0],\n        targetOrigin: [0, 0],\n        is3d: !!isAbsolute3d,\n        // left: number;\n        // top: number;\n        // right: number;\n        // bottom: number;\n        // origin: number[];\n        // pos1: number[];\n        // pos2: number[];\n        // pos3: number[];\n        // pos4: number[];\n        // direction: 1 | -1;\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        direction: 1,\n        ...allResult,\n    };\n}\nexport function getElementInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n) {\n    return calculateElementInfo(target, container, rootContainer, true);\n}\nexport function calculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n    // prevMatrix?: number[],\n    // prevRootMatrix?: number[],\n    // prevN?: number,\n) {\n    const {\n        matrixes,\n        is3d,\n        targetMatrix: prevTargetMatrix,\n        transformOrigin,\n        targetOrigin,\n        offsetContainer,\n    } = getMatrixStackInfo(target, container); // prevMatrix\n    const {\n        matrixes: rootMatrixes,\n        is3d: isRoot3d,\n    } = getMatrixStackInfo(offsetContainer, rootContainer); // prevRootMatrix\n\n    // if (rootContainer === document.body) {\n    //     console.log(offsetContainer, rootContainer, rootMatrixes);\n    // }\n    const isNext3d = isAbsolute3d || isRoot3d || is3d;\n    const n = isNext3d ? 4 : 3;\n    const isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    let targetMatrix = prevTargetMatrix;\n    // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let allMatrix = createIdentityMatrix(n);\n    let rootMatrix = createIdentityMatrix(n);\n    let beforeMatrix = createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n    const originalRootContainer = rootContainer || document.body;\n    const endContainer = getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;\n\n    rootMatrixes.reverse();\n    matrixes.reverse();\n\n    if (!is3d && isNext3d) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n\n        convert3DMatrixes(matrixes);\n    }\n    if (!isRoot3d && isNext3d) {\n        convert3DMatrixes(rootMatrixes);\n    }\n\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n    // if (!prevRootMatrix) {\n    rootMatrixes.forEach(info => {\n        rootMatrix = multiply(rootMatrix, info.matrix!, n);\n    });\n    // }\n    matrixes.forEach((info, i) => {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n\n        // calculate for SVGElement\n        if (!info.matrix) {\n            const nextInfo = matrixes[i + 1];\n            const offset = getSVGOffset(\n                info,\n                nextInfo,\n                endContainer,\n                n,\n                multiply(rootMatrix, allMatrix, n),\n            );\n            info.matrix = createOriginMatrix(offset, n);\n        }\n        allMatrix = multiply(allMatrix, info.matrix!, n);\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n    }\n    const targetTransform = makeMatrixCSS(\n        isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix,\n        isMatrix3d,\n    );\n\n    rootMatrix = ignoreDimension(rootMatrix, n, n);\n\n    return {\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        allMatrix,\n        targetMatrix,\n        targetTransform,\n        transformOrigin,\n        targetOrigin,\n        is3d: isNext3d,\n    };\n}\nexport function makeMatrixCSS(matrix: number[], is3d: boolean = matrix.length > 9) {\n    return `${is3d ? \"matrix3d\" : \"matrix\"}(${convertMatrixtoCSS(matrix, !is3d).join(\",\")})`;\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n\n    if (!el) {\n        return { x: 0, y: 0, width: 0, height: 0, clientWidth, clientHeight };\n    }\n    const viewBox = el.viewBox;\n    const baseVal = (viewBox && viewBox.baseVal) || { x: 0, y: 0, width: 0, height: 0 };\n\n    return {\n        x: baseVal.x,\n        y: baseVal.y,\n        width: baseVal.width || clientWidth,\n        height: baseVal.height || clientHeight,\n        clientWidth,\n        clientHeight,\n    };\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const {\n        width: viewBoxWidth,\n        height: viewBoxHeight,\n        clientWidth,\n        clientHeight,\n    } = getSVGViewBox(el);\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n * (n - 1)],\n        scaleMatrix[n * (n - 1) + 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox) {\n        return [0, 0];\n    }\n    const bbox = el.getBBox();\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function calculatePosition(matrix: number[], pos: number[], n: number) {\n    return calculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function calculatePoses(matrix: number[], width: number, height: number, n: number) {\n    return [[0, 0], [width, 0], [0, height], [width, height]].map(pos => calculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function calculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = calculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    offsetInfo: MatrixInfo,\n    targetInfo: MatrixInfo,\n    container: HTMLElement | SVGElement,\n    n: number,\n    beforeMatrix: number[],\n) {\n    const target = offsetInfo.target;\n    const origin = offsetInfo.origin!;\n    const targetMatrix = targetInfo.matrix!;\n    const [width, height] = getSize(target, undefined, true);\n    const containerClientRect = container.getBoundingClientRect();\n    let margin = [0, 0];\n\n    if (container === document.body) {\n        margin = getBodyOffset(target, true);\n    }\n\n    const rect = target.getBoundingClientRect();\n    const rectLeft\n        = rect.left - containerClientRect.left + container.scrollLeft\n        - (container.clientLeft || 0) + margin[0];\n    const rectTop\n        = rect.top - containerClientRect.top + container.scrollTop\n        - (container.clientTop || 0) + margin[1];\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        targetMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = calculateRect(mat, width, height, n);\n    const posOrigin = calculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            calculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            calculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            targetMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = calculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\nexport function calculateMoveablePosition(matrix: number[], origin: number[], width: number, height: number) {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    const poses = calculatePoses(matrix, width, height, n);\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = poses;\n    let [originX, originY] = calculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const direction = getShapeDirection(poses);\n\n    return {\n        left,\n        top,\n        right,\n        bottom,\n        origin: [originX, originY],\n        pos1: [x1, y1],\n        pos2: [x2, y2],\n        pos3: [x3, y3],\n        pos4: [x4, y4],\n        direction,\n    };\n}\nexport function getDistSize(vec: number[]) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], zoom = 1, rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, zoom: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translateZ(0px) translate(${x}px, ${y}px) rotate(${rotation}rad) scale(${zoom})`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\nexport function getSize(\n    target: SVGElement | HTMLElement,\n    style: CSSStyleDeclaration = getComputedStyle(target),\n    isOffset?: boolean,\n    isBoxSizing: boolean = isOffset || style.boxSizing === \"border-box\",\n) {\n    let width = (target as HTMLElement).offsetWidth;\n    let height = (target as HTMLElement).offsetHeight;\n    const hasOffset = !isUndefined(width);\n\n    if ((isOffset || isBoxSizing) && hasOffset) {\n        return [width, height];\n    }\n    if (!hasOffset && target.tagName.toLowerCase() !== \"svg\") {\n        const bbox = (target as SVGGraphicsElement).getBBox();\n        return [bbox.width, bbox.height];\n    }\n\n    width = target.clientWidth;\n    height = target.clientHeight;\n\n    if (isOffset || isBoxSizing) {\n        const borderLeft = parseFloat(style.borderLeftWidth!) || 0;\n        const borderRight = parseFloat(style.borderRightWidth!) || 0;\n        const borderTop = parseFloat(style.borderTopWidth!) || 0;\n        const borderBottom = parseFloat(style.borderBottomWidth!) || 0;\n\n        return [\n            width + borderLeft + borderRight,\n            height + borderTop + borderBottom,\n        ];\n    } else {\n        const paddingLeft = parseFloat(style.paddingLeft!) || 0;\n        const paddingRight = parseFloat(style.paddingRight!) || 0;\n        const paddingTop = parseFloat(style.paddingTop!) || 0;\n        const paddingBottom = parseFloat(style.paddingBottom!) || 0;\n\n        return [\n            width - paddingLeft - paddingRight,\n            height - paddingTop - paddingBottom,\n        ];\n    }\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nexport function getTargetInfo(\n    moveableElement?: HTMLElement | null,\n    target?: HTMLElement | SVGElement | null,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    // state?: Partial<MoveableManagerState> | false | undefined,\n) {\n    let beforeDirection: 1 | -1 = 1;\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let moveableClientRect = resetClientRect();\n\n    const result = calculateElementInfo(\n        target, container!, rootContainer!, false,\n        // state,\n    );\n    if (target) {\n        const n = result.is3d ? 4 : 3;\n        const beforePosition = calculateMoveablePosition(\n            result.offsetMatrix,\n            plus(result.transformOrigin, getOrigin(result.targetMatrix, n)),\n            result.width, result.height,\n        );\n        beforeDirection = beforePosition.direction;\n        beforeOrigin = plus(\n            beforePosition.origin,\n            [beforePosition.left - result.left, beforePosition.top - result.top],\n        );\n\n        targetClientRect = getClientRect(target);\n        containerClientRect = getClientRect(\n            getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body,\n            true,\n        );\n        if (moveableElement) {\n            moveableClientRect = getClientRect(moveableElement);\n        }\n    }\n\n    return {\n        targetClientRect,\n        containerClientRect,\n        moveableClientRect,\n        beforeDirection,\n        beforeOrigin,\n        originalBeforeOrigin: beforeOrigin,\n        target,\n        ...result,\n    };\n}\nexport function resetClientRect(): MoveableClientRect {\n    return {\n        left: 0, right: 0,\n        top: 0, bottom: 0,\n        width: 0, height: 0,\n        clientLeft: 0, clientTop: 0,\n        clientWidth: 0, clientHeight: 0,\n        scrollWidth: 0, scrollHeight: 0,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement, isExtends?: boolean) {\n    let left = 0;\n    let top = 0;\n    let width = 0;\n    let height = 0;\n\n    if (el === document.body || el === document.documentElement) {\n        width = window.innerWidth;\n        height = window.innerHeight;\n        left = -(document.documentElement.scrollLeft || document.body.scrollLeft);\n        top = -(document.documentElement.scrollTop || document.body.scrollTop);\n    } else {\n        const clientRect = el.getBoundingClientRect();\n\n        left = clientRect.left;\n        top = clientRect.top;\n        width = clientRect.width;\n        height = clientRect.height;\n    }\n\n    const rect: MoveableClientRect = {\n        left,\n        right: left + width,\n        top,\n        bottom: top + height,\n        width,\n        height,\n    };\n\n    if (isExtends) {\n        rect.clientLeft = el.clientLeft;\n        rect.clientTop = el.clientTop;\n        rect.clientWidth = el.clientWidth;\n        rect.clientHeight = el.clientHeight;\n        rect.scrollWidth = el.scrollWidth;\n        rect.scrollHeight = el.scrollHeight;\n        rect.overflow = getComputedStyle(el).overflow !== \"visible\";\n    }\n    return rect;\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\nexport function unset(self: any, name: string) {\n    if (self[name]) {\n        self[name].unset();\n        self[name] = null;\n    }\n}\n\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: ExcludeParams<T>,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    const nextParams = {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        moveable,\n        datas: datas.datas,\n    } as any;\n\n    if (datas.isStartEvent) {\n        datas.lastEvent = nextParams;\n    } else {\n        datas.isStartEvent = true;\n    }\n    return nextParams;\n}\nexport function fillEndParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: ExcludeEndParams<T> & { isDrag?: boolean },\n): T {\n    const datas = e.datas;\n    const isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n\n    return {\n        isDrag,\n        ...params,\n        moveable,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        lastEvent: datas.lastEvent,\n        isDouble: e.isDouble,\n        datas: datas.datas,\n    } as any;\n}\n\nexport function triggerEvent<T extends IObject<any> = MoveableProps, U extends keyof T = string>(\n    moveable: any,\n    name: U,\n    params: T[U] extends ((e: infer P) => any) | undefined ? P : IObject<any>,\n    isManager?: boolean,\n): any {\n    return moveable.triggerEvent(name, params, isManager);\n}\n\nexport function getComputedStyle(el: Element, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n    ables: Able[], methods: Array<keyof Able>,\n    triggerAblesSimultaneously?: boolean,\n) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (!triggerAblesSimultaneously && able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => any) {\n    const groups: T[][] = [];\n    const groupKeys: any[] = [];\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        const keyIndex = groupKeys.indexOf(groupKey);\n        const group = groups[keyIndex] || [];\n\n        if (keyIndex === -1) {\n            groupKeys.push(groupKey);\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function groupByMap<T>(arr: T[], func: (el: T, index: number, arr: T[]) => string | number) {\n    const groups: T[][] = [];\n    const groupKeys: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        let group = groupKeys[groupKey];\n\n        if (!group) {\n            group = [];\n            groupKeys[groupKey] = group;\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n    return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(b) - Math.abs(a));\n\n    return args[0];\n}\nexport function minOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    return args[0];\n}\n\nexport function calculateInversePosition(matrix: number[], pos: number[], n: number) {\n    return calculate(\n        invert(matrix, n),\n        convertPositionMatrix(pos, n),\n        n,\n    );\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n    const {\n        is3d,\n        rootMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n    [\n        e.distX, e.distY,\n    ] = calculateInversePosition(rootMatrix, [e.distX, e.distY], n);\n\n    return e;\n}\n\nexport function calculatePadding(\n    matrix: number[], pos: number[],\n    transformOrigin: number[], origin: number[], n: number,\n) {\n    return minus(calculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\n\nexport function convertCSSSize(value: number, size: number, isRelative?: boolean) {\n    return isRelative ? `${value / size * 100}%` : `${value}px`;\n}\n\nexport function moveControlPos(\n    controlPoses: ControlPose[],\n    index: number,\n    dist: number[],\n    isRect?: boolean,\n) {\n    const { direction, sub } = controlPoses[index];\n    const dists = controlPoses.map(() => [0, 0]);\n    const directions = direction ? direction.split(\"\") : [];\n\n    if (isRect && index < 8) {\n        const verticalDirection = directions.filter(dir => dir === \"w\" || dir === \"e\")[0];\n        const horizontalDirection = directions.filter(dir => dir === \"n\" || dir === \"s\")[0];\n\n        dists[index] = dist;\n        controlPoses.forEach((controlPose, i) => {\n            const {\n                direction: controlDir,\n            } = controlPose;\n\n            if (!controlDir) {\n                return;\n            }\n            if (controlDir.indexOf(verticalDirection) > -1) {\n                dists[i][0] = dist[0];\n            }\n            if (controlDir.indexOf(horizontalDirection) > -1) {\n                dists[i][1] = dist[1];\n            }\n        });\n        if (verticalDirection) {\n            dists[1][0] = dist[0] / 2;\n            dists[5][0] = dist[0] / 2;\n        }\n        if (horizontalDirection) {\n            dists[3][1] = dist[1] / 2;\n            dists[7][1] = dist[1] / 2;\n        }\n    } else if (direction && !sub) {\n        directions.forEach(dir => {\n            const isVertical = dir === \"n\" || dir === \"s\";\n\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: dirDir,\n                    horizontal: dirHorizontal,\n                    vertical: dirVertical,\n                } = controlPose;\n\n                if (!dirDir || dirDir.indexOf(dir) === -1) {\n                    return;\n                }\n                dists[i] = [\n                    isVertical || !dirHorizontal ? 0 : dist[0],\n                    !isVertical || !dirVertical ? 0 : dist[1],\n                ];\n            });\n        });\n    } else {\n        dists[index] = dist;\n    }\n\n    return dists;\n}\n\nexport function getTinyDist(v: number) {\n    return Math.abs(v) <= TINY_NUM ? 0 : v;\n}\n\nexport function directionCondition(moveable: any, e: any) {\n    if (e.isRequest) {\n        if (e.requestAble === \"resizable\" || e.requestAble === \"scalable\") {\n            return e.parentDirection!;\n        } else {\n            return false;\n        }\n    }\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n}\n\nexport function invertObject<T extends IObject<any>>(obj: T): InvertObject<T> {\n    const nextObj: IObject<any> = {};\n\n    for (const name in obj) {\n        nextObj[obj[name]] = name;\n    }\n    return nextObj as any;\n}\n\nexport function getTransform(transforms: string[], index: number) {\n    const beforeFunctionTexts = transforms.slice(0, index < 0 ? undefined : index);\n    const beforeFunctionTexts2 = transforms.slice(0, index < 0 ? undefined : index + 1);\n    const targetFunctionText = transforms[index] || \"\";\n    const afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n    const afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n\n    const beforeFunctions = parse(beforeFunctionTexts);\n    const beforeFunctions2 = parse(beforeFunctionTexts2);\n    const targetFunctions = parse([targetFunctionText]);\n    const afterFunctions = parse(afterFunctionTexts);\n    const afterFunctions2 = parse(afterFunctionTexts2);\n\n\n    const beforeFunctionMatrix = toMat(beforeFunctions);\n    const beforeFunctionMatrix2 = toMat(beforeFunctions2);\n    const afterFunctionMatrix = toMat(afterFunctions);\n    const afterFunctionMatrix2 = toMat(afterFunctions2);\n    const allFunctionMatrix = multiply(\n        beforeFunctionMatrix,\n        afterFunctionMatrix,\n        4,\n    );\n    return {\n        transforms,\n        beforeFunctionMatrix,\n        beforeFunctionMatrix2,\n        targetFunctionMatrix: toMat(targetFunctions),\n        afterFunctionMatrix,\n        afterFunctionMatrix2,\n        allFunctionMatrix,\n        beforeFunctions,\n        beforeFunctions2,\n        targetFunction: targetFunctions[0],\n        afterFunctions,\n        afterFunctions2,\n        beforeFunctionTexts,\n        beforeFunctionTexts2,\n        targetFunctionText,\n        afterFunctionTexts,\n        afterFunctionTexts2,\n    };\n}\n\nexport function isArrayFormat<T = any>(arr: any): arr is ArrayFormat<T> {\n    if (!arr || !isObject(arr)) {\n        return false;\n    }\n    return isArray(arr) || \"length\" in arr;\n}\n\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>, isSelector: true): T | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>, isSelector?: boolean): T | string | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n    target: MoveableRefType<T>,\n    isSelector?: boolean,\n): any {\n    if (!target) {\n        return null;\n    }\n    if (isString(target)) {\n        if (isSelector) {\n            return document.querySelector(target);\n        }\n        return target;\n    }\n    if (isFunction(target)) {\n        return target();\n    }\n    if (\"current\" in target) {\n        return target.current;\n    }\n    return target;\n}\n\nexport function getRefTargets(\n    targets: MoveableRefType | ArrayFormat<MoveableRefType>,\n    isSelector: true): Array<HTMLElement | SVGElement | null>;\nexport function getRefTargets(\n    targets: MoveableRefType | ArrayFormat<MoveableRefType>,\n    isSelector?: boolean): Array<HTMLElement | SVGElement | string | null>;\nexport function getRefTargets(targets: MoveableRefType | ArrayFormat<MoveableRefType>, isSelector?: boolean) {\n    if (!targets) {\n        return [];\n    }\n    const userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];\n\n    return userTargets.reduce((prev, target) => {\n        if (isString(target) && isSelector) {\n            return [...prev, ...[].slice.call(document.querySelectorAll<HTMLElement>(target))];\n        }\n        prev.push(getRefTarget(target, isSelector));\n        return prev;\n    }, [] as Array<SVGElement | HTMLElement | string | null | undefined>);\n}\n\nexport function getElementTargets(\n    targets: Array<SVGElement | HTMLElement | string | null | undefined>,\n    selectorMap: IObject<Array<HTMLElement | SVGElement>>,\n) {\n    const elementTargets: Array<SVGElement | HTMLElement> = [];\n    targets.forEach(target => {\n        if (!target) {\n            return;\n        }\n        if (isString(target)) {\n            if (selectorMap[target]) {\n                elementTargets.push(...selectorMap[target]);\n            }\n            return;\n        }\n        elementTargets.push(target);\n    });\n\n    return elementTargets;\n}\n\nexport function minmax(...values: number[]) {\n    return [Math.min(...values), Math.max(...values)];\n}\n\n\nexport function getAbsoluteRotation(pos1: number[], pos2: number[], direction: number) {\n    let deg = getRad(pos1, pos2) / Math.PI * 180;\n\n    deg = direction >= 0 ? deg : 180 - deg;\n    deg = deg >= 0 ? deg : 360 + deg;\n\n    return deg;\n}\n\n\nexport function getDragDistByState(state: MoveableManagerState, dist: number[]) {\n    const {\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    let inverseMatrix = invert(rootMatrix, n);\n\n    if (!is3d) {\n        inverseMatrix = convertDimension(inverseMatrix, 3, 4);\n    }\n    inverseMatrix[12] = 0;\n    inverseMatrix[13] = 0;\n    inverseMatrix[14] = 0;\n\n    return calculateMatrixDist(inverseMatrix, dist);\n}\n","import { makeAble } from \"./AbleManager\";\nimport { triggerEvent, fillParams, fillEndParams } from \"../utils\";\nimport {\n    PinchableProps, Able, SnappableState,\n    OnPinchStart, OnPinch, OnPinchEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\n\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\nexport default makeAble(\"pinchable\", {\n    events: {\n        onPinchStart: \"pinchStart\",\n        onPinch: \"pinch\",\n        onPinchEnd: \"pinchEnd\",\n        onPinchGroupStart: \"pinchGroupStart\",\n        onPinchGroup: \"pinchGroup\",\n        onPinchGroupEnd: \"pinchGroupEnd\",\n    } as const,\n    dragStart() {\n        return true;\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, targets, angle, originalDatas } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        pinchAbles.forEach(able => {\n            originalDatas[able.name] = originalDatas[able.name] || {};\n\n            if (!able[controlEventName]) {\n                return;\n            }\n            const ableEvent: any = {\n                ...e,\n                datas: originalDatas[able.name],\n                parentRotate: angle,\n                isPinch: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const {\n            datas, scale: pinchScale, distance,\n            originalDatas,\n            inputEvent, targets,\n            angle,\n        } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                datas: originalDatas[able.name],\n                inputEvent,\n                parentDistance,\n                parentRotate: angle,\n                isPinch: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, isPinch, inputEvent, targets, originalDatas } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillEndParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                isDrag: isPinch,\n                datas: originalDatas[able.name],\n                inputEvent,\n                isPinch: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        return this.pinchStart!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.pinch!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.pinchEnd!(moveable, { ...e, targets: moveable.props.targets });\n    },\n});\n\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n","import { MoveableManagerState, OnCustomDrag } from \"../types\";\nimport { convertDragDist } from \"../utils\";\n\nexport function setCustomDrag(\n    e: any,\n    state: MoveableManagerState<any>,\n    delta: number[],\n    isPinch: boolean,\n    isConvert: boolean,\n) {\n\n    const result = state.gesto!.move(delta, e.inputEvent);\n    const datas = result.originalDatas || result.datas;\n    const draggableDatas = datas.draggable || (datas.draggable = {});\n\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        isDrag: true,\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: draggableDatas,\n        originalDatas: e.originalDatas,\n    };\n}\n\nexport default class CustomGesto {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas: any = {\n        draggable: {},\n    };\n\n    public dragStart(client: number[], e: any) {\n        this.isDrag = false;\n        this.isFlag = false;\n        const originalDatas = e.originalDatas;\n\n        this.datas = originalDatas;\n        if (!originalDatas.draggable) {\n            originalDatas.draggable = {};\n        }\n        return {\n            ...this.move(client, e.inputEvent),\n            type: \"dragstart\",\n        };\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            this.isDrag = true;\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            type: \"drag\",\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas.draggable,\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentGesto: this,\n        };\n    }\n}\n","import { Able, MoveableGroupInterface, MoveableManagerInterface } from \"./types\";\nimport CustomGesto, { setCustomDrag } from \"./gesto/CustomGesto\";\n\nexport function fillChildEvents(\n    moveable: MoveableGroupInterface<any, any>,\n    name: string,\n    e: any,\n): any[] {\n    const datas = e.originalDatas;\n\n    datas.groupable = datas.groupable || {};\n\n    const groupableDatas = datas.groupable;\n\n    groupableDatas.childDatas = groupableDatas.childDatas || [];\n\n    const childDatas = groupableDatas.childDatas;\n\n    return moveable.moveables.map((_, i) => {\n        childDatas[i] = childDatas[i] || {};\n        childDatas[i][name] = childDatas[i][name] || {};\n\n        return {\n            ...e,\n            datas: childDatas[i][name],\n            originalDatas: childDatas[i],\n        };\n    });\n}\nexport function triggerChildGesto(\n    moveable: MoveableGroupInterface<any, any>,\n    able: Able,\n    type: string,\n    delta: number[],\n    e: any,\n    isConvert: boolean,\n) {\n    const isStart = !!type.match(/Start$/g);\n    const isEnd = !!type.match(/End$/g);\n    const isPinch = e.isPinch;\n    const datas = e.datas;\n    const events = fillChildEvents(moveable, able.name, e);\n\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        let childEvent: any = ev;\n\n        if (isStart) {\n            childEvent = new CustomGesto().dragStart(delta, ev);\n        } else {\n            if (!childMoveable.state.gesto) {\n                childMoveable.state.gesto = datas.childGestos[i];\n            }\n            childEvent = setCustomDrag(ev, childMoveable.state, delta, isPinch, isConvert);\n        }\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        if (isEnd) {\n            childMoveable.state.gesto = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childGestos = moveables.map(child => child.state.gesto);\n    }\n    return childs;\n}\nexport function triggerChildAbles<T extends Able>(\n    moveable: MoveableGroupInterface<any, any>,\n    able: T,\n    type: keyof T & string,\n    e: any,\n    eachEvent: (movebale: MoveableManagerInterface<any, any>, ev: any) => any = (_, ev) => ev,\n    callback?: (moveable: MoveableManagerInterface<any, any>, ev: any, result: any, index: number) => any,\n) {\n    const isEnd = !!type.match(/End$/g);\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        let childEvent = ev;\n\n        childEvent = eachEvent(childMoveable, ev);\n\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        result && callback && callback(childMoveable, ev, result, i);\n\n        if (isEnd) {\n            childMoveable.state.gesto = null;\n        }\n        return result;\n    });\n\n    return childs;\n}\n","\nimport {\n    invert, calculate, minus, plus,\n    convertPositionMatrix,\n    createScaleMatrix, multiply, fromTranslation, convertDimension,\n} from \"@scena/matrix\";\nimport {\n    calculatePoses, getAbsoluteMatrix, getAbsolutePosesByState,\n    calculatePosition, calculateInversePosition, getTransform, calculateMoveablePosition,\n} from \"../utils\";\nimport { splitUnit, isArray, splitSpace, average, findIndex } from \"@daybrush/utils\";\nimport {\n    MoveableManagerState, ResizableProps, MoveableManagerInterface,\n    OnTransformEvent, OnTransformStartEvent, DraggableProps, OnDrag,\n} from \"../types\";\nimport Draggable from \"../ables/Draggable\";\nimport { setCustomDrag } from \"./CustomGesto\";\nimport { parse, parseMat } from \"css-to-mat\";\n\nexport function calculatePointerDist(moveable: MoveableManagerInterface, e: any) {\n    const { clientX, clientY, datas } = e;\n    const {\n        moveableClientRect,\n        rootMatrix,\n        is3d,\n        pos1,\n    } = moveable.state;\n    const { left, top } = moveableClientRect;\n    const n = is3d ? 4 : 3;\n    const [posX, posY] = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1);\n    const [distX, distY] = getDragDist({ datas, distX: posX, distY: posY });\n\n    return [distX, distY];\n}\n\nexport function setDragStart(moveable: MoveableManagerInterface<any>, { datas }: any) {\n    const {\n        allMatrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = allMatrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(allMatrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getTransformDirection(e: any) {\n    return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nexport function resolveTransformEvent(event: any, functionName: string) {\n    const {\n        datas,\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = event;\n\n    const index = datas.transformIndex;\n    const nextTransforms = originalDatas.nextTransforms;\n    const nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;\n    const nextIndex = index === -1 ? nextTransforms.length\n        : index + nextTransformAppendedIndexes.filter((i: number) => i < index).length;\n\n    const result = getTransform(nextTransforms, nextIndex);\n    const targetFunction = result.targetFunction;\n    const matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n\n    datas.beforeFunctionTexts = result.beforeFunctionTexts;\n    datas.afterFunctionTexts = result.afterFunctionTexts;\n    datas.beforeTransform = result.beforeFunctionMatrix;\n    datas.beforeTransform2 = result.beforeFunctionMatrix2;\n    datas.targetTansform = result.targetFunctionMatrix;\n    datas.afterTransform = result.afterFunctionMatrix;\n    datas.afterTransform2 = result.afterFunctionMatrix2;\n    datas.targetAllTransform = result.allFunctionMatrix;\n\n    if (targetFunction.functionName === matFunctionName) {\n        datas.afterFunctionTexts.splice(0, 1);\n        datas.isAppendTransform = false;\n    } else {\n        datas.isAppendTransform = true;\n        originalDatas.nextTransformAppendedIndexes = [...nextTransformAppendedIndexes, nextIndex];\n    }\n}\n\nexport function convertTransformFormat(datas: any, value: any, dist: any) {\n    return `${datas.beforeFunctionTexts.join(\" \")} ${datas.isAppendTransform ? dist : value} ${datas.afterFunctionTexts.join(\" \")}`;\n}\nexport function getTransformDist({ datas, distX, distY }: any) {\n    const [bx, by] = getBeforeDragDist({ datas, distX, distY });\n    // B * [tx, ty] * A = [bx, by] * targetMatrix;\n    // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\n\n    const res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));\n\n    return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nexport function getTransfromMatrix(datas: any, targetMatrix: number[], isAfter?: boolean) {\n    const {\n        beforeTransform,\n        afterTransform,\n        beforeTransform2,\n        afterTransform2,\n        targetAllTransform,\n    } = datas;\n\n    // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\n    // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\n    // nextTargetMatrix = (targetMatrix * targetAllTransform)\n    const nextTargetMatrix\n        = isAfter\n            ? multiply(targetAllTransform, targetMatrix, 4)\n            : multiply(targetMatrix, targetAllTransform, 4);\n\n    // res1 = B-1 * nextTargetMatrix\n    const res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);\n\n    // res3 = res2 * A-1\n    const afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);\n\n    return afterTargetMatrix;\n}\nexport function getBeforeDragDist({ datas, distX, distY }: any) {\n    // TT = BT\n    const {\n        inverseBeforeMatrix,\n        is3d,\n        startDragBeforeDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\n    // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\n    return minus(\n        calculate(\n            inverseBeforeMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        startDragBeforeDist,\n    );\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\n\nexport function calculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    const nextPoses = getPosesByDirection(poses, direction);\n\n    return [\n        average(nextPoses.map(pos => pos[0])),\n        average(nextPoses.map(pos => pos[1])),\n    ];\n}\nexport function getPosByReverseDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n    [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n    [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n    */\n\n    return getPosByDirection(poses, direction.map(dir => -dir));\n}\n\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    fixedDirection: number[],\n) {\n    const poses = calculatePoses(matrix, width, height, n);\n    const fixedPos = getPosByDirection(poses, fixedDirection);\n    const distX = startPos[0] - fixedPos[0];\n    const distY = startPos[1] - fixedPos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function getNextTransformMatrix(\n    state: MoveableManagerState<any>,\n    datas: any,\n    transform: string,\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n    } = state;\n    const {\n        beforeTransform,\n        afterTransform,\n    } = datas;\n    const n = is3d ? 4 : 3;\n    const targetTransform = parseMat([transform]);\n\n    return getNextMatrix(\n        offsetMatrix,\n        convertDimension(multiply(multiply(beforeTransform, targetTransform as any, 4), afterTransform, 4), 4, n),\n        transformOrigin,\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\n\nexport function fillTransformStartEvent(e: any): OnTransformStartEvent {\n    const originalDatas = e.originalDatas.beforeRenderable;\n    return {\n        setTransform: (transform: string | string[], index = -1) => {\n            originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            setTransformIndex(e, index);\n        },\n        setTransformIndex: (index: number) => {\n            setTransformIndex(e, index);\n        },\n    };\n}\nexport function setDefaultTransformIndex(e: any, property: string) {\n    const originalDatas = e.originalDatas.beforeRenderable;\n    const startTransforms = originalDatas.startTransforms;\n\n    setTransformIndex(e, findIndex<string>(startTransforms, func => func.indexOf(`${property}(`) === 0));\n}\nexport function setTransformIndex(e: any, index: number) {\n    const originalDatas = e.originalDatas.beforeRenderable;\n    const datas = e.datas;\n\n    datas.transformIndex = index;\n    if (index === -1) {\n        return;\n    }\n    const transform = originalDatas.startTransforms[index];\n\n    if (!transform) {\n        return;\n    }\n    const info = parse([transform]);\n\n    datas.startValue = info[0].functionValue;\n}\nexport function fillOriginalTransform(\n    e: any,\n    transform: string,\n) {\n    const originalDatas = e.originalDatas.beforeRenderable;\n\n    originalDatas.nextTransforms = splitSpace(transform);\n}\nexport function fillTransformEvent(\n    moveable: MoveableManagerInterface<DraggableProps>,\n    nextTransform: string,\n    delta: number[],\n    isPinch: boolean,\n    e: any,\n): OnTransformEvent {\n    fillOriginalTransform(e, nextTransform);\n    return {\n        transform: nextTransform,\n        drag: Draggable.drag(\n            moveable,\n            setCustomDrag(e, moveable.state, delta, isPinch, false),\n        ) as OnDrag,\n    };\n}\nexport function getTranslateDist(\n    moveable: MoveableManagerInterface<any>,\n    transform: string,\n    fixedDirection: number[],\n    fixedPosition: number[],\n    datas: any,\n) {\n    const state = moveable.state;\n    const {\n        left,\n        top,\n    } = state;\n\n    const groupable = moveable.props.groupable;\n    const nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);\n    const dist = minus(fixedPosition, nextFixedPosition);\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getScaleDist(\n    moveable: MoveableManagerInterface<any>,\n    scaleDist: number[],\n    fixedDirection: number[],\n    fixedPosition: number[],\n    datas: any,\n) {\n    return getTranslateDist(\n        moveable,\n        `scale(${scaleDist.join(\", \")})`,\n        fixedDirection,\n        fixedPosition,\n        datas,\n    );\n}\nexport function getOriginDirection(moveable: MoveableManagerInterface<any>) {\n    const {\n        width,\n        height,\n        transformOrigin,\n    } = moveable.state;\n    return [\n        -1 + transformOrigin[0] / (width / 2),\n        -1 + transformOrigin[1] / (height / 2),\n    ];\n}\nexport function getDirectionOffset(\n    moveable: MoveableManagerInterface, direction: number[],\n    nextMatrix: number[] = moveable.state.allMatrix,\n) {\n    const {\n        width,\n        height,\n        is3d,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n    const nextFixedOffset = [\n        width / 2 * (1 + direction[0]),\n        height / 2 * (1 + direction[1]),\n    ];\n    return calculatePosition(nextMatrix, nextFixedOffset, n);\n}\nexport function getRotateDist(\n    moveable: MoveableManagerInterface<any>,\n    rotateDist: number,\n    fixedPosition: number[],\n    datas: any,\n) {\n    const fixedDirection = getOriginDirection(moveable);\n\n    return getTranslateDist(\n        moveable,\n        `rotate(${rotateDist}deg)`,\n        fixedDirection,\n        fixedPosition,\n        datas,\n    );\n}\nexport function getResizeDist(\n    moveable: MoveableManagerInterface<any>,\n    width: number,\n    height: number,\n    fixedDirection: number[],\n    fixedPosition: number[],\n    transformOrigin: string[],\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const {\n        transformOrigin: prevOrigin,\n        targetMatrix,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = moveable.state;\n\n    const n = is3d ? 4 : 3;\n    const nextOrigin = calculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getAbsolutePosition(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n","import {\n    SnapInfo, SnappableProps, SnappableState,\n    SnapGuideline, ResizableProps, ScalableProps,\n    SnapOffsetInfo, MoveableManagerInterface, MoveableClientRect,\n    ElementGuidelineValue,\n} from \"../../types\";\nimport {\n    selectValue, getAbsolutePosesByState,\n    getRect, groupBy, getTinyDist, calculateInversePosition,\n    calculatePosition, roundSign, getRefTarget,\n} from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../gesto/GestoUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport { diff } from \"@egjs/children-differ\";\nimport { isObject, throttle } from \"@daybrush/utils\";\n\nexport function calculateContainerPos(\n    rootMatrix: number[],\n    containerRect: MoveableClientRect,\n    n: number,\n) {\n    const clientPos = calculatePosition(\n        rootMatrix, [containerRect.clientLeft!, containerRect.clientTop!], n);\n\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1],\n    ];\n}\n\nexport function getGapGuidelines(\n    guidelines: SnapGuideline[],\n    type: \"vertical\" | \"horizontal\",\n    snapThreshold: number,\n    index: number,\n    [start, end]: number[],\n    [otherStart, otherEnd]: number[],\n) {\n    const totalGuidelines: SnapGuideline[] = [];\n    const otherIndex = index ? 0 : 1;\n    const otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n\n    const elementGuidelines\n        = groupBy(guidelines.filter(({ type: guidelineType }) => guidelineType === type), ({ element }) => element)\n            .map(group => group[0])\n            .filter(({ pos, sizes }) => pos[otherIndex] <= otherEnd\n                && otherStart <= pos[otherIndex] + sizes![otherIndex]);\n\n    elementGuidelines.forEach(guideline1 => {\n        const elementStart = guideline1.pos[index];\n        const elementEnd = elementStart + guideline1.sizes![index];\n\n        elementGuidelines.forEach(guideline2 => {\n            const {\n                pos: guideline2Pos,\n                sizes: guideline2Sizes,\n                element: guideline2Element,\n                className: guidline2ClassName,\n            } = guideline2;\n            const targetStart = guideline2Pos[index];\n            const targetEnd = targetStart + guideline2Sizes![index];\n            let pos = 0;\n            let gap = 0;\n            let canSnap = true;\n\n            if (elementEnd <= targetStart) {\n                // gap -\n                gap = elementEnd - targetStart;\n                pos = targetEnd - gap;\n\n                if (start < pos - snapThreshold) {\n                    canSnap = false;\n                }\n                // element target moveable\n            } else if (targetEnd <= elementStart) {\n                // gap +\n                gap = elementStart - targetEnd;\n                pos = targetStart - gap;\n\n                if (end > pos + snapThreshold) {\n                    canSnap = false;\n                }\n                // moveable target element\n            } else {\n                return;\n            }\n            if (canSnap) {\n                totalGuidelines.push({\n                    pos: otherType === \"vertical\" ? [pos, guideline2Pos[1]] : [guideline2Pos[0], pos],\n                    element: guideline2Element,\n                    sizes: guideline2Sizes,\n                    size: 0,\n                    type: otherType,\n                    gap,\n                    className: guidline2ClassName,\n                    gapGuidelines: elementGuidelines,\n                });\n            }\n            if (elementEnd <= start && end <= targetStart) {\n                // elementEnd   moveable   target\n                const centerPos = ((targetStart + elementEnd) - (end - start)) / 2;\n\n                if (throttle(start - (centerPos - snapThreshold), 0.1) >= 0) {\n                    totalGuidelines.push({\n                        pos: otherType === \"vertical\" ? [centerPos, guideline2Pos[1]] : [guideline2Pos[0], centerPos],\n                        className: guidline2ClassName,\n                        element: guideline2Element,\n                        sizes: guideline2Sizes,\n                        size: 0,\n                        type: otherType,\n                        gap: elementEnd - start,\n                        gapGuidelines: elementGuidelines,\n                    });\n                }\n            }\n        });\n    });\n    return totalGuidelines;\n}\nexport function getDefaultGuidelines(\n    horizontalGuidelines: number[] | false,\n    verticalGuidelines: number[] | false,\n    width: number,\n    height: number,\n    clientLeft = 0,\n    clientTop = 0,\n    snapOffset = { left: 0, top: 0, right: 0, bottom: 0 },\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n    const {\n        left: snapOffsetLeft,\n        top: snapOffsetTop,\n        bottom: snapOffsetBottom,\n        right: snapOffsetRight,\n    } = snapOffset;\n    const snapWidth = width! + snapOffsetRight - snapOffsetLeft;\n    const snapHeight = height! + snapOffsetBottom - snapOffsetTop;\n\n    horizontalGuidelines && horizontalGuidelines!.forEach(pos => {\n        guidelines.push({ type: \"horizontal\", pos: [\n            snapOffsetLeft,\n            throttle(pos - clientTop + snapOffsetTop, 0.1),\n        ], size: snapWidth });\n    });\n    verticalGuidelines && verticalGuidelines!.forEach(pos => {\n        guidelines.push({ type: \"vertical\", pos: [\n            throttle(pos - clientLeft + snapOffsetLeft, 0.1),\n            snapOffsetTop,\n        ], size: snapHeight });\n    });\n    return guidelines;\n}\nexport function calculateElementGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    values: ElementGuidelineValue[],\n) {\n    const guidelines: SnapGuideline[] = [];\n\n    if (!values.length) {\n        return guidelines;\n    }\n    const state = moveable.state;\n    const {\n        snapCenter,\n    } = moveable.props;\n    const {\n        containerClientRect,\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const [containerLeft, containerTop] = calculateContainerPos(rootMatrix, containerClientRect, n);\n    const poses = getAbsolutePosesByState(state);\n    const {\n        minX: targetLeft,\n        minY: targetTop,\n    } = getMinMaxs(poses);\n    const [distLeft, distTop] = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [\n        clientLeft - containerLeft,\n        clientTop - containerTop,\n    ], n)).map(pos => roundSign(pos));\n\n    values.forEach(value => {\n        const {\n            element,\n            top: topValue,\n            left: leftValue,\n            right: rightValue,\n            bottom: bottomValue,\n            className,\n        } = value;\n        const rect = element.getBoundingClientRect();\n        const left = rect.left - containerLeft;\n        const top = rect.top - containerTop;\n        const bottom = top + rect.height;\n        const right = left + rect.width;\n        const [elementLeft, elementTop] = calculateInversePosition(rootMatrix, [left, top], n);\n        const [elementRight, elementBottom] = calculateInversePosition(rootMatrix, [right, bottom], n);\n        const width = elementRight - elementLeft;\n        const height = elementBottom - elementTop;\n        const sizes = [width, height];\n\n        //top\n        if (topValue !== false) {\n            guidelines.push({\n                type: \"vertical\", element, pos: [\n                    throttle(elementLeft + distLeft, 0.1),\n                    elementTop,\n                ], size: height,\n                sizes,\n                className,\n            });\n        }\n\n        // bottom\n        if (bottomValue !== false) {\n            guidelines.push({\n                type: \"vertical\", element, pos: [\n                    throttle(elementRight + distLeft, 0.1),\n                    elementTop,\n                ], size: height,\n                sizes,\n                className,\n            });\n        }\n\n        // left\n        if (leftValue !== false) {\n            guidelines.push({\n                type: \"horizontal\", element, pos: [\n                    elementLeft,\n                    throttle(elementTop + distTop, 0.1),\n                ], size: width,\n                sizes,\n                className,\n            });\n        }\n\n        // right\n        if (rightValue !== false) {\n            guidelines.push({\n                type: \"horizontal\", element, pos: [\n                    elementLeft,\n                    throttle(elementBottom + distTop, 0.1),\n                ], size: width,\n                sizes,\n                className,\n            });\n        }\n\n        if (snapCenter) {\n            guidelines.push({\n                type: \"vertical\",\n                element,\n                pos: [\n                    throttle((elementLeft + elementRight) / 2 + distLeft, 0.1),\n                    elementTop,\n                ],\n                size: height,\n                sizes,\n                center: true,\n                className,\n            });\n            guidelines.push({\n                type: \"horizontal\",\n                element,\n                pos: [\n                    elementLeft,\n                    throttle((elementTop + elementBottom) / 2 + distTop, 0.1),\n                ],\n                size: width,\n                sizes,\n                center: true,\n                className,\n            });\n        }\n    });\n    return guidelines;\n}\nexport function getElementGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    isRefresh: boolean,\n    prevGuidelines: SnapGuideline[] = [],\n) {\n    const guidelines: SnapGuideline[] = [];\n    const state = moveable.state;\n\n    if (isRefresh && state.guidelines && state.guidelines.length) {\n        return guidelines;\n    }\n\n    const {\n        elementGuidelines = [],\n    } = moveable.props;\n\n    if (!elementGuidelines.length) {\n        return guidelines;\n    }\n\n    const prevValues = state.elementGuidelineValues || [];\n    const nextValues = elementGuidelines.map(el => {\n        if (isObject(el) && \"element\" in el) {\n            return el;\n        }\n        return {\n            element: getRefTarget(el, true)!,\n        };\n    }).filter(value => {\n        return value.element;\n    }) as ElementGuidelineValue[];\n\n    state.elementGuidelineValues = nextValues;\n\n    const { added, removed } = diff(prevValues.map(v => v.element), nextValues.map(v => v.element));\n    const removedElements = removed.map(index => prevValues[index].element);\n    const addedGuidelines = calculateElementGuidelines(moveable, added.map(index => nextValues[index]).filter(value => {\n        return (value.refresh && isRefresh) || (!value.refresh && !isRefresh);\n    }));\n\n    return [\n        ...prevGuidelines.filter(guideline => removedElements.indexOf(guideline.element!) === -1),\n        ...addedGuidelines,\n    ];\n}\nexport function getTotalGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const {\n        snapOffset,\n        staticGuidelines,\n        containerClientRect: {\n            overflow,\n            scrollHeight: containerHeight,\n            scrollWidth: containerWidth,\n            clientHeight: containerClientHeight,\n            clientWidth: containerClientWidth,\n            clientLeft,\n            clientTop,\n        },\n    } = moveable.state;\n    const {\n        snapHorizontal = true,\n        snapVertical = true,\n        snapGap = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n        snapThreshold = 5,\n        snapGridWidth = 0,\n        snapGridHeight = 0,\n    } = moveable.props;\n    const totalGuidelines: SnapGuideline[] = [...staticGuidelines, ...getElementGuidelines(moveable, true)];\n\n    if (snapGap) {\n        const { top, left, bottom, right } = getRect(getAbsolutePosesByState(moveable.state));\n        const elementGuidelines = staticGuidelines.filter(({ element }) => element);\n\n        totalGuidelines.push(...getGapGuidelines(\n            elementGuidelines,\n            \"horizontal\",\n            snapThreshold,\n            0,\n            [left, right],\n            [top, bottom],\n        ), ...getGapGuidelines(\n            elementGuidelines,\n            \"vertical\",\n            snapThreshold,\n            1,\n            [top, bottom],\n            [left, right],\n        ));\n    }\n    totalGuidelines.push(...getGridGuidelines(\n        snapGridWidth,\n        snapGridHeight,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n    ));\n\n    totalGuidelines.push(...getDefaultGuidelines(\n        (snapHorizontal && horizontalGuidelines) || false,\n        (snapVertical && verticalGuidelines) || false,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n        snapOffset,\n    ));\n\n    return totalGuidelines;\n}\nexport function getGridGuidelines(\n    snapGridWidth: number,\n    snapGridHeight: number,\n    containerWidth: number,\n    containerHeight: number,\n    clientLeft = 0,\n    clientTop = 0,\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n\n    if (snapGridHeight) {\n        for (let pos = 0; pos <= containerHeight; pos += snapGridHeight) {\n            guidelines.push({\n                type: \"horizontal\",\n                pos: [0, throttle(pos - clientTop, 0.1)],\n                size: containerWidth!,\n                hide: true,\n            });\n        }\n    }\n    if (snapGridWidth) {\n        for (let pos = 0; pos <= containerWidth; pos += snapGridWidth) {\n            guidelines.push({\n                type: \"vertical\",\n                pos: [throttle(pos - clientLeft, 0.1), 0],\n                size: containerHeight!,\n                hide: true,\n            });\n        }\n    }\n    return guidelines;\n}\nexport function checkMoveableSnapPoses(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    snapCenter?: boolean,\n    customSnapThreshold?: number,\n) {\n    const props = moveable.props;\n    const {\n        snapElement = true,\n    } = props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n\n    return checkSnapPoses(\n        moveable.state.guidelines,\n        posesX,\n        posesY,\n        {\n            snapThreshold,\n            snapCenter,\n            snapElement,\n        },\n    );\n}\n\nexport function checkSnapPoses(\n    guidelines: SnapGuideline[],\n    posesX: number[],\n    posesY: number[],\n    options: {\n        snapThreshold?: number,\n        snapCenter?: boolean,\n        snapElement?: boolean,\n    },\n) {\n    return {\n        vertical: checkSnap(guidelines, \"vertical\", posesX, options),\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, options),\n    };\n}\nexport function checkSnapKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): { vertical: SnapOffsetInfo, horizontal: SnapOffsetInfo } {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    let [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    dx = getTinyDist(dx);\n    dy = getTinyDist(dy);\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []);\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\nexport function checkSnaps(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    rect: {\n        left?: number,\n        top?: number,\n        bottom?: number,\n        right?: number,\n        center?: number,\n        middle?: number,\n    },\n    isCenter: boolean,\n    customSnapThreshold?: number,\n) {\n    const snapCenter = moveable.props.snapCenter;\n    const isSnapCenter = snapCenter! && isCenter;\n\n    let verticalNames: Array<\"left\" | \"center\" | \"right\"> = [\"left\", \"right\"];\n    let horizontalNames: Array<\"top\" | \"middle\" | \"bottom\"> = [\"top\", \"bottom\"];\n\n    if (isSnapCenter) {\n        verticalNames.push(\"center\");\n        horizontalNames.push(\"middle\");\n    }\n    verticalNames = verticalNames.filter(name => name in rect);\n    horizontalNames = horizontalNames.filter(name => name in rect);\n\n    return checkMoveableSnapPoses(\n        moveable,\n        verticalNames.map(name => rect[name]!),\n        horizontalNames.map(name => rect[name]!),\n        isSnapCenter,\n        customSnapThreshold,\n    );\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: SnapGuideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    {\n        snapThreshold = 5,\n        snapElement,\n        snapCenter,\n    }: {\n        snapThreshold?: number,\n        snapCenter?: boolean,\n        snapElement?: boolean,\n    } = {},\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            index: -1,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map((targetPos, index) => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type, center, element } = guideline;\n            if (\n                (!snapElement && element)\n                || (!snapCenter && center)\n                || type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n\n        return {\n            pos: targetPos,\n            index,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    const isSnap = snapPosInfos.length > 0;\n    return {\n        isSnap,\n        index: isSnap ? snapPosInfos[0].index : -1,\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManagerInterface<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n) {\n    let nextPoses: number[][] = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        nextPoses = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ].map(direction => getPosByDirection(poses, direction));\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            nextPoses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n    } else {\n        if (moveable.props.keepRatio) {\n            nextPoses = [\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            ].map(dir => getPosByDirection(poses, dir));\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    return checkMoveableSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n}\n\nexport function checkSnapBoundPriority(\n    a: { isBound: boolean, isSnap: boolean, offset: number },\n    b: { isBound: boolean, isSnap: boolean, offset: number },\n) {\n    const aDist = Math.abs(a.offset);\n    const bDist = Math.abs(b.offset);\n\n    if (a.isBound && b.isBound) {\n        return bDist - aDist;\n    } else if (a.isBound) {\n        return -1;\n    } else if (b.isBound) {\n        return 1;\n    } else if (a.isSnap && b.isSnap) {\n        return bDist - aDist;\n    } else if (a.isSnap) {\n        return -1;\n    } else if (b.isSnap) {\n        return 1;\n    } else if (aDist < TINY_NUM) {\n        return 1;\n    } else if (bDist < TINY_NUM) {\n        return -1;\n    }\n    return aDist - bDist;\n}\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        }\n        return checkSnapBoundPriority(\n            { isBound: a.isBound, isSnap: a.isSnap, offset: aOffset },\n            { isBound: b.isBound, isSnap: b.isSnap, offset: bOffset },\n        );\n    })[0];\n}\n","import { average, getRad, throttle } from \"@daybrush/utils\";\nimport { rotate } from \"@scena/matrix\";\nimport { maxOffset, getDistSize, getTinyDist } from \"../../utils\";\n\nimport { SnappableProps, DraggableProps, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../gesto/GestoUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average([line[0][0], line[1][0]]);\n    const cy = average([line[0][1], line[1][1]]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], error: number = TINY_NUM) {\n    const centerSign = hitTestLine(dots[0], line) <= 0;\n\n    return dots.slice(1).every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || Math.abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    line: number[][],\n    center: number[],\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const {\n        horizontal: isHorizontalStart,\n        vertical: isVerticalStart,\n    } = isStartLine(center, line);\n\n    if (isSameStartLine([\n        center,\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n\n    // test vertical\n    const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n    const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n    const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n    isRender?: boolean,\n) {\n    const dot1 = line[0];\n    const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n    const dy1 = getTinyDist(dot2[1] - dot1[1]);\n    const dx1 = getTinyDist(dot2[0] - dot1[0]);\n\n    const dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n    const dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        if (isRender && !dy1) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (dx1) {\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n            const y = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        } else {\n            const offset = boundDot1[0] - dot1[0];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    } else if (!dy2) {\n        // horizontal\n        if (isRender && !dx1) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (dy1) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            // const a = dy1 / dx1;\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n            const x = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        } else {\n            const offset = boundDot1[1] - dot1[1];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    lines: number[][][],\n    center: number[],\n    datas: any,\n) {\n    return lines.map(([multiple, pos1, pos2]) => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, [pos1, pos2], center);\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckInnerBoundLines(poses, [0, 0], false).map(([sign, pos1, pos2]) => {\n        return [\n            sign.map(dir => Math.abs(dir) * 2),\n            pos1,\n            pos2,\n        ];\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport function getCheckInnerBoundLines(\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n) {\n    return getCheckSnapLineDirections(direction, keepRatio).map(([sign, dir1, dir2]) => {\n        return [\n            sign,\n            getPosByDirection(poses, dir1),\n            getPosByDirection(poses, dir2),\n        ];\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    const dots = [\n        center,\n        ...boundDots,\n    ];\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some(line => !isSameStartLine(dots, line));\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return Math.abs(pos1[0]);\n    }\n    if (!dy) {\n        return Math.abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n\n    if (!innerBounds) {\n        return {\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    const lines = [\n        [pos1, pos2],\n        [pos2, pos4],\n        [pos4, pos3],\n        [pos3, pos1],\n    ];\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n    const boundMap = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false,\n    };\n\n    lines.forEach(line => {\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);\n        const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);\n        const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n","import { getRad, throttle } from \"@daybrush/utils\";\nimport {\n    BoundInfo, SnappableProps, BoundType,\n    RotatableProps, MoveableManagerInterface, SnappableState,\n} from \"../../types\";\nimport { rotate, minus } from \"@scena/matrix\";\nimport { getDistSize } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    bounds: BoundType | false | undefined,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        position = \"client\",\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds || {};\n    const nextBounds = {\n        position,\n        left,\n        top,\n        right,\n        bottom,\n    };\n\n    return {\n        vertical: checkBounds(nextBounds, verticalPoses, true),\n        horizontal: checkBounds(nextBounds, horizontalPoses, false),\n    };\n}\nexport function getBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    externalBounds?: BoundType | false | null,\n) {\n    const {\n        containerClientRect: {\n            clientHeight: containerHeight,\n            clientWidth: containerWidth,\n            clientLeft,\n            clientTop,\n        },\n        snapOffset: {\n            left: snapOffsetLeft,\n            top: snapOffsetTop,\n            right: snapOffsetRight,\n            bottom: snapOffsetBottom,\n        },\n    } = moveable.state;\n    const bounds = externalBounds || moveable.props.bounds || {} as BoundType;\n    const position = bounds.position || \"client\";\n    const isCSS = position === \"css\";\n    const {\n        left = -Infinity,\n        top = -Infinity,\n    } = bounds;\n    let {\n        right = isCSS ? -Infinity : Infinity,\n        bottom = isCSS ? -Infinity : Infinity,\n    } = bounds;\n\n    if (isCSS) {\n        right = containerWidth! + snapOffsetRight - snapOffsetLeft - right;\n        bottom = containerHeight! + snapOffsetBottom - snapOffsetTop - bottom;\n    }\n\n    return {\n        left: left + snapOffsetLeft - clientLeft!,\n        right: right + snapOffsetLeft - clientLeft!,\n        top: top + snapOffsetTop - clientTop!,\n        bottom: bottom + snapOffsetTop - clientTop!,\n    };\n}\nexport function checkBoundKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const [endX, endY] = endPos;\n    let [dx, dy] = minus(endPos, startPos);\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom &&  endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBounds(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo[] {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n    const boundInfos: BoundInfo[] = [];\n\n    if (startBoundPos + 1 > minPos) {\n        boundInfos.push({\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        });\n    }\n    if (endBoundPos - 1 < maxPos) {\n        boundInfos.push({\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        });\n    }\n\n    if (!boundInfos.length) {\n        boundInfos.push({\n            isBound: false,\n            offset: 0,\n            pos: 0,\n        });\n    }\n\n    return boundInfos.sort((a, b) => Math.abs(b.offset) - Math.abs(a.offset));\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, SnappableState>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    if (!moveable.props.bounds) {\n        return [];\n    }\n    const rad = rotation * Math.PI / 180;\n\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index]) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n","import { find, throttle } from \"@daybrush/utils\";\nimport {\n    RenderGuidelineInfo, Renderer, RenderGuidelineInnerInfo,\n    MoveableManagerInterface, SnappableProps, SnapGuideline,\n    SnappableOptions, SnappableRenderType, GapGuideline, SnappableState,\n} from \"../../types\";\nimport { prefix, flat, groupBy } from \"../../utils\";\n\nconst DIRECTION_NAMES = {\n    horizontal: [\n        \"left\",\n        \"top\",\n        \"width\",\n        \"Y\",\n        \"X\",\n    ] as const,\n    vertical: [\n        \"top\", \"left\", \"height\", \"X\", \"Y\",\n    ] as const,\n} as const;\n\nexport function groupByElementGuidelines(\n    guidelines: SnapGuideline[],\n    clientPos: number,\n    size: number,\n    index: number\n) {\n    const groupInfos: Array<[Element, number, any]> = [];\n\n    const group = groupBy(\n        guidelines.filter(({ element, gap }) => element && !gap),\n        ({ element, pos }) => {\n            const elementPos = pos[index];\n            const sign = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;\n            const groupKey = `${sign}_${pos[index ? 0 : 1]}`;\n            const groupInfo = find(groupInfos, ([groupElement, groupPos]) => {\n                return element === groupElement && elementPos === groupPos;\n            });\n            if (groupInfo) {\n                return groupInfo[2];\n            }\n            groupInfos.push([element!, elementPos, groupKey]);\n            return groupKey;\n        }\n    );\n    group.forEach((elementGuidelines) => {\n        elementGuidelines.sort((a, b) => {\n            const result =\n                getElementGuidelineDist(a.pos[index], a.size, clientPos, size)\n                    .size -\n                getElementGuidelineDist(b.pos[index], a.size, clientPos, size)\n                    .size;\n\n            return result || a.pos[index ? 0 : 1] - b.pos[index ? 0 : 1];\n        });\n    });\n    return group;\n}\nexport function getElementGuidelineDist(\n    elementPos: number,\n    elementSize: number,\n    targetPos: number,\n    targetSize: number\n) {\n    // relativePos < 0  => element(l)  ---  (r)target\n    // relativePos > 0  => target(l)   ---  (r)element\n    const relativePos = elementPos - targetPos;\n    const startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n    const endPos = relativePos < 0 ? 0 : relativePos;\n    const size = endPos - startPos;\n\n    return {\n        size,\n        pos: startPos,\n    };\n}\n\nexport function renderGuideline(info: RenderGuidelineInfo, React: Renderer): any {\n    const { direction, classNames, size, pos, zoom, key } = info;\n    const isHorizontal = direction === \"horizontal\";\n    const scaleDirection = isHorizontal ? \"Y\" : \"X\";\n    // const scaleDirection2 = isHorizontal ? \"Y\" : \"X\";\n\n    return React.createElement(\"div\", {\n        key,\n        className: classNames.join(\" \"),\n        style: {\n            [isHorizontal ? \"width\" : \"height\"]: `${size}`,\n            transform: `translate(${pos[0]}, ${pos[1]}) translate${scaleDirection}(-50%) scale${scaleDirection}(${zoom})`,\n        },\n    });\n}\n\nexport function renderInnerGuideline(info: RenderGuidelineInnerInfo, React: Renderer): any {\n    return renderGuideline({\n        ...info,\n        classNames: [\n            prefix(\"line\", \"guideline\", info.direction),\n            ...info.classNames,\n        ].filter(className => className) as string[],\n        size: info.size || `${info.sizeValue}px`,\n        pos: info.pos || info.posValue.map(v => `${throttle(v, 0.1)}px`),\n    }, React);\n}\n\nexport function renderElementGroups(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    direction: \"vertical\" | \"horizontal\",\n    groups: SnapGuideline[][],\n    minPos: number,\n    clientPos: number,\n    clientSize: number,\n    targetPos: number,\n    snapThreshold: number,\n    snapDigit: number,\n    index: number,\n    snapDistFormat: Required<SnappableOptions>[\"snapDistFormat\"],\n    React: Renderer\n) {\n    const { zoom, isDisplaySnapDigit = true } = moveable.props;\n    const [posName1, posName2, sizeName, , scaleDirection] = DIRECTION_NAMES[direction];\n    return flat(\n        groups.map((elementGuidelines, i) => {\n            let isFirstRenderSize = true;\n\n            return elementGuidelines.map(({ pos, size }, j) => {\n                const {\n                    pos: linePos,\n                    size: lineSize,\n                } = getElementGuidelineDist(\n                    pos[index],\n                    size,\n                    clientPos,\n                    clientSize\n                );\n\n                if (lineSize < snapThreshold) {\n                    return null;\n                }\n                const isRenderSize = isFirstRenderSize;\n\n                isFirstRenderSize = false;\n                const snapSize =\n                    isDisplaySnapDigit && isRenderSize\n                        ? parseFloat(lineSize.toFixed(snapDigit))\n                        : 0;\n                return (\n                    <div\n                        key={`${direction}LinkGuideline${i}-${j}`}\n                        className={prefix(\"guideline-group\", direction)}\n                        style={{\n                            [posName1]: `${minPos + linePos}px`,\n                            [posName2]: `${-targetPos + pos[index ? 0 : 1]}px`,\n                            [sizeName]: `${lineSize}px`,\n                        }}\n                    >\n                        {renderInnerGuideline(\n                            {\n                                direction: direction,\n                                classNames: [prefix(\"dashed\")],\n                                size: \"100%\",\n                                posValue: [0, 0],\n                                sizeValue: lineSize,\n                                zoom: zoom!,\n                            },\n                            React\n                        )}\n                        <div\n                            className={prefix(\"size-value\")}\n                            style={{\n                                transform: `translate${scaleDirection}(-50%) scale(${zoom})`,\n                            }}\n                        >\n                            {snapSize > 0 ? snapDistFormat(snapSize) : \"\"}\n                        </div>\n                    </div>\n                );\n            });\n        })\n    );\n}\nexport function renderSnapPoses(\n    moveable: MoveableManagerInterface,\n    direction: string,\n    snapPoses: SnappableRenderType[],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    index: number,\n    React: Renderer\n) {\n    const { zoom } = moveable.props;\n    return snapPoses.map(({ type, pos }, i) => {\n        const renderPos = [0, 0];\n\n        renderPos[index] = minPos;\n        renderPos[index ? 0 : 1] = -targetPos + pos;\n\n        return renderInnerGuideline(\n            {\n                key: `${direction}TargetGuideline${i}`,\n                classNames: [prefix(\"target\", \"bold\", type)],\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n                direction: direction,\n            },\n            React\n        );\n    });\n}\nexport function filterElementInnerGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    guidelines: SnapGuideline[],\n    index: number,\n    targetPos: number[],\n    clientPos: number[],\n    targetSizes: number[],\n) {\n    const { isDisplayInnerSnapDigit } = moveable.props;\n    const innerGuidelines: SnapGuideline[] = [];\n    const otherIndex = index ? 0 : 1;\n    const targetContentPos = targetPos[index];\n    const targetContentSize = targetSizes[index];\n    let gapGuidelines: GapGuideline[] = [];\n    let nextGuidelines = guidelines.filter(guideline => {\n        const { element, pos, size } = guideline;\n\n        if (\n            isDisplayInnerSnapDigit && element\n            && pos[index] < targetContentPos && targetContentPos + targetContentSize < pos[index] + size\n        ) {\n            innerGuidelines.push(guideline);\n\n            const contentPos = pos[index] - targetContentPos;\n            const inlinePos = pos[otherIndex] - targetPos[otherIndex];\n\n            gapGuidelines.push({\n                ...guideline,\n                inner: true,\n                gap: contentPos,\n                renderPos: index ? [inlinePos, contentPos] : [contentPos, inlinePos],\n            });\n            gapGuidelines.push({\n                ...guideline,\n                inner: true,\n                gap: pos[index] + size - targetContentPos - targetContentSize,\n                renderPos: index ? [inlinePos, targetContentSize] : [targetContentSize, inlinePos],\n            });\n            return false;\n        }\n        return true;\n    });\n\n    nextGuidelines = nextGuidelines.filter(guideline1 => {\n        const {\n            element: element1,\n            pos: pos1,\n            size: size1,\n        } = guideline1;\n        const contentPos1 = pos1[index];\n\n        if (!element1) {\n            return true;\n        }\n        return nextGuidelines.every(guideline2 => {\n            const {\n                element: element2,\n                pos: pos2,\n                size: size2,\n            } = guideline2;\n            const contentPos2 = pos2[index];\n            if (!element2 || guideline1 === guideline2) {\n                return true;\n            }\n            return contentPos1 + size1 <= contentPos2\n                || contentPos2 + size2 <= contentPos1\n                || (contentPos1 < contentPos2 && contentPos2 + size2 < contentPos1 + size1);\n        });\n    });\n    const groups = groupByElementGuidelines(\n        nextGuidelines,\n        clientPos[index],\n        targetContentSize,\n        index,\n    );\n    gapGuidelines = gapGuidelines.filter(guideline => {\n        const gap = guideline.gap!;\n        const inlinePos = guideline.pos[otherIndex];\n\n        return groups.every(group => {\n            return group.every(groupGuideline => {\n                const groupPos = groupGuideline.pos;\n                const renderPos = -targetContentPos + groupPos[index];\n\n                if (groupPos[otherIndex] !== inlinePos) {\n                    return true;\n                }\n                if (gap < 0 && renderPos < 0) {\n                    return false;\n                }\n                if (gap > 0 && renderPos > targetSizes[index]) {\n                    return false;\n                }\n                return true;\n            });\n        });\n    });\n\n    return {\n        guidelines: nextGuidelines,\n        groups,\n        gapGuidelines,\n    };\n}\nexport function renderGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    direction: string,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    React: Renderer\n) {\n    const { zoom } = moveable.props;\n\n    return guidelines.filter(({ hide }) => {\n        return !hide;\n    }).map((guideline, i) => {\n        const { pos, size, element } = guideline;\n\n        const renderPos = [\n            -targetPos[0] + pos[0],\n            -targetPos[1] + pos[1],\n        ];\n\n        return renderInnerGuideline(\n            {\n                key: `${direction}Guideline${i}`,\n                classNames: element ? [prefix(\"bold\")] : [],\n                direction: direction,\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n            },\n            React\n        );\n    });\n}\n\nexport function renderGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    direction: \"vertical\" | \"horizontal\",\n    gapGuidelines: GapGuideline[],\n    snapDistFormat: Required<SnappableOptions>[\"snapDistFormat\"],\n    React: any\n): any[] {\n    const { snapDigit = 0, isDisplaySnapDigit = true, zoom } = moveable.props;\n    const scaleDirection = direction === \"horizontal\" ? \"X\" : \"Y\";\n    const sizeName = direction === \"horizontal\" ? \"width\" : \"height\";\n\n    return gapGuidelines.map(({ renderPos, gap, className, inner }, i) => {\n        const absGap = Math.abs(gap!);\n        const snapSize = isDisplaySnapDigit\n            ? parseFloat(absGap.toFixed(snapDigit))\n            : 0;\n        return (\n            <div\n                key={`${direction}GapGuideline${i}`}\n                className={prefix(\"guideline-group\", direction)}\n                style={{\n                    left: `${renderPos[0]}px`,\n                    top: `${renderPos[1]}px`,\n                    [sizeName]: `${absGap}px`,\n                }}\n            >\n                {renderInnerGuideline(\n                    {\n                        direction: direction,\n                        classNames: [prefix(inner ? \"dashed\" : \"gap\"), className],\n                        size: \"100%\",\n                        posValue: [0, 0],\n                        sizeValue: absGap,\n                        zoom: zoom!,\n                    },\n                    React\n                )}\n                <div\n                    className={prefix(\"size-value\", \"gap\")}\n                    style={{\n                        transform: `translate${scaleDirection}(-50%) scale(${zoom})`,\n                    }}\n                >\n                    {snapSize > 0 ? snapDistFormat(snapSize) : \"\"}\n                </div>\n            </div>\n        );\n    });\n}\n","import {\n    Renderer,\n    SnappableProps,\n    SnappableState,\n    SnapGuideline,\n    SnapInfo,\n    BoundInfo,\n    ScalableProps,\n    SnapPosInfo,\n    RotatableProps,\n    RectInfo,\n    DraggableProps,\n    SnapOffsetInfo,\n    GapGuideline,\n    MoveableManagerInterface,\n    SnappableRenderType,\n    BoundType,\n    SnapBoundInfo,\n    MoveableGroupInterface,\n} from \"../types\";\nimport {\n    prefix,\n    calculatePoses,\n    getRect,\n    getAbsolutePosesByState,\n    getAbsolutePoses,\n    getDistSize,\n    groupBy,\n    flat,\n    maxOffset,\n    minOffset,\n    triggerEvent,\n    calculateInversePosition,\n    directionCondition,\n    getClientRect,\n    getRefTarget,\n    getDragDistByState,\n} from \"../utils\";\nimport {\n    IObject, findIndex, hasClass, getRad, getDist,\n    throttle,\n} from \"@daybrush/utils\";\nimport {\n    getPosByReverseDirection,\n    getDragDist,\n    scaleMatrix,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { minus, rotate, plus } from \"@scena/matrix\";\nimport { dragControlCondition as rotatableDragControlCondtion } from \"./Rotatable\";\nimport { FLOAT_POINT_NUM, TINY_NUM } from \"../consts\";\nimport {\n    getInnerBoundInfo,\n    getCheckInnerBoundLines,\n    getInnerBoundDragInfo,\n    checkRotateInnerBounds,\n    checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport {\n    checkBoundPoses,\n    checkRotateBounds,\n    checkBoundKeepRatio,\n    getBounds,\n} from \"./snappable/bounds\";\nimport {\n    checkSnaps,\n    getSnapInfosByDirection,\n    checkMoveableSnapPoses,\n    getNearestSnapGuidelineInfo,\n    getNearOffsetInfo,\n    checkSnapKeepRatio,\n    checkSnapPoses,\n    getElementGuidelines,\n    calculateContainerPos,\n    getTotalGuidelines,\n} from \"./snappable/snap\";\nimport {\n    renderElementGroups, renderSnapPoses,\n    renderGuidelines, renderGapGuidelines,\n    filterElementInnerGuidelines,\n} from \"./snappable/render\";\n\ninterface DirectionSnapType<T> {\n    vertical: T;\n    horizontal: T;\n}\n\n\nexport function snapStart(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n) {\n    const state = moveable.state;\n\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n    const container = moveable.state.container;\n    const snapContainer = moveable.props.snapContainer || container!;\n\n    const containerClientRect = state.containerClientRect;\n    const snapOffset = {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n    };\n\n    if (container !== snapContainer) {\n        const snapContainerTarget = getRefTarget(snapContainer, true);\n\n        if (snapContainerTarget) {\n            const snapContainerRect = getClientRect(snapContainerTarget);\n            const offset1 = getDragDistByState(state, [\n                snapContainerRect.left - containerClientRect.left,\n                snapContainerRect.top - containerClientRect.top,\n            ]);\n            const offset2 = getDragDistByState(state, [\n                snapContainerRect.right - containerClientRect.right,\n                snapContainerRect.bottom - containerClientRect.bottom,\n            ]);\n            snapOffset.left = throttle(offset1[0], 0.1);\n            snapOffset.top = throttle(offset1[1], 0.1);\n            snapOffset.right = throttle(offset2[0], 0.1);\n            snapOffset.bottom = throttle(offset2[1], 0.1);\n        }\n    }\n\n    state.snapOffset = snapOffset;\n    state.elementGuidelineValues = [];\n    state.staticGuidelines = getElementGuidelines(moveable, false);\n    state.guidelines = getTotalGuidelines(moveable);\n    state.enableSnap = true;\n}\n\nexport function hasGuidelines(\n    moveable: MoveableManagerInterface<any, any>,\n    ableName: string\n): moveable is MoveableManagerInterface<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            innerBounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n            snapGridWidth,\n            snapGridHeight,\n        },\n        state: { guidelines, enableSnap },\n    } = moveable;\n\n    if (\n        !snappable ||\n        !enableSnap ||\n        (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        snapGridWidth ||\n        snapGridHeight ||\n        bounds ||\n        innerBounds ||\n        (guidelines && guidelines.length) ||\n        (verticalGuidelines && verticalGuidelines.length) ||\n        (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>\n) {\n    const sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n\n    if (!sizeOffset) {\n        return {\n            isOutside: false,\n            offset: [0, 0],\n        };\n    }\n    const size = getDist(pos1, pos2);\n    const dist1 = getDist(sizeOffset, pos1);\n    const dist2 = getDist(sizeOffset, pos2);\n\n    const isOutside = dist1 > size || dist2 > size;\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return {\n        offset: [widthOffset, heightOffset],\n        isOutside,\n    };\n}\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    direction: number[],\n    is3d: boolean\n) {\n    const nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextPos = getPosByReverseDirection(nextPoses, direction);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n    isRequest: boolean\n): DirectionSnapType<SnapBoundInfo> {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(moveable, startPos, endPos);\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? ({\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any) : checkSnapKeepRatio(moveable, startPos, endPos);\n\n    const horizontalOffset = getSnapBoundOffset(\n        horizontalBoundInfo,\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBoundOffset(\n        verticalBoundInfo,\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function checkMoveableSnapBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    isRequest: boolean,\n    poses: number[][],\n    boundPoses: number[][] = poses\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable),\n        boundPoses.map((pos) => pos[0]),\n        boundPoses.map((pos) => pos[1])\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false, index: -1 } as SnapInfo,\n        vertical: { isSnap: false, index: -1 } as SnapInfo,\n    } : checkMoveableSnapPoses(\n        moveable,\n        poses.map((pos) => pos[0]),\n        poses.map((pos) => pos[1]),\n        moveable.props.snapCenter\n    );\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\nexport function checkSnapBounds(\n    guideines: SnapGuideline[],\n    bounds: BoundType | undefined | false,\n    posesX: number[],\n    posesY: number[],\n    options: {\n        isRequest?: boolean;\n        snapThreshold?: number;\n        snapCenter?: boolean;\n        snapElement?: boolean;\n    } = {}\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(bounds, posesX, posesY);\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = options.isRequest ? {\n        horizontal: { isSnap: false, index: -1 } as SnapInfo,\n        vertical: { isSnap: false, index: -1 } as SnapInfo,\n    } : checkSnapPoses(guideines, posesX, posesY, options);\n\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\nexport function normalized(value: number) {\n    return value ? value / Math.abs(value) : 0;\n}\nexport function checkMaxBounds(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    fixedPosition: number[],\n    datas: any\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const { width, height } = moveable.state;\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach((otherDirection) => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n            const deg = (getRad(fixedPosition, otherPos) * 360) / Math.PI;\n\n            if (isCheckHorizontal) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPosition[1];\n                }\n                const {\n                    offset: [, heightOffset],\n                    isOutside: isHeightOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[1] < otherPos[1] ? bottom : top) -\n                    otherPos[1],\n                    false,\n                    datas\n                );\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);\n                }\n            }\n            if (isCheckVertical) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPosition[0];\n                }\n                const {\n                    offset: [widthOffset],\n                    isOutside: isWidthOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true,\n                    datas\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\nfunction checkSnapRightLine(\n    startPos: number[],\n    endPos: number[],\n    snapBoundInfo: { vertical: SnapBoundInfo; horizontal: SnapBoundInfo },\n    keepRatio: boolean\n) {\n    const rad = (getRad(startPos, endPos) / Math.PI) * 180;\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            dist: verticalDist,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            dist: horizontalDist,\n        },\n    } = snapBoundInfo;\n\n    const rad180 = rad % 180;\n    const isHorizontalLine = rad180 < 3 || rad180 > 177;\n    const isVerticalLine = rad180 > 87 && rad180 < 93;\n\n    if (horizontalDist < verticalDist) {\n        if (\n            isVerticalBound ||\n            (isVerticalSnap &&\n                !isVerticalLine &&\n                (!keepRatio || !isHorizontalLine))\n        ) {\n            return \"vertical\";\n        }\n    }\n    if (\n        isHorizontalBound ||\n        (isHorizontalSnap &&\n            !isHorizontalLine &&\n            (!keepRatio || !isVerticalLine))\n    ) {\n        return \"horizontal\";\n    }\n    return \"\";\n}\nfunction getSnapBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n        const snapBoundInfo = keepRatio\n            ? checkSnapBoundsKeepRatio(\n                moveable,\n                otherStartPos,\n                otherEndPos,\n                isRequest\n            )\n            : checkMoveableSnapBounds(moveable, isRequest, [otherEndPos]);\n\n        const {\n            horizontal: {\n                // dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                // dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const snapLine = checkSnapRightLine(\n            otherStartPos,\n            otherEndPos,\n            snapBoundInfo,\n            keepRatio\n        );\n\n        if (!snapLine) {\n            return {\n                sign: multiple,\n                isBound: false,\n                isSnap: false,\n                offset: [0, 0],\n            };\n        }\n\n        const isVertical = snapLine === \"vertical\";\n        const sizeOffset = solveNextOffset(\n            otherStartPos,\n            otherEndPos,\n            -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n            isVertical,\n            datas,\n        ).offset.map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\nexport function getCheckSnapDirections(\n    direction: number[],\n    keepRatio: boolean\n) {\n    const directions: number[][][] = [];\n    const fixedDirection = [-direction[0], -direction[1]];\n\n    if (direction[0] && direction[1]) {\n        directions.push(\n            [fixedDirection, [direction[0], -direction[1]]],\n            [fixedDirection, [-direction[0], direction[1]]]\n        );\n        if (keepRatio) {\n            // pass two direction condition\n            directions.push([fixedDirection, direction]);\n        }\n    } else if (direction[0]) {\n        // vertcal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [fixedDirection[0], -1]],\n                [fixedDirection, [fixedDirection[0], 1]],\n                [fixedDirection, [direction[0], -1]],\n                [fixedDirection, direction],\n                [fixedDirection, [direction[0], 1]]\n            );\n        } else {\n            directions.push(\n                [\n                    [fixedDirection[0], -1],\n                    [direction[0], -1],\n                ],\n                [\n                    [fixedDirection[0], 0],\n                    [direction[0], 0],\n                ],\n                [\n                    [fixedDirection[0], 1],\n                    [direction[0], 1],\n                ]\n            );\n        }\n    } else if (direction[1]) {\n        // horizontal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [-1, fixedDirection[1]]],\n                [fixedDirection, [1, fixedDirection[1]]],\n                [fixedDirection, [-1, direction[1]]],\n                [fixedDirection, [1, direction[1]]],\n                [fixedDirection, direction]\n            );\n        } else {\n            directions.push(\n                [\n                    [-1, fixedDirection[1]],\n                    [-1, direction[1]],\n                ],\n                [\n                    [0, fixedDirection[1]],\n                    [0, direction[1]],\n                ],\n                [\n                    [1, fixedDirection[1]],\n                    [1, direction[1]],\n                ]\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        directions.push(\n            [fixedDirection, [1, 0]],\n            [fixedDirection, [-1, 0]],\n            [fixedDirection, [0, -1]],\n            [fixedDirection, [0, 1]],\n\n            [\n                [1, 0],\n                [1, -1],\n            ],\n            [\n                [1, 0],\n                [1, 1],\n            ],\n            [\n                [0, 1],\n                [1, 1],\n            ],\n            [\n                [0, 1],\n                [-1, 1],\n            ],\n\n            [\n                [-1, 0],\n                [-1, -1],\n            ],\n            [\n                [-1, 0],\n                [-1, 1],\n            ],\n            [\n                [0, -1],\n                [1, -1],\n            ],\n            [\n                [0, -1],\n                [-1, -1],\n            ]\n        );\n    }\n\n    return directions;\n}\nexport function getSizeOffsetInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    const directions = getCheckSnapDirections(direction, keepRatio);\n    const lines = getCheckInnerBoundLines(poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(\n            moveable,\n            poses,\n            directions,\n            keepRatio,\n            isRequest,\n            datas\n        ),\n        ...getInnerBoundInfo(\n            moveable,\n            lines,\n            getPosByDirection(poses, [0, 0]),\n            datas\n        ),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: { offset: horizontalOffset },\n        vertical: { offset: verticalOffset },\n    } = checkMoveableSnapBounds(moveable, isRequest, [snapPos]);\n\n    if (verticalOffset || horizontalOffset) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n        const nextWidth = Math.min(\n            maxWidth || Infinity,\n            width + direction[0] * nextWidthOffset\n        );\n        const nextHeight = Math.min(\n            maxHeight || Infinity,\n            height + direction[1] * nextHeightOffset\n        );\n\n        return [nextWidth - width, nextHeight - height];\n    }\n    return [0, 0];\n}\nexport function checkSizeDist(\n    moveable: MoveableManagerInterface<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            isRequest,\n            datas\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist =\n                Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist =\n                Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset =\n                isWidthBound && isHeightBound\n                    ? widthDist < heightDist\n                    : isHeightBound ||\n                    (!isWidthBound && widthDist < heightDist);\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = (width * nextHeightOffset) / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = (height * nextWidthOffset) / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    if (direction[0] && direction[1]) {\n        const { maxWidth, maxHeight } = checkMaxBounds(\n            moveable,\n            poses,\n            direction,\n            fixedPosition,\n            datas\n        );\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset).map(pos => pos.map(p => throttle(p, FLOAT_POINT_NUM))),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            isRequest,\n            datas\n        );\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [widthOffset, heightOffset];\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    origin: number[],\n    rotation: number\n) {\n    if (!hasGuidelines(moveable, \"rotatable\")) {\n        return rotation;\n    }\n\n    const { pos1, pos2, pos3, pos4 } = rect;\n    const rad = (rotation * Math.PI) / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map((pos) => minus(pos, origin));\n    const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n    const result = [\n        ...checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation),\n        ...checkRotateInnerBounds(\n            moveable,\n            prevPoses,\n            nextPoses,\n            origin,\n            rotation\n        ),\n    ];\n    result.sort((a, b) => Math.abs(a - rotation) - Math.abs(b - rotation));\n\n    if (result.length) {\n        return result[0];\n    } else {\n        return rotation;\n    }\n}\nexport function checkSnapResize(\n    moveable: MoveableManagerInterface<{}, {}>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const { allMatrix, is3d } = moveable.state;\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                allMatrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedPosition,\n                direction,\n                is3d\n            );\n        },\n        width,\n        height,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManagerInterface<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const { width, height, fixedPosition } = datas;\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const is3d = datas.is3d;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(\n                    datas,\n                    plus(scale, [widthOffset / width, heightOffset / height]),\n                ),\n                width,\n                height,\n                fixedPosition,\n                direction,\n                is3d\n            );\n        },\n        width,\n        height,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n\n    return [sizeDist[0] / width, sizeDist[1] / height];\n}\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: any\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[]\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses: number[][] = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalBound) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset]);\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalSnap) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset]);\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return (\n                    getDistSize(minus([distX, distY], a)) -\n                    getDistSize(minus([distX, distY], b))\n                );\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY =\n                    (distY * Math.abs(distX + offsetX)) / Math.abs(distX) -\n                    distY;\n            } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX =\n                    (distX * Math.abs(distY + offsetY)) / Math.abs(prevDistY) -\n                    distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (\n                    Math.abs(offsetX) > TINY_NUM &&\n                    Math.abs(offsetX) < Math.abs(verticalOffset)\n                ) {\n                    const scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (\n                    Math.abs(offsetY) > TINY_NUM &&\n                    Math.abs(offsetY) < Math.abs(horizontalOffset)\n                ) {\n                    const scale =\n                        Math.abs(horizontalOffset) / Math.abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n        offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\nexport function checkSnapDrag(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n    const { left, right, top, bottom } = getRect(poses);\n    const snapCenter = moveable.props.snapCenter;\n    const snapPoses = [\n        [left, top],\n        [right, top],\n        [left, bottom],\n        [right, bottom],\n    ];\n\n    if (snapCenter) {\n        snapPoses.push([(left + right) / 2, (top + bottom) / 2]);\n    }\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkMoveableSnapBounds(moveable, isRequest, snapPoses, poses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound =\n        verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound =\n        horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(\n        verticalSnapBoundInfo.offset,\n        verticalInnerBoundInfo.offset\n    );\n    const horizontalOffset = maxOffset(\n        horizontalSnapBoundInfo.offset,\n        horizontalInnerBoundInfo.offset\n    );\n\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset]\n    );\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: SnapGuideline[] = [];\n\n    posInfos.forEach((posInfo) => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\n\nfunction getGapGuidelinesToStart(\n    guidelines: SnapGuideline[],\n    index: number,\n    targetPos: number[],\n    targetSizes: number[],\n    guidelinePos: number[],\n    gap: number,\n    otherPos: number\n): GapGuideline[] {\n    const absGap = Math.abs(gap);\n    let start = guidelinePos[index] + (gap > 0 ? targetSizes[0] : 0);\n\n    return guidelines\n        .filter(({ pos: gapPos }) => gapPos[index] <= targetPos[index])\n        .sort(({ pos: aPos }, { pos: bPos }) => bPos[index] - aPos[index])\n        .filter(({ pos: gapPos, sizes: gapSizes }) => {\n            const nextPos = gapPos[index];\n\n            if (\n                throttle(nextPos + gapSizes![index], FLOAT_POINT_NUM) ===\n                throttle(start - absGap, FLOAT_POINT_NUM)\n            ) {\n                start = nextPos;\n                return true;\n            }\n            return false;\n        })\n        .map((gapGuideline) => {\n            const renderPos =\n                -targetPos[index] +\n                gapGuideline.pos[index] +\n                gapGuideline.sizes![index];\n\n            return {\n                ...gapGuideline,\n                gap,\n                renderPos: index\n                    ? [otherPos, renderPos]\n                    : [renderPos, otherPos],\n            };\n        });\n}\nfunction getGapGuidelinesToEnd(\n    guidelines: SnapGuideline[],\n    index: number,\n    targetPos: number[],\n    targetSizes: number[],\n    guidelinePos: number[],\n    gap: number,\n    otherPos: number\n): GapGuideline[] {\n    const absGap = Math.abs(gap);\n    let start = guidelinePos[index] + (gap < 0 ? targetSizes[index] : 0);\n\n    return guidelines\n        .filter(({ pos: gapPos }) => gapPos[index] > targetPos[index])\n        .sort(({ pos: aPos }, { pos: bPos }) => aPos[index] - bPos[index])\n        .filter(({ pos: gapPos, sizes: gapSizes }) => {\n            const nextPos = gapPos[index];\n\n            if (\n                throttle(nextPos, FLOAT_POINT_NUM) === throttle(start + absGap, FLOAT_POINT_NUM)\n            ) {\n                start = nextPos + gapSizes![index];\n                return true;\n            }\n            return false;\n        })\n        .map((gapGuideline) => {\n            const renderPos =\n                -targetPos[index] + gapGuideline.pos[index] - absGap;\n\n            return {\n                ...gapGuideline,\n                gap,\n                renderPos: index\n                    ? [otherPos, renderPos]\n                    : [renderPos, otherPos],\n            };\n        });\n}\nfunction getGapGuidelines(\n    guidelines: SnapGuideline[],\n    type: \"vertical\" | \"horizontal\",\n    targetPos: number[],\n    targetSizes: number[]\n): GapGuideline[] {\n    const elementGuidelines = guidelines.filter(\n        ({ element, gap, type: guidelineType }) =>\n            element && gap && guidelineType === type\n    );\n    const [index, otherIndex] = type === \"vertical\" ? [0, 1] : [1, 0];\n\n    return flat(\n        elementGuidelines.map((guideline) => {\n            const pos = guideline.pos;\n            const gap = guideline.gap!;\n            const gapGuidelines = guideline.gapGuidelines!;\n            const sizes = guideline.sizes!;\n\n            let offset = minOffset(\n                pos[otherIndex] + sizes[otherIndex] - targetPos[otherIndex],\n                pos[otherIndex] -\n                targetPos[otherIndex] -\n                targetSizes[otherIndex]\n            );\n            const minSize = Math.min(\n                sizes[otherIndex],\n                targetSizes[otherIndex]\n            );\n\n            if (offset > 0 && offset > minSize) {\n                offset = (offset - minSize / 2) * 2;\n            } else if (offset < 0 && offset < -minSize) {\n                offset = (offset + minSize / 2) * 2;\n            }\n            if (offset === 0) {\n                return [];\n            }\n\n            const otherPos =\n                (offset > 0 ? 0 : targetSizes[otherIndex]) + offset / 2;\n\n            return [\n                ...getGapGuidelinesToStart(\n                    gapGuidelines,\n                    index,\n                    targetPos,\n                    targetSizes,\n                    pos,\n                    gap,\n                    otherPos\n                ),\n                ...getGapGuidelinesToEnd(\n                    gapGuidelines,\n                    index,\n                    targetPos,\n                    targetSizes,\n                    pos,\n                    gap,\n                    otherPos\n                ),\n            ];\n        })\n    );\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: SnappableRenderType[],\n    horizontalSnapPoses: SnappableRenderType[],\n    externalBounds?: BoundType | false | null\n) {\n    const {\n        vertical: verticalBoundInfos,\n        horizontal: horizontalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable, externalBounds),\n        verticalPoses,\n        horizontalPoses\n    );\n    verticalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            verticalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    horizontalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            horizontalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    const {\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                verticalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n\n    horizontalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                horizontalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n}\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\nexport default {\n    name: \"snappable\",\n    props: {\n        snappable: [Boolean, Array],\n        snapContainer: Object,\n        snapCenter: Boolean,\n        snapHorizontal: Boolean,\n        snapVertical: Boolean,\n        snapElement: Boolean,\n        snapGap: Boolean,\n        snapGridWidth: Number,\n        snapGridHeight: Number,\n        isDisplaySnapDigit: Boolean,\n        isDisplayInnerSnapDigit: Boolean,\n        snapDigit: Number,\n        snapThreshold: Number,\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n        bounds: Object,\n        innerBounds: Object,\n        snapDistFormat: Function,\n    } as const,\n    events: {\n        onSnap: \"snap\",\n    } as const,\n    css: [\n        `:host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n`,\n    ],\n    render(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        React: Renderer\n    ): any[] {\n        const state = moveable.state;\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            snapRenderInfo,\n            targetClientRect,\n            containerClientRect,\n            is3d,\n            rootMatrix,\n        } = state;\n\n        if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n        state.staticGuidelines = getElementGuidelines(moveable, false, state.staticGuidelines);\n        state.guidelines = getTotalGuidelines(moveable);\n\n        const n = is3d ? 4 : 3;\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        const containerPos = calculateContainerPos(\n            rootMatrix,\n            containerClientRect,\n            n\n        );\n        const [clientLeft, clientTop] = calculateInversePosition(\n            rootMatrix,\n            [\n                targetClientRect.left - containerPos[0],\n                targetClientRect.top - containerPos[1],\n            ],\n            n\n        );\n\n        const {\n            snapThreshold = 5,\n            snapDigit = 0,\n            snapDistFormat = (v: number) => v,\n        } = moveable.props;\n        const externalPoses = snapRenderInfo.externalPoses || [];\n        const poses = getAbsolutePosesByState(moveable.state);\n        const verticalSnapPoses: SnappableRenderType[] = [];\n        const horizontalSnapPoses: SnappableRenderType[] = [];\n        const verticalGuidelines: SnapGuideline[] = [];\n        const horizontalGuidelines: SnapGuideline[] = [];\n        const snapInfos: Array<{\n            vertical: SnapInfo;\n            horizontal: SnapInfo;\n        }> = [];\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const hasExternalPoses = externalPoses.length > 0;\n        const externalRect = hasExternalPoses\n            ? getRect(externalPoses)\n            : ({} as ReturnType<typeof getRect>);\n\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(\n                    getSnapInfosByDirection(\n                        moveable,\n                        poses,\n                        snapRenderInfo.direction\n                    )\n                );\n            }\n            if (snapRenderInfo.snap) {\n                const rect = getRect(poses);\n\n                if (snapRenderInfo.center) {\n                    (rect as any).middle = (rect.top + rect.bottom) / 2;\n                    (rect as any).center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, true, 1));\n            }\n            if (hasExternalPoses) {\n                if (snapRenderInfo.center) {\n                    (externalRect as any).middle =\n                        (externalRect.top + externalRect.bottom) / 2;\n                    (externalRect as any).center =\n                        (externalRect.left + externalRect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, externalRect, true, 1));\n            }\n            snapInfos.forEach((snapInfo) => {\n                const {\n                    vertical: { posInfos: verticalPosInfos },\n                    horizontal: { posInfos: horizontalPosInfos },\n                } = snapInfo;\n                verticalSnapPoses.push(\n                    ...verticalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                horizontalSnapPoses.push(\n                    ...horizontalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n                horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n            });\n        }\n\n        addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses\n        );\n        if (hasExternalPoses) {\n            addBoundGuidelines(\n                moveable,\n                [externalRect.left, externalRect.right],\n                [externalRect.top, externalRect.bottom],\n                verticalSnapPoses,\n                horizontalSnapPoses,\n                snapRenderInfo.externalBounds\n            );\n        }\n\n\n        const gapHorizontalGuidelines = getGapGuidelines(\n            verticalGuidelines,\n            \"vertical\",\n            [targetLeft, targetTop],\n            [width, height]\n        );\n        const gapVerticalGuidelines = getGapGuidelines(\n            horizontalGuidelines,\n            \"horizontal\",\n            [targetLeft, targetTop],\n            [width, height]\n        );\n\n        const allGuidelines = [...verticalGuidelines, ...horizontalGuidelines];\n        triggerEvent(\n            moveable,\n            \"onSnap\",\n            {\n                guidelines: allGuidelines.filter(({ element }) => !element),\n                elements: groupBy(\n                    allGuidelines.filter(({ element }) => element),\n                    ({ element }) => element\n                ),\n                gaps: [...gapVerticalGuidelines, ...gapHorizontalGuidelines],\n            },\n            true\n        );\n        const {\n            guidelines: nextHorizontalGuidelines,\n            groups: elementHorizontalGroups,\n            gapGuidelines: innerGapHorizontalGuidelines,\n        } = filterElementInnerGuidelines(\n            moveable,\n            horizontalGuidelines,\n            0,\n            [targetLeft, targetTop],\n            [clientLeft, clientTop],\n            [width, height],\n        );\n        const {\n            guidelines: nextVerticalGuidelines,\n            groups: elementVerticalGroups,\n            gapGuidelines: innerGapVerticalGuidelines,\n        } = filterElementInnerGuidelines(\n            moveable,\n            verticalGuidelines,\n            1,\n            [targetLeft, targetTop],\n            [clientLeft, clientTop],\n            [width, height],\n        );\n\n        return [\n            ...renderGapGuidelines(\n                moveable,\n                \"vertical\",\n                [...gapVerticalGuidelines, ...innerGapVerticalGuidelines],\n                snapDistFormat,\n                React\n            ),\n            ...renderGapGuidelines(\n                moveable,\n                \"horizontal\",\n                [...gapHorizontalGuidelines, ...innerGapHorizontalGuidelines],\n                snapDistFormat,\n                React\n            ),\n            ...renderElementGroups(\n                moveable,\n                \"horizontal\",\n                elementHorizontalGroups,\n                minLeft,\n                clientLeft,\n                width,\n                targetTop,\n                snapThreshold,\n                snapDigit,\n                0,\n                snapDistFormat,\n                React\n            ),\n            ...renderElementGroups(\n                moveable,\n                \"vertical\",\n                elementVerticalGroups,\n                minTop,\n                clientTop,\n                height,\n                targetLeft,\n                snapThreshold,\n                snapDigit,\n                1,\n                snapDistFormat,\n                React\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"horizontal\",\n                nextHorizontalGuidelines,\n                [targetLeft, targetTop],\n                React\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"vertical\",\n                nextVerticalGuidelines,\n                [targetLeft, targetTop],\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"horizontal\",\n                horizontalSnapPoses,\n                minLeft,\n                targetTop,\n                width,\n                0,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"vertical\",\n                verticalSnapPoses,\n                minTop,\n                targetLeft,\n                height,\n                1,\n                React\n            ),\n        ];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        e: any\n    ) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        snapStart(moveable);\n    },\n    drag(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        const state = moveable.state;\n        state.staticGuidelines = getElementGuidelines(moveable, false, state.staticGuidelines);\n        state.guidelines = getTotalGuidelines(moveable);\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragControlCondition(moveable: MoveableManagerInterface, e: any) {\n        if (directionCondition(moveable, e) || rotatableDragControlCondtion(moveable, e)) {\n            return true;\n        }\n        if (!e.isRequest && e.inputEvent) {\n            return hasClass(e.inputEvent.target, prefix(\"snap-control\"));\n        }\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragGroupControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupControlEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.staticGuidelines = [];\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n    },\n};\n\n\n/**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable.Snappable#snappable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n/**\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\n * @name Moveable.Snappable#snapContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.querySelector(\".container\"));\n *\n * moveable.snapContainer = document.body;\n */\n/**\n * When you drag, make the snap in the center of the target. (default: false)\n * @name Moveable.Snappable#snapCenter\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n * });\n *\n * moveable.snapCenter = true;\n */\n\n/**\n * When you drag, make the snap in the vertical guidelines. (default: true)\n * @name Moveable.Snappable#snapVertical\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapVertical = false;\n */\n/**\n * When you drag, make the snap in the horizontal guidelines. (default: true)\n * @name Moveable.Snappable#snapHorizontal\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapHorizontal = false;\n */\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n/**\n * When you drag, make the snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapElement\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapElement = false;\n */\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidelines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidelines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries. (default: null)\n * @name Moveable.Snappable#bounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * You can set up inner boundaries. (default: null)\n * @name Moveable.Snappable#innerBounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n\n/**\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridWidth\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridWidth = 5;\n */\n\n/**\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridHeight\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridHeight = 5;\n */\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * Whether to show element inner snap distance (default: false)\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplayInnerSnapDigit = true;\n */\n\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: v => v,\n * });\n * moveable.snapDistFormat = v => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n","import {\n    setDragStart, getBeforeDragDist, getTransformDist,\n    convertTransformFormat, resolveTransformEvent, fillTransformStartEvent, setDefaultTransformIndex,\n} from \"../gesto/GestoUtils\";\nimport {\n    triggerEvent, fillParams,\n    getDistSize, prefix,\n    fillEndParams, getComputedStyle,\n} from \"../utils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState,\n    Renderer, OnDragGroupEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildGesto } from \"../groupUtils\";\nimport { checkSnapDrag, startCheckSnapDrag } from \"./Snappable\";\nimport { IObject, getRad, throttle, throttleArray } from \"@daybrush/utils\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n        startDragRotate: Number,\n        edgeDraggable: Boolean,\n    } as const,\n    events: {\n        onDragStart: \"dragStart\",\n        onDrag: \"drag\",\n        onDragEnd: \"dragEnd\",\n        onDragGroupStart: \"dragGroupStart\",\n        onDragGroup: \"dragGroup\",\n        onDragGroupEnd: \"dragGroupEnd\",\n    } as const,\n    render(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        React: Renderer,\n    ): any[] {\n        const { throttleDragRotate, zoom } = moveable.props;\n        const { dragInfo, beforeOrigin } = moveable.state;\n\n        if (!throttleDragRotate || !dragInfo) {\n            return [];\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return [];\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return [<div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        }} />];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentGesto } = e;\n        const state = moveable.state;\n        const {\n            target,\n            gesto,\n        } = state;\n\n        if (gesto) {\n            return false;\n        }\n        state.gesto = parentGesto || moveable.targetGesto;\n        const style = getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.startValue = [0, 0];\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(e, \"translate\");\n        startCheckSnapDrag(moveable, datas);\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startValue = translate;\n            },\n            ...fillTransformStartEvent(e),\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            state.gesto = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        resolveTransformEvent(e, \"translate\");\n\n        const { datas, parentEvent, parentFlag, isPinch, isRequest } = e;\n        let { distX, distY } = e;\n        const { isDrag, prevDist, prevBeforeDist, startValue } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let isSnap = false;\n        let dragRotateRad = 0;\n\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            const startDragRotate = props.startDragRotate || 0;\n            const deg\n                = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate)\n                - startDragRotate;\n            const ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n            const rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n            const r = getDistSize([rx, ry]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {\n            const [verticalInfo, horizontalInfo] = checkSnapDrag(\n                moveable, distX, distY, throttleDragRotate, isRequest, datas,\n            );\n            const {\n                isSnap: isVerticalSnap,\n                isBound: isVerticalBound,\n                offset: verticalOffset,\n            } = verticalInfo;\n            const {\n                isSnap: isHorizontalSnap,\n                isBound: isHorizontalBound,\n                offset: horizontalOffset,\n            } = horizontalInfo;\n            isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n        datas.passDeltaX = distX - (datas.passDistX || 0);\n        datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDistX = distX;\n        datas.passDistY = distY;\n        const beforeTranslate = plus(getBeforeDragDist({ datas, distX, distY }), startValue);\n        const translate = plus(getTransformDist({ datas, distX, distY }), startValue);\n\n        if (!throttleDragRotate && !isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n\n        const beforeDist = minus(beforeTranslate, startValue);\n        const dist = minus(translate, startValue);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = convertTransformFormat(datas,\n            `translate(${translate[0]}px, ${translate[1]}px)`, `translate(${dist[0]}px, ${dist[1]}px)`);\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            width,\n            height,\n            isPinch,\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas, isDrag } = e;\n\n        moveable.state.gesto = null;\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillEndParams<OnDragEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, clientX, clientY } = e;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildGesto(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0,\n        ], e, false);\n\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDeltaX, passDeltaY } = e.datas;\n        const events = triggerChildGesto(moveable, this, \"drag\", [passDeltaX, passDeltaY], e, false);\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        triggerChildGesto(moveable, this, \"dragEnd\", [0, 0], e, false);\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams<OnDragGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        return {\n            isControl: false,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n};\n\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group drag starts, the `dragGroupStart` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroupStart\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\n*     console.log(\"onDragGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group drag, the `dragGroup` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroup\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\n*     console.log(\"onDragGroup\", targets);\n*     events.forEach(ev => {\n*          // drag event\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\n*          // ev.target!.style.left = `${ev.left}px`;\n*          // ev.target!.style.top = `${ev.top}px`;\n*          console.log(\"onDrag translate\", ev.dist);\n*          ev.target!.style.transform = ev.transform;)\n*     });\n* });\n*/\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n","import { prefix, getControlTransform, getLineStyle } from \"./utils\";\nimport { Renderer, MoveableManagerInterface, RenderDirections } from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS, DIRECTIONS } from \"./consts\";\nimport { IObject, throttle, getRad } from \"@daybrush/utils\";\n\nexport function renderDirectionControls(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    defaultDirections: string[],\n    React: Renderer,\n    additionalClassName: string = \"\",\n): any[] {\n    const {\n        renderPoses,\n        rotation: radRotation,\n        direction,\n    } = moveable.state;\n    const {\n        renderDirections: directions = defaultDirections,\n        zoom,\n    } = moveable.props;\n\n    const directionMap: IObject<boolean> = {};\n\n    if (!directions) {\n        return [];\n    }\n    const sign = (direction > 0 ? 1 : -1);\n    const renderDirections = directions === true ? DIRECTIONS : directions;\n    const degRotation = radRotation / Math.PI * 180;\n\n    renderDirections.forEach(dir => {\n        directionMap[dir] = true;\n    });\n    return renderDirections.map(dir => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes || !directionMap[dir]) {\n            return null;\n        }\n        const directionRotation = (throttle(degRotation, 15) + sign * DIRECTION_ROTATIONS[dir] + 720) % 180;\n\n        return (\n            <div className={prefix(\"control\", \"direction\", dir, additionalClassName)}\n                data-rotation={directionRotation} data-direction={dir} key={`direction-${dir}`}\n                style={getControlTransform(radRotation, zoom!, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\nexport function renderLine(\n    React: Renderer, direction: string,\n    pos1: number[], pos2: number[],\n    zoom: number,\n    key: number | string, ...classNames: string[]) {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line${key}`} className={prefix(\"line\", \"direction\", direction, ...classNames)}\n        data-rotation={rotation}\n        data-line-index={key}\n        data-direction={direction} style={getLineStyle(pos1, pos2, zoom, rad)}></div>;\n}\nexport function renderAllDirections(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    React: Renderer,\n) {\n    return renderDirectionControls(moveable, DIRECTIONS, React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    React: Renderer,\n): any[] {\n    return renderDirectionControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n","import {\n    prefix, triggerEvent, fillParams,\n    calculatePosition, fillEndParams, getRotationRad, getRefTargets,\n} from \"../utils\";\nimport {\n    IObject, hasClass, getRad,\n    throttle,\n} from \"@daybrush/utils\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps,\n    SnappableState, MoveableManagerInterface, MoveableGroupInterface, DraggableProps,\n    OnDragStart,\n} from \"../types\";\nimport { triggerChildAbles } from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { minus, plus, rotate as rotateMatrix } from \"@scena/matrix\";\nimport CustomGesto from \"../gesto/CustomGesto\";\nimport { checkSnapRotate } from \"./Snappable\";\nimport {\n    fillTransformStartEvent,\n    convertTransformFormat, getRotateDist,\n    getOriginDirection,\n    getDirectionOffset,\n    fillTransformEvent,\n    setDefaultTransformIndex,\n    resolveTransformEvent,\n    getTransformDirection,\n} from \"../gesto/GestoUtils\";\nimport { renderDirectionControls } from \"../renderDirections\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: IObject<any>, clientX: number, clientY: number, origin: number[], rect: MoveableClientRect) {\n\n    const n = moveable.state.is3d ? 4 : 3;\n    const nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);\n    const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.prevSnapDeg = datas.prevDeg;\n    datas.startDeg = datas.prevDeg;\n    datas.loop = 0;\n}\nfunction getParentDeg(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    parentDist: number,\n    direction: number,\n    startValue: number,\n) {\n    const {\n        prevDeg,\n    } = datas;\n\n    // const absoluteDeg = startValue + parentDist;\n    const dist = checkSnapRotate(\n        moveable,\n        moveableRect,\n        datas.origin,\n        parentDist,\n    );\n    datas.prevDeg = dist;\n\n    const delta = dist - prevDeg;\n\n    return [delta, dist, startValue + dist];\n}\nfunction getDeg(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    deg: number,\n    direction: number,\n    startValue: number,\n    throttleRotate: number,\n    isSnap?: boolean,\n) {\n    const {\n        prevDeg,\n        prevSnapDeg,\n        startDeg,\n        loop: prevLoop,\n    } = datas;\n\n    if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++datas.loop;\n    } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --datas.loop;\n    }\n    const loop = datas.loop;\n    const absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startValue;\n    let absoluteDeg = loop * 360 + deg - startDeg + startValue;\n\n    datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startValue;\n\n    absoluteDeg = throttle(absoluteDeg, throttleRotate);\n    let dist = direction * (absoluteDeg - startValue);\n    if (isSnap) {\n        dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n        absoluteDeg = dist / direction + startValue;\n    }\n    datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startValue;\n\n    const delta = direction * (absoluteDeg - absolutePrevSnapDeg);\n\n    return [delta, dist, startValue + dist];\n}\nfunction getRotateInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    direction: number,\n    clientX: number, clientY: number,\n    startValue: number,\n    throttleRotate: number,\n) {\n    return getDeg(\n        moveable,\n        moveableRect,\n        datas,\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        startValue,\n        throttleRotate,\n        true,\n    );\n}\n\nexport function getReversePositionX(dir: string) {\n    if (dir === \"left\") {\n        return \"right\";\n    } else if (dir === \"right\") {\n        return \"left\";\n    }\n    return dir;\n}\nexport function getReversePositionY(dir: string) {\n    if (dir === \"top\") {\n        return \"bottom\";\n    } else if (dir === \"bottom\") {\n        return \"top\";\n    }\n    return dir;\n}\nexport function getRotationPositions(\n    rotationPosition: RotatableProps[\"rotationPosition\"],\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number,\n) {\n    if (rotationPosition === \"none\") {\n        return;\n    }\n    const [dir1, dir2] = (rotationPosition || \"top\").split(\"-\");\n    let radPoses = [pos1, pos2];\n\n    // if (scale[0] < 0) {\n    //     dir1 = getReversePositionX(dir1);\n    //     dir2 = getReversePositionX(dir2);\n    // }\n    // if (scale[1] < 0) {\n    //     dir1 = getReversePositionY(dir1);\n    //     dir2 = getReversePositionY(dir2);\n    // }\n    if (dir1 === \"left\") {\n        radPoses = [pos3, pos1];\n    } else if (dir1 === \"right\") {\n        radPoses = [pos2, pos4];\n    } else if (dir1 === \"bottom\") {\n        radPoses = [pos4, pos3];\n    }\n    let pos = [\n        (radPoses[0][0] + radPoses[1][0]) / 2,\n        (radPoses[0][1] + radPoses[1][1]) / 2,\n    ];\n    const rad = getRotationRad(radPoses, direction);\n    if (dir2) {\n        const isStart = dir2 === \"top\" || dir2 === \"left\";\n        const isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n\n        pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\n    }\n    return [pos, rad] as const;\n}\n\nexport function dragControlCondition(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n    if (e.isRequest) {\n        return e.requestAble === \"rotatable\";\n    }\n    const target = e.inputEvent.target as HTMLElement;\n    if (hasClass(target, prefix(\"rotation-control\"))) {\n        return true;\n    }\n    const rotationTarget = moveable.props.rotationTarget;\n\n    if (rotationTarget) {\n        return getRefTargets(rotationTarget, true).some(element => {\n            if (!element) {\n                return false;\n            }\n            return target === element || target.contains(element);\n        });\n    }\n    return false;\n}\n\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n        renderDirections: Object,\n        rotationTarget: Object,\n    } as const,\n    events: {\n        onRotateStart: \"rotateStart\",\n        onRotate: \"rotate\",\n        onRotateEnd: \"rotateEnd\",\n        onRotateGroupStart: \"rotateGroupStart\",\n        onRotateGroup: \"rotateGroup\",\n        onRotateGroupEnd: \"rotateGroupEnd\",\n    } as const,\n    css: [\n        `.rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }`,\n    ],\n    render(moveable: MoveableManagerInterface<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n            zoom,\n            renderDirections,\n        } = moveable.props;\n        const {\n            renderPoses,\n            direction,\n        } = moveable.state;\n        if (!rotatable) {\n            return null;\n        }\n        const positions = getRotationPositions(rotationPosition!, renderPoses, direction);\n\n        const jsxs = [];\n\n        if (positions) {\n            const [pos, rad] = positions;\n            jsxs.push(\n                <div key=\"rotation\" className={prefix(\"rotation\")} style={{\n                    // tslint:disable-next-line: max-line-length\n                    transform: `translate(-50%) translate(${pos[0]}px, ${pos[1]}px) rotate(${rad}rad)`,\n                }}>\n                    <div className={prefix(\"line rotation-line\")} style={{\n                        transform: `scaleX(${zoom})`,\n                    }}></div>\n                    <div className={prefix(\"control rotation-control\")} style={{\n                        transform: `translate(0.5px) scale(${zoom})`,\n                    }}></div>\n                </div>\n            );\n        }\n        if (renderDirections) {\n            jsxs.push(...renderDirectionControls(moveable, [], React));\n        }\n\n\n        return jsxs;\n    },\n    dragControlCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<RotatableProps & SnappableProps & DraggableProps, SnappableState>,\n        e: any) {\n        const {\n            datas,\n            clientX, clientY,\n            parentRotate, parentFlag, isPinch,\n            isRequest,\n        } = e;\n        const {\n            target, left, top, origin, beforeOrigin,\n            direction, beforeDirection, targetTransform,\n            moveableClientRect,\n        } = moveable.state;\n\n        if (!isRequest && !target) {\n            return false;\n        }\n\n        const rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n        datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));\n        datas.absoluteInfo = {\n            origin: rect.origin,\n            startValue: rect.rotation,\n        };\n        setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);\n        if (isRequest || isPinch || parentFlag) {\n            const externalRotate = parentRotate || 0;\n\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n            datas.afterInfo = {\n                origin: rect.origin,\n                prevDeg: externalRotate, startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n        } else {\n            datas.beforeInfo = { origin: rect.beforeOrigin };\n            datas.afterInfo = { origin: rect.origin };\n\n            setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);\n            setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);\n        }\n\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startValue = 0;\n        datas.datas = {};\n\n        setDefaultTransformIndex(e, \"rotate\");\n\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startValue = rotatation * Math.PI / 180;\n            },\n            ...fillTransformStartEvent(e),\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ) as OnDragStart | false,\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n        };\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<RotatableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, isPinch, groupDelta } = e;\n        const {\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            absoluteInfo,\n            isRotate,\n            startValue,\n            rect,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n\n        resolveTransformEvent(e, \"rotate\");\n\n        const targetDirection = getTransformDirection(e);\n        const direction = beforeDirection * targetDirection;\n        const {\n            throttleRotate = 0,\n            parentMoveable,\n        } = moveable.props;\n\n        let delta: number;\n        let dist: number;\n        let rotate: number;\n\n        let beforeDelta: number;\n        let beforeDist: number;\n        let beforeRotate: number;\n\n        let absoluteDelta: number;\n        let absoluteDist: number;\n        let absoluteRotate: number;\n\n        const startDeg = 180 / Math.PI * startValue;\n        const absoluteStartDeg = absoluteInfo.startValue;\n\n        if (!parentFlag && \"parentDist\" in e) {\n            const parentDist = e.parentDist;\n\n            [delta, dist, rotate]\n                = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startDeg);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getParentDeg(moveable, rect, beforeInfo, parentDist, beforeDirection, startDeg);\n            [absoluteDelta, absoluteDist, absoluteRotate]\n                = getParentDeg(moveable, rect, absoluteInfo, parentDist, direction, absoluteStartDeg);\n        } else if (isPinch || parentFlag) {\n            [delta, dist, rotate]\n                = getDeg(moveable, rect, afterInfo, parentRotate, direction, startDeg, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getDeg(moveable, rect, beforeInfo, parentRotate, beforeDirection, startDeg, throttleRotate);\n            [absoluteDelta, absoluteDist, absoluteRotate]\n                = getDeg(moveable, rect, absoluteInfo, parentRotate, direction, absoluteStartDeg, throttleRotate);\n        } else {\n            [delta, dist, rotate]\n                = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startDeg, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate] = getRotateInfo(\n                moveable, rect, beforeInfo, beforeDirection, clientX, clientY,\n                startDeg, throttleRotate,\n            );\n            [absoluteDelta, absoluteDist, absoluteRotate]\n                = getRotateInfo(\n                    moveable, rect, absoluteInfo, direction, clientX, clientY,\n                    absoluteStartDeg, throttleRotate,\n                );\n        }\n\n        if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n\n        const nextTransform = convertTransformFormat(\n            datas, `rotate(${rotate}deg)`, `rotate(${dist}deg)`,\n        );\n\n        const inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);\n        const inverseDelta = minus(\n            plus(groupDelta || [0, 0], inverseDist),\n            datas.prevInverseDist || [0, 0],\n        );\n        datas.prevInverseDist = inverseDist;\n\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate,\n\n            beforeDist,\n            beforeDelta,\n            beforeRotate,\n\n            absoluteDist,\n            absoluteDelta,\n            absoluteRotate,\n            isPinch: !!isPinch,\n            ...fillTransformEvent(\n                moveable,\n                nextTransform,\n                inverseDelta,\n                isPinch,\n                e,\n            ),\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n        const { datas, isDrag } = e;\n\n        if (!datas.isRotate) {\n            return false;\n        }\n        datas.isRotate = false;\n\n        triggerEvent(moveable, \"onRotateEnd\", fillEndParams<OnRotateEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(datas.beforeDirection * moveable.rotation);\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                ev.datas.groupClient = childClient;\n                return { ...ev, parentRotate: 0 };\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const direction = datas.beforeDirection;\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [prevX, prevY] = ev.datas.groupClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad * direction);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                ev.datas.groupClient = [clientX, clientY];\n\n                return { ...ev, parentRotate, groupDelta: delta };\n            },\n        );\n        moveable.rotation = direction * params.beforeRotate;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set: (rotation: number) => {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams = fillEndParams<OnRotateGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n     *\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * requester.request({ rotate: 10 });\n     * requester.request({ rotate: 20 });\n     * requester.request({ rotate: 30 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<RotatableProps>) {\n        const datas = {};\n        let distRotate = 0;\n\n        const startRotation = moveable.getRotation();\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaRotate\" in e) {\n                    distRotate += e.deltaRotate;\n                } else if (\"rotate\" in e) {\n                    distRotate = e.rotate - startRotation;\n                }\n\n                return { datas, parentDist: distRotate };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n* When rotating, the rotate event is called.\n* @memberof Moveable.Rotatable\n* @event rotate\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { rotatable: true });\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\n*     target.style.transform = transform;\n* });\n*/\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n* When the group rotate, the `rotateGroup` event is called.\n* @memberof Moveable.Rotatable\n* @event rotateGroup\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     rotatable: true\n* });\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\n*     console.log(\"onRotateGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group rotate.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const deg = ev.beforeDist;\n*     });\n* });\n*/\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    getDirection, triggerEvent,\n    fillParams, getCSSSize,\n    getDistSize, fillEndParams, directionCondition,\n    getComputedStyle,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getDragDist,\n    getResizeDist,\n    getAbsolutePosition,\n} from \"../gesto/GestoUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd, MoveableManagerInterface, MoveableGroupInterface, SnappableProps,\n} from \"../types\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirections\";\nimport {\n    fillChildEvents,\n    triggerChildAbles,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { calculate, createRotateMatrix, plus } from \"@scena/matrix\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\nimport { checkSnapResize } from \"./Snappable\";\nimport {\n    calculateBoundSize, IObject,\n    isString, getRad, convertUnitSize,\n    throttle,\n} from \"@daybrush/utils\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        keepRatio: Boolean,\n    } as const,\n    events: {\n        onResizeStart: \"resizeStart\",\n        onResize: \"resize\",\n        onResizeEnd: \"resizeEnd\",\n\n        onResizeGroupStart: \"resizeGroupStart\",\n        onResizeGroup: \"resizeGroup\",\n        onResizeGroupEnd: \"resizeGroupEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<Partial<ResizableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, edge } = moveable.props;\n        if (resizable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            isPinch,\n            parentDirection,\n            datas,\n            parentFlag,\n        } = e;\n\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n\n        const { target, width, height } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        !isPinch && setDragStart(moveable, e);\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        [\n            datas.startWidth,\n            datas.startHeight,\n        ] = getCSSSize(target);\n        const padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];\n        datas.minSize = padding;\n        datas.maxSize = [Infinity, Infinity];\n\n        if (!parentFlag) {\n            const style = getComputedStyle(target);\n\n            const {\n                position,\n                minWidth,\n                minHeight,\n                maxWidth,\n                maxHeight,\n            } = style;\n            const isParentElement = position === \"static\" || position === \"relative\";\n            const container = isParentElement\n                ? target.parentElement\n                : (target as HTMLElement).offsetParent;\n\n            let containerWidth = width;\n            let containerHeight = height;\n\n            if (container) {\n                containerWidth = container!.clientWidth;\n                containerHeight = container!.clientHeight;\n\n                if (isParentElement) {\n                    const containerStyle = getComputedStyle(container!);\n\n                    containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;\n                    containerHeight -= parseFloat(containerStyle.paddingTop) || 0;\n                }\n            }\n\n            datas.minSize = plus([\n                convertUnitSize(minWidth, containerWidth) || 0,\n                convertUnitSize(minHeight, containerHeight) || 0,\n            ], padding);\n            datas.maxSize = plus([\n                convertUnitSize(maxWidth, containerWidth) || Infinity,\n                convertUnitSize(maxHeight, containerHeight) || Infinity,\n            ], padding);\n        }\n        const transformOrigin = moveable.props.transformOrigin || \"% %\";\n\n        datas.transformOrigin = transformOrigin && isString(transformOrigin)\n            ? transformOrigin.split(\" \")\n            : transformOrigin;\n\n        datas.isWidth = (!direction[0] && !direction[1]) || direction[0] || !direction[1];\n\n        function setRatio(ratio: number) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n\n\n        function setFixedDirection(fixedDirection: number[]) {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);\n        }\n\n        setRatio(width / height);\n        setFixedDirection([-direction[0], -direction[1]]);\n\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setMin: (minSize: number[]) => {\n                datas.minSize = minSize;\n            },\n            setMax: (maxSize: number[]) => {\n                datas.maxSize = [\n                    maxSize[0] || Infinity,\n                    maxSize[1] || Infinity,\n                ];\n            },\n            setRatio,\n            setFixedDirection,\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = triggerEvent<ResizableProps>(moveable, \"onResizeStart\", params);\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps & SnappableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            distX, distY,\n            parentFlag, isPinch,\n            parentDistance, parentScale,\n            parentKeepRatio,\n            dragClient,\n            parentDist,\n            isRequest,\n        } = e;\n\n        const {\n            isResize,\n            transformOrigin,\n            fixedDirection,\n            startWidth,\n            startHeight,\n            prevWidth,\n            prevHeight,\n            minSize,\n            maxSize,\n            ratio,\n            isWidth,\n            startOffsetWidth,\n            startOffsetHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            throttleResize = 0,\n            parentMoveable,\n            snapThreshold = 5,\n        } = moveable.props;\n        let direction = datas.direction;\n        let sizeDirection = direction;\n        let distWidth = 0;\n        let distHeight = 0;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);\n        let fixedPosition = dragClient;\n\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n\n        if (parentDist) {\n            distWidth = parentDist[0];\n            distHeight = parentDist[1];\n\n            if (keepRatio) {\n                if (!distWidth) {\n                    distWidth = distHeight * ratio;\n                } else if (!distHeight) {\n                    distHeight = distWidth / ratio;\n                }\n            }\n        } else if (parentScale) {\n            distWidth = (parentScale[0] - 1) * startOffsetWidth;\n            distHeight = (parentScale[1] - 1) * startOffsetHeight;\n        } else if (isPinch) {\n            if (parentDistance) {\n                distWidth = parentDistance;\n                distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n\n            distWidth = sizeDirection[0] * dist[0];\n            distHeight = sizeDirection[1] * dist[1];\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], sizeDirection);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = distHeight / ratio;\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = distWidth * ratio;\n                } else {\n                    // two-way\n                    const startWidthSize = sizeDirection[0] * 2 * startOffsetWidth;\n                    const startHeightSize = sizeDirection[1] * 2 * startOffsetHeight;\n                    const distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]])\n                        - getDistSize([startWidthSize, startHeightSize]);\n                    const ratioRad = getRad([0, 0], [ratio, 1]);\n\n                    distWidth = Math.cos(ratioRad) * distSize;\n                    distHeight = Math.sin(ratioRad) * distSize;\n                }\n            } else if (!keepRatio) {\n                const nextDirection = [...direction];\n\n                if (!startOffsetWidth) {\n                    if (dist[0] < 0) {\n                        nextDirection[0] = -1;\n                    } else if (dist[0] > 0) {\n                        nextDirection[0] = 1;\n                    }\n                }\n                if (!startOffsetHeight) {\n                    if (dist[1] < 0) {\n                        nextDirection[1] = -1;\n                    } else if (dist[1] > 0) {\n                        nextDirection[1] = 1;\n                    }\n                }\n                direction = nextDirection;\n                sizeDirection = nextDirection;\n                distWidth = sizeDirection[0] * dist[0];\n                distHeight = sizeDirection[1] * dist[1];\n            }\n        }\n        let nextWidth = sizeDirection[0] || keepRatio\n            ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n        let nextHeight = sizeDirection[1] || keepRatio\n            ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n        if (keepRatio && startOffsetWidth && startOffsetHeight) {\n            // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n            if (isWidth) {\n                nextHeight = nextWidth / ratio;\n            } else {\n                nextWidth = nextHeight * ratio;\n            }\n        }\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapResize(\n                moveable, nextWidth,\n                nextHeight, direction,\n                fixedPosition,\n                isRequest,\n                datas,\n            );\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nextWidth = throttle(nextWidth, throttleResize!);\n                } else {\n                    nextHeight = throttle(nextHeight, throttleResize!);\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nextWidth += snapDist[0];\n                nextHeight = nextWidth / ratio;\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nextHeight += snapDist[1];\n                nextWidth = nextHeight * ratio;\n            }\n        } else {\n            if (startOffsetWidth + distWidth < -snapThreshold) {\n                snapDist[0] = 0;\n            }\n            if (startOffsetWidth + distHeight < -snapThreshold) {\n                snapDist[1] = 0;\n            }\n            nextWidth += snapDist[0];\n            nextHeight += snapDist[1];\n            if (!snapDist[0]) {\n                nextWidth = throttle(nextWidth, throttleResize!);\n            }\n            if (!snapDist[1]) {\n                nextHeight = throttle(nextHeight, throttleResize!);\n            }\n        }\n        [nextWidth, nextHeight] = calculateBoundSize(\n            [nextWidth, nextHeight],\n            minSize,\n            maxSize,\n            keepRatio,\n        );\n        nextWidth = Math.round(nextWidth);\n        nextHeight = Math.round(nextHeight);\n        distWidth = nextWidth - startOffsetWidth;\n        distHeight = nextHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        const inverseDelta = getResizeDist(\n            moveable,\n            nextWidth, nextHeight,\n            fixedDirection, fixedPosition,\n            transformOrigin,\n        );\n\n        if (!parentMoveable && delta.every(num => !num) && inverseDelta.every(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnResize>(moveable, e, {\n            width: startWidth + distWidth,\n            height: startHeight + distHeight,\n            offsetWidth: nextWidth,\n            offsetHeight: nextHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!isPinch,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false),\n            ) as OnDrag,\n        });\n        triggerEvent<ResizableProps>(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            this.dragControl(moveable, e);\n            return true;\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isResize) {\n            return false;\n        }\n        datas.isResize = false;\n\n        const params = fillEndParams<OnResizeEnd>(moveable, e, {});\n        triggerEvent<ResizableProps>(moveable, \"onResizeEnd\", params);\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n        function setDist(child: MoveableManagerInterface, ev: any) {\n            const fixedDirection = datas.fixedDirection;\n            const fixedPosition = datas.fixedPosition;\n            const pos = getAbsolutePosition(child, fixedDirection);\n            const [originalX, originalY] = calculate(\n                createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                3,\n            );\n            ev.datas.originalX = originalX;\n            ev.datas.originalY = originalY;\n\n            return ev;\n        }\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                return setDist(child, ev);\n            },\n        );\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n            setFixedDirection(fixedDirection: number[]) {\n                params.setFixedDirection(fixedDirection);\n                events.forEach((ev, i) => {\n                    ev.setFixedDirection(fixedDirection);\n                    setDist(moveable.moveables[i], originalEvents[i]);\n                });\n            },\n        };\n        const result = triggerEvent<ResizableProps>(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const {\n            offsetWidth, offsetHeight, dist,\n        } = params;\n\n        const keepRatio = moveable.props.keepRatio;\n\n        const parentScale = [\n            offsetWidth / (offsetWidth - dist[0]),\n            offsetHeight / (offsetHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [clientX, clientY] = calculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        ev.datas.originalX * parentScale[0],\n                        ev.datas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...ev,\n                    parentDist: null,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent<ResizableProps>(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams: OnResizeGroupEnd = fillEndParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent<ResizableProps>(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Resizable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to resize\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @param {number} [e.offsetWidth] - offset number of width\n     * @param {number} [e.offsetHeight] - offset number of height\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any>) {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n        const rect = moveable.getRect();\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight;\n                }\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can be resized. (default: false)\n * @name Moveable.Resizable#resizable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize.\n * @name Moveable.Resizable#throttleResize\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 0,\n * });\n *\n * moveable.throttleResize = 1;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Resizable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Resizable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group resize starts, the `resizeGroupStart` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroupStart\n* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroupStart\", ({ targets }) => {\n*     console.log(\"onResizeGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group resize, the `resizeGroup` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroup\n* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroup\", ({ targets, events }) => {\n*     console.log(\"onResizeGroup\", targets);\n*     events.forEach(ev => {\n*         const offset = [\n*             direction[0] < 0 ? -ev.delta[0] : 0,\n*             direction[1] < 0 ? -ev.delta[1] : 0,\n*         ];\n*         // ev.drag is a drag event that occurs when the group resize.\n*         const left = offset[0] + ev.drag.beforeDist[0];\n*         const top = offset[1] + ev.drag.beforeDist[1];\n*         const width = ev.width;\n*         const top = ev.top;\n*     });\n* });\n*/\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    getDirection, triggerEvent, multiply2,\n    fillParams, getDistSize, fillEndParams, directionCondition,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n    setDragStart, getDragDist,\n    resolveTransformEvent,\n    convertTransformFormat,\n    getScaleDist,\n    fillTransformStartEvent,\n    fillTransformEvent,\n    getAbsolutePosition,\n    setDefaultTransformIndex,\n} from \"../gesto/GestoUtils\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirections\";\nimport {\n    ScalableProps, ResizableProps, OnScaleGroup, OnScaleGroupEnd,\n    Renderer, OnScaleGroupStart, DraggableProps, OnDragStart,\n    SnappableState, GroupableProps, OnScaleStart,\n    OnScale, OnScaleEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport {\n    fillChildEvents,\n    triggerChildAbles,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { calculate, createRotateMatrix, plus, minus } from \"@scena/matrix\";\nimport CustomGesto from \"../gesto/CustomGesto\";\nimport { checkSnapScale } from \"./Snappable\";\nimport {\n    isArray, IObject, getRad, getDist,\n    throttle,\n} from \"@daybrush/utils\";\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n    } as const,\n    events: {\n        onScaleStart: \"scaleStart\",\n        onScale: \"scale\",\n        onScaleEnd: \"scaleEnd\",\n        onScaleGroupStart: \"scaleGroupStart\",\n        onScaleGroup: \"scaleGroup\",\n        onScaleGroupEnd: \"scaleGroupEnd\",\n    } as const,\n    render(\n        moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps>>,\n        React: Renderer): any[] | undefined {\n        const { resizable, scalable, edge } = moveable.props;\n        if (!resizable && scalable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n        const { datas, isPinch, inputEvent, parentDirection } = e;\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n            pos1,\n            pos2,\n            pos4,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!isPinch) {\n            setDragStart(moveable, e);\n        }\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.width = width;\n        datas.height = height;\n        datas.startValue = [1, 1];\n\n        const scaleWidth = getDist(pos1, pos2);\n        const scaleHeight = getDist(pos2, pos4);\n        const isWidth = (!direction[0] && !direction[1]) || direction[0] || !direction[1];\n\n\n        datas.scaleWidth = scaleWidth;\n        datas.scaleHeight = scaleHeight;\n        datas.scaleXRatio = scaleWidth / width;\n        datas.scaleYRatio = scaleHeight / height;\n\n        setDefaultTransformIndex(e, \"scale\");\n\n\n\n        datas.isWidth = isWidth;\n\n\n        function setRatio(ratio: number) {\n            datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n        }\n\n        function setFixedDirection(fixedDirection: number[]) {\n            datas.fixedDirection = fixedDirection;\n            datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);\n        }\n\n        setRatio(getDist(pos1, pos2) / getDist(pos2, pos4));\n        setFixedDirection([-direction[0], -direction[1]]);\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startValue = scale;\n            },\n            setRatio,\n            setFixedDirection,\n            ...fillTransformStartEvent(e),\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent<ScalableProps, \"onScaleStart\">(moveable, \"onScaleStart\", params);\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        resolveTransformEvent(e, \"scale\");\n        const {\n            datas, distX, distY,\n            parentScale,\n            parentDistance,\n            parentKeepRatio,\n            parentFlag, isPinch,\n            dragClient,\n            parentDist,\n            isRequest,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            width,\n            height,\n            isScale,\n            startValue,\n            isWidth,\n            ratio,\n            fixedDirection,\n            scaleXRatio,\n            scaleYRatio,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const {\n            throttleScale,\n            parentMoveable,\n        } = moveable.props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);\n        const state = moveable.state;\n\n        let scaleX = 1;\n        let scaleY = 1;\n        let fixedPosition = dragClient;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n\n        if (parentDist) {\n            scaleX = (width + parentDist[0]) / width;\n            scaleY = (height + parentDist[1]) / height;\n        } else if (parentScale) {\n            scaleX = parentScale[0];\n            scaleY = parentScale[1];\n        } else if (isPinch) {\n            if (parentDistance) {\n                scaleX = (width + parentDistance) / width;\n                scaleY = (height + parentDistance * height / width) / height;\n            }\n        } else {\n            const dragDist = getDragDist({ datas, distX, distY });\n            let distScaleWidth = sizeDirection[0] * dragDist[0] * scaleXRatio;\n            let distScaleHeight = sizeDirection[1] * dragDist[1] * scaleYRatio;\n\n            if (keepRatio && width && height) {\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    // distHeight = signSize;\n                    distScaleWidth = distScaleHeight * ratio;\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    // distWidth = signSize;\n                    distScaleHeight = distScaleWidth / ratio;\n                } else {\n                    const size = getDistSize([distScaleWidth, distScaleHeight]);\n\n                    // two-way\n                    const dragRad = getRad([0, 0], dragDist);\n                    const standardRad = getRad([0, 0], sizeDirection);\n                    const signSize = Math.cos(dragRad - standardRad) * size;\n                    const ratioRad = getRad([0, 0], [ratio, 1]);\n\n                    distScaleWidth = Math.cos(ratioRad) * signSize;\n                    distScaleHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n            scaleX = (width + (distScaleWidth / scaleXRatio)) / width;\n            scaleY = (height + (distScaleHeight / scaleYRatio)) / height;\n        }\n\n        scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];\n        scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];\n\n        if (scaleX === 0) {\n            scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (scaleY === 0) {\n            scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n\n        const dist = [scaleX / startValue[0], scaleY / startValue[1]];\n        let scale = [scaleX, scaleY];\n\n        if (!isPinch && moveable.props.groupable) {\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction, request: e.isRequest };\n            }\n        }\n\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapScale(\n                moveable,\n                dist,\n                direction,\n                isRequest,\n                datas,\n            );\n        }\n\n\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0] * width) > Math.abs(snapDist[1] * height)) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    dist[0] = throttle(dist[0] * startValue[0], throttleScale!) / startValue[0];\n                } else {\n                    dist[1] = throttle(dist[1] * startValue[1], throttleScale!) / startValue[1];\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                dist[0] += snapDist[0];\n                const snapHeight = width * dist[0] * startValue[0] / ratio;\n\n                dist[1] = snapHeight / height / startValue[1];\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                dist[1] += snapDist[1];\n                const snapWidth = height * dist[1] * startValue[1] * ratio;\n\n                dist[0] = snapWidth / width / startValue[0];\n            }\n        } else {\n            dist[0] += snapDist[0];\n            dist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                dist[0] = throttle(dist[0] * startValue[0], throttleScale!) / startValue[0];\n            }\n            if (!snapDist[1]) {\n                dist[1] = throttle(dist[1] * startValue[1], throttleScale!) / startValue[1];\n            }\n        }\n        if (dist[0] === 0) {\n            dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (dist[1] === 0) {\n            dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];\n        scale = multiply2(dist, startValue);\n\n        const inverseDist = getScaleDist(moveable, dist, fixedDirection, fixedPosition, datas);\n\n        const inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);\n\n        datas.prevDist = dist;\n        datas.prevInverseDist = inverseDist;\n        if (\n            scaleX === prevDist[0] && scaleY === prevDist[1]\n            && inverseDelta.every(num => !num)\n            && !parentMoveable\n        ) {\n            return false;\n        }\n\n        const nextTransform = convertTransformFormat(\n            datas, `scale(${scale.join(\", \")})`, `scale(${dist.join(\", \")})`);\n        const params = fillParams<OnScale>(moveable, e, {\n            offsetWidth: width,\n            offsetHeight: height,\n            direction,\n\n            // beforeScale,\n            // beforeDist,\n            // beforeDelta,\n\n            scale,\n            dist,\n            delta,\n\n            isPinch: !!isPinch,\n            ...fillTransformEvent(\n                moveable,\n                nextTransform,\n                inverseDelta,\n                isPinch,\n                e,\n            ),\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillEndParams<OnScaleEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const originalEvents = fillChildEvents(moveable, \"resizable\", e);\n\n        function setDist(child: MoveableManagerInterface, ev: any) {\n            const fixedDirection = datas.fixedDirection;\n            const fixedPosition = datas.fixedPosition;\n            const pos = getAbsolutePosition(child, fixedDirection);\n            const [originalX, originalY] = calculate(\n                createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                3,\n            );\n            ev.datas.originalX = originalX;\n            ev.datas.originalY = originalY;\n\n            return ev;\n        }\n\n        datas.moveableScale = moveable.scale;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControlStart\",\n            e,\n            (child, ev) => {\n                return setDist(child, ev);\n            },\n        );\n\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n            setFixedDirection(fixedDirection: number[]) {\n                params.setFixedDirection(fixedDirection);\n                events.forEach((ev, i) => {\n                    ev.setFixedDirection(fixedDirection);\n                    setDist(moveable.moveables[i], originalEvents[i]);\n                });\n            },\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n\n        const moveableScale = datas.moveableScale;\n        moveable.scale = [\n            params.scale[0] * moveableScale[0],\n            params.scale[1] * moveableScale[1],\n        ];\n        const keepRatio = moveable.props.keepRatio;\n        const { dist, scale } = params;\n\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAbles(\n            moveable,\n            this,\n            \"dragControl\",\n            e,\n            (_, ev) => {\n                const [clientX, clientY] = calculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        ev.datas.originalX * dist[0],\n                        ev.datas.originalY * dist[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...ev,\n                    parentDist: null,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        triggerChildAbles(moveable, this, \"dragControlEnd\", e);\n\n        const nextParams = fillEndParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Scalable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to scale\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can scaled. (default: false)\n * @name Moveable.Scalable#scalable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, the scale event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the scale event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the scaleEnd event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the scaleEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group scale starts, the `scaleGroupStart` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroupStart\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\n*     console.log(\"onScaleGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group scale, the `scaleGroup` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroup\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\n*     console.log(\"onScaleGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group scale.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const scaleX = ev.scale[0];\n*         const scaleY = ev.scale[1];\n*     });\n* });\n*/\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, getLineStyle, getDirection, getAbsolutePosesByState,\n    triggerEvent, fillParams, fillEndParams,\n} from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    calculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    minus,\n    createWarpMatrix,\n    plus,\n} from \"@scena/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport {\n    setDragStart, getDragDist, getPosIndexesByDirection, setDefaultTransformIndex,\n    fillTransformStartEvent, resolveTransformEvent,\n    convertTransformFormat, fillOriginalTransform, getTransfromMatrix,\n} from \"../gesto/GestoUtils\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { hasClass, dot, getRad } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirections\";\nimport { hasGuidelines, checkMoveableSnapBounds } from \"./Snappable\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n    } as const,\n    events: {\n        onWarpStart: \"warpStart\",\n        onWarp: \"warp\",\n        onWarpEnd: \"warpEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<ResizableProps & ScalableProps & WarpableProps>, React: Renderer): any[] {\n        const { resizable, scalable, warpable, zoom } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return [];\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")}\n                key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3, zoom)}></div>,\n            <div className={prefix(\"line\")}\n                key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4, zoom)}></div>,\n            ...renderAllDirections(moveable, React),\n        ];\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (e.isRequest) {\n            return false;\n        }\n        return hasClass(e.inputEvent.target, prefix(\"direction\"));\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map(p => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startValue = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(e, \"matrix3d\");\n\n        state.snapRenderInfo = {\n            request: e.isRequest,\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startValue = matrix;\n            },\n            ...fillTransformStartEvent(e),\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, isRequest } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startValue,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n        resolveTransformEvent(e, \"matrix3d\");\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkMoveableSnapBounds(\n                moveable,\n                isRequest,\n                selectedPoses.map(pos => [pos[0] + distX, pos[1] + distY]),\n            );\n\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[2],\n            poses[1],\n            poses[3],\n            nextPoses[0],\n            nextPoses[2],\n            nextPoses[1],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n        // B * A * M\n        const afterMatrix = multiply(targetInverseMatrix, h, 4);\n\n        // B * M * A\n        const matrix = getTransfromMatrix(datas, afterMatrix, true);\n\n        const delta = multiply(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n        const totalMatrix = multiply(startValue, matrix, 4);\n        const nextTransform = convertTransformFormat(\n            datas, `matrix3d(${totalMatrix.join(\", \")})`, `matrix3d(${matrix.join(\", \")})`);\n\n        fillOriginalTransform(e, nextTransform);\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: totalMatrix,\n            dist: matrix,\n            multiply,\n            transform: nextTransform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillEndParams<OnWarpEnd>(moveable, e, {}));\n        return isDrag;\n    },\n};\n\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n/**\n* Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n* @name Moveable.Warpable#renderDirections\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     warpable: true,\n*     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n* });\n*\n* moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n*/\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable.Warpable\n* @event warpStart\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n","import { prefix } from \"./utils\";\n\nexport const AREA_PIECES = /*#__PURE__*/prefix(\"area-pieces\");\nexport const AREA_PIECE = /*#__PURE__*/prefix(\"area-piece\");\nexport const AVOID = /*#__PURE__*/prefix(\"avoid\");\n","import {\n    createWarpMatrix,\n} from \"@scena/matrix\";\nimport { ref } from \"framework-utils\";\nimport { getRect, calculateInversePosition, makeMatrixCSS, prefix } from \"../utils\";\nimport {\n    Renderer, GroupableProps, DragAreaProps, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { AREA_PIECE, AVOID, AREA_PIECES } from \"../classNames\";\nimport { addClass, removeClass } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManagerInterface) {\n    const el = moveable.areaElement;\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n        passDragArea: Boolean,\n    } as const,\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    render(moveable: MoveableManagerInterface<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable, passDragArea } = moveable.props;\n        const { width, height, renderPoses } = moveable.state;\n\n        const className = passDragArea ? prefix(\"area\", \"pass\") : prefix(\"area\");\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={className}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            renderPoses[0],\n            renderPoses[1],\n            renderPoses[2],\n            renderPoses[3],\n        );\n        const transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={className} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManagerInterface, { datas, clientX, clientY, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        const areaElement = moveable.areaElement;\n        const state = moveable.state;\n        const {\n            moveableClientRect,\n            renderPoses,\n            rootMatrix,\n            is3d,\n        } = state;\n        const { left, top } = moveableClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n            width,\n            height,\n        } = getRect(renderPoses);\n        const n = is3d ? 4 : 3;\n        let [posX, posY] = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n);\n\n        posX -= relativeLeft;\n        posY -= relativeTop;\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n        state.disableNativeEvent = true;\n        return;\n    },\n    drag(moveable: MoveableManagerInterface, { datas, inputEvent }: any) {\n        this.enableNativeEvent(moveable);\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<DragAreaProps>, e: any) {\n        this.enableNativeEvent(moveable);\n        const { inputEvent, datas } = e;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<DragAreaProps>,\n        e: any,\n    ) {\n        return this.dragEnd(moveable, e);\n    },\n    unset(moveable: MoveableManagerInterface<DragAreaProps>) {\n        restoreStyle(moveable);\n        moveable.state.disableNativeEvent = false;\n    },\n    enableNativeEvent(moveable: MoveableManagerInterface<DragAreaProps>) {\n        const state = moveable.state;\n        if (state.disableNativeEvent) {\n            requestAnimationFrame(() => {\n                state.disableNativeEvent = false;\n            });\n        }\n    },\n};\n\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n/**\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\n * @name Moveable#passDragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n","import { prefix, getControlTransform } from \"../utils\";\nimport { Renderer, OriginOptions, MoveableManagerInterface } from \"../types\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"origin\", {\n    render(moveable: MoveableManagerInterface<OriginOptions>, React: Renderer): any[] {\n        const { zoom } = moveable.props;\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, zoom!, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n});\n\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n","\nimport { ScrollableProps, OnScroll, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { triggerEvent, fillParams, getRefTarget } from \"../utils\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n        getScrollPosition: Function,\n    } as const,\n    events: {\n        onScroll: \"scroll\",\n        onScrollGroup: \"scrollGroup\",\n    } as const,\n    dragStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer() as HTMLElement,\n        } = props;\n\n        const dragScroll = new DragScroll();\n        const scrollContainerElement = getRefTarget<HTMLElement>(scrollContainer, true);\n\n        e.datas.dragScroll = dragScroll;\n\n        const gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY }) => {\n            moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainerElement!,\n        });\n    },\n    checkScroll(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const {\n            dragScroll,\n        } = e.datas;\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer(),\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets, isControl: true });\n    },\n    dragGroupContro(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable.Scrollable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable.Scrollable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable.Scrollable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable.Scrollable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        dragTarget: Object,\n        container: Object,\n        portalContainer: Object,\n        rootContainer: Object,\n        zoom: Number,\n        transformOrigin: Array,\n        edge: Boolean,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n        pinchOutside: Boolean,\n        triggerAblesSimultaneously: Boolean,\n        checkInput: Boolean,\n        cspNonce: String,\n        translateZ: Number,\n        props: Object,\n    } as const,\n    events: {} as const,\n};\n","import { prefix, makeMatrixCSS } from \"../utils\";\nimport { Renderer, MoveableManagerInterface } from \"../types\";\nimport { createWarpMatrix } from \"@scena/matrix\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"padding\", {\n    render(moveable: MoveableManagerInterface, React: Renderer): any[] {\n        const props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        const padding = props.padding || {};\n        const {\n            left = 0,\n            top = 0,\n            right = 0,\n            bottom = 0,\n        } = padding;\n        const {\n            renderPoses,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        } = moveable.state;\n\n        const poses = [pos1, pos2, pos3, pos4];\n        const paddingDirections: number[][] = [];\n\n        if (left > 0) {\n            paddingDirections.push([0, 2]);\n        }\n        if (top > 0) {\n            paddingDirections.push([0, 1]);\n        }\n        if (right > 0) {\n            paddingDirections.push([1, 3]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([2, 3]);\n        }\n        return paddingDirections.map(([dir1, dir2], i) => {\n            const paddingPos1 = poses[dir1];\n            const paddingPos2 = poses[dir2];\n            const paddingPos3 = renderPoses[dir1];\n            const paddingPos4 = renderPoses[dir2];\n\n            const h = createWarpMatrix(\n                [0, 0],\n                [100, 0],\n                [0, 100],\n                [100, 100],\n                paddingPos1,\n                paddingPos2,\n                paddingPos3,\n                paddingPos4,\n            );\n            if (!h.length) {\n                return undefined;\n            }\n            return (<div key={`padding${i}`} className={prefix(\"padding\")} style={{\n                transform: makeMatrixCSS(h, true),\n            }}></div>);\n        });\n    },\n});\n\n/**\n * Add padding around the target to increase the drag area. (default: null)\n * @name Moveable#padding\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n","import { convertCSSSize } from \"../../utils\";\nimport { ControlPose } from \"../../types\";\nimport { convertUnitSize } from \"@daybrush/utils\";\n\nconst RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"] as const;\n\nfunction calculateRatio(values: number[], size: number) {\n    const sumSize = values[0] + values[1];\n    const sumRatio = sumSize > size ? size / sumSize : 1;\n\n    values[0] *= sumRatio;\n    values[1] = size - values[1] * sumRatio;\n\n    return values;\n}\nexport const HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nexport const VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nexport const HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1] as const;\nexport const VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1] as const;\n\nexport function getRadiusStyles(\n    poses: number[][], controlPoses: ControlPose[],\n    isRelative: boolean,\n    width: number,\n    height: number,\n    left = 0,\n    top = 0,\n    right: number = width,\n    bottom: number = height,\n) {\n    const clipStyles: string[] = [];\n    let isVertical = false;\n\n    const raws = poses.map((pos, i) => {\n        const { horizontal, vertical } = controlPoses[i];\n        if (vertical && !isVertical) {\n            isVertical = true;\n            clipStyles.push(\"/\");\n        }\n\n        if (isVertical) {\n            const rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n\n            return rawPos;\n        } else {\n            const rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n\n            return rawPos;\n        }\n    });\n\n    return {\n        styles: clipStyles,\n        raws,\n    };\n}\nexport function getRadiusRange(controlPoses: ControlPose[]) {\n    // [start, length]\n    const horizontalRange = [0, 0];\n    const verticalRange = [0, 0];\n    const length = controlPoses.length;\n\n    for (let i = 0; i < length; ++i) {\n        const clipPose = controlPoses[i];\n\n        if (!clipPose.sub) {\n            continue;\n        }\n        if (clipPose.horizontal) {\n            if (horizontalRange[1] === 0) {\n                horizontalRange[0] = i;\n            }\n            horizontalRange[1] = i - horizontalRange[0] + 1;\n            verticalRange[0] = i + 1;\n        }\n        if (clipPose.vertical) {\n            if (verticalRange[1] === 0) {\n                verticalRange[0] = i;\n            }\n            verticalRange[1] = i - verticalRange[0] + 1;\n        }\n    }\n\n    return {\n        horizontalRange,\n        verticalRange,\n    };\n}\nexport function getRadiusValues(\n    values: string[],\n    width: number,\n    height: number,\n    left: number,\n    top: number,\n    minCounts: number[] = [0, 0],\n): ControlPose[] {\n    const splitIndex = values.indexOf(\"/\");\n    const splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n    const horizontalValues = values.slice(0, splitLength);\n    const verticalValues = values.slice(splitLength + 1);\n    const [\n        nwValue = \"0px\",\n        neValue = nwValue,\n        seValue = nwValue,\n        swValue = neValue,\n    ] = horizontalValues;\n    const [\n        wnValue = nwValue,\n        enValue = wnValue,\n        esValue = wnValue,\n        wsValue = enValue,\n    ] = verticalValues;\n\n    const horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(pos => convertUnitSize(pos, width));\n    const verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(pos => convertUnitSize(pos, height));\n    const horizontalPoses = horizontalRawPoses.slice();\n    const verticalPoses = verticalRawPoses.slice();\n\n    [horizontalPoses[0], horizontalPoses[1]] = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width);\n    [horizontalPoses[3], horizontalPoses[2]] = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width);\n    [verticalPoses[0], verticalPoses[3]] = calculateRatio([verticalPoses[0], verticalPoses[3]], height);\n    [verticalPoses[1], verticalPoses[2]] = calculateRatio([verticalPoses[1], verticalPoses[2]], height);\n\n    const nextHorizontalPoses\n        = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));\n    const nextVerticalPoses\n        = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));\n    return [\n        ...nextHorizontalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n                sub: true,\n                raw: horizontalRawPoses[i],\n                direction,\n            };\n        }),\n        ...nextVerticalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n                sub: true,\n                raw: verticalRawPoses[i],\n                direction,\n            };\n        }),\n    ];\n}\nexport function removeRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    index: number,\n    startIndex: number,\n    length: number = poses.length,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    const radiuslIndex = index - startIndex;\n    let deleteCount = 0;\n\n    if (radiuslIndex === 0) {\n        deleteCount = length;\n    } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n        deleteCount = horizontalRange[1] - radiuslIndex;\n    } else if (radiuslIndex >= verticalRange[0]) {\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n    } else {\n        return;\n    }\n    controlPoses.splice(index, deleteCount);\n    poses.splice(index, deleteCount);\n}\nexport function addRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    startIndex: number,\n    horizontalIndex: number,\n    verticalIndex: number,\n    distX: number,\n    distY: number,\n    right: number,\n    bottom: number,\n    left = 0,\n    top = 0,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    if (horizontalIndex > -1) {\n        const radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\n            ? distX - left\n            : right - distX;\n        for (let i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n            const y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n            let x = 0;\n            if (horizontalIndex === i) {\n                x = distX;\n            } else if (i === 0) {\n                x = left + radiusX;\n            } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n                x = right - (poses[startIndex][0] - left);\n            }\n            controlPoses.splice(startIndex + i, 0, {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [x, y],\n            });\n            poses.splice(startIndex + i, 0, [x, y]);\n\n            if (i === 0) {\n                break;\n            }\n        }\n    } else if (verticalIndex > - 1) {\n        const radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\n            ? distY - top\n            : bottom - distY;\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n            const pos = [\n                left + radiusY,\n                top,\n            ];\n            controlPoses.push({\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n                vertical: 0,\n                pos,\n            });\n            poses.push(pos);\n        }\n\n        const startVerticalIndex = verticalRange[0];\n        for (let i = verticalRange[1]; i <= verticalIndex; ++i) {\n            const x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n            let y = 0;\n            if (verticalIndex === i) {\n                y = distY;\n            } else if (i === 0) {\n                y = top + radiusY;\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n                y = poses[startIndex + startVerticalIndex][1];\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n            }\n            controlPoses.push({\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [x, y],\n            });\n            poses.push([x, y]);\n            if (i === 0) {\n                break;\n            }\n        }\n    }\n}\nexport function splitRadiusPoses(\n    controlPoses: ControlPose[],\n    raws: number[] = controlPoses.map(pos => pos.raw!),\n) {\n    const horizontals = controlPoses\n        .map((pos, i) => pos.horizontal ? raws[i] : null).filter(pos => pos != null) as number[];\n    const verticals = controlPoses\n        .map((pos, i) => pos.vertical ? raws[i] : null).filter(pos => pos != null) as number[];\n\n    return {\n        horizontals,\n        verticals,\n    };\n}\n","import {\n    Renderer, ClippableProps, OnClip,\n    ClippableState, OnClipEnd, OnClipStart,\n    ControlPose, MoveableManagerInterface,\n} from \"../types\";\nimport { splitBracket, splitComma, splitUnit, splitSpace, convertUnitSize, getRad } from \"@daybrush/utils\";\nimport {\n    prefix, calculatePosition, getDiagonalSize,\n    fillParams, triggerEvent,\n    makeMatrixCSS, getRect, fillEndParams,\n    convertCSSSize, moveControlPos,\n    getComputedStyle,\n} from \"../utils\";\nimport { plus, minus } from \"@scena/matrix\";\nimport { setDragStart, getDragDist, calculatePointerDist } from \"../gesto/GestoUtils\";\nimport {\n    getRadiusValues,\n    HORIZONTAL_RADIUS_ORDER, VERTICAL_RADIUS_ORDER, getRadiusStyles, addRadiusPos, removeRadiusPos,\n} from \"./roundable/borderRadius\";\nimport { renderLine } from \"../renderDirections\";\nimport { getDefaultGuidelines, checkSnapBoundPriority } from \"./snappable/snap\";\nimport { checkSnapBounds } from \"./Snappable\";\n\nconst CLIP_DIRECTIONS = [\n    [0, -1, \"n\"],\n    [1, 0, \"e\"],\n] as const;\nconst CLIP_RECT_DIRECTIONS = [\n    [-1, -1, \"nw\"],\n    [0, -1, \"n\"],\n    [1, -1, \"ne\"],\n    [1, 0, \"e\"],\n    [1, 1, \"se\"],\n    [0, 1, \"s\"],\n    [-1, 1, \"sw\"],\n    [-1, 0, \"w\"],\n] as const;\n\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nfunction getClipStyles(\n    moveable: MoveableManagerInterface<ClippableProps>,\n    clipPath: ReturnType<typeof getClipPath>,\n    poses: number[][],\n) {\n    const {\n        clipRelative,\n    } = moveable.props;\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const {\n        type: clipType,\n        poses: clipPoses,\n    } = clipPath!;\n\n    const isRect = clipType === \"rect\";\n    const isCircle = clipType === \"circle\";\n    if (clipType === \"polygon\") {\n        return poses.map(pos => `${convertCSSSize(pos[0], width, clipRelative)} ${convertCSSSize(pos[1], height, clipRelative)}`);\n    } else if (isRect || clipType === \"inset\") {\n        const top = poses[1][1];\n        const right = poses[3][0];\n        const left = poses[7][0];\n        const bottom = poses[5][1];\n\n        if (isRect) {\n            return [\n                top,\n                right,\n                bottom,\n                left,\n            ].map(pos => `${pos}px`);\n        }\n        const clipStyles\n            = [top, width - right, height - bottom, left]\n                .map((pos, i) => convertCSSSize(pos, i % 2 ? width : height, clipRelative));\n\n        if (poses.length > 8) {\n            const [subWidth, subHeight] = minus(poses[4], poses[0]);\n\n            clipStyles.push(\"round\", ...getRadiusStyles(\n                poses.slice(8),\n                clipPoses.slice(8),\n                clipRelative!,\n                subWidth,\n                subHeight,\n                left, top, right, bottom,\n            ).styles);\n        }\n        return clipStyles;\n    } else if (isCircle || clipType === \"ellipse\") {\n        const center = poses[0];\n        const ry = convertCSSSize(\n            Math.abs(poses[1][1] - center[1]),\n            isCircle ? Math.sqrt((width * width + height * height) / 2) : height,\n            clipRelative,\n        );\n\n        const clipStyles = isCircle ? [ry]\n            : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n\n        clipStyles.push(\n            \"at\", convertCSSSize(center[0], width, clipRelative),\n            convertCSSSize(center[1], height, clipRelative));\n\n        return clipStyles;\n    }\n}\nfunction getRectPoses(top: number, right: number, bottom: number, left: number): ControlPose[] {\n    const xs = [left, (left + right) / 2, right];\n    const ys = [top, (top + bottom) / 2, bottom];\n\n    return CLIP_RECT_DIRECTIONS.map(([dirx, diry, dir]) => {\n        const x = xs[dirx + 1];\n        const y = ys[diry + 1];\n        return {\n            vertical: Math.abs(diry),\n            horizontal: Math.abs(dirx),\n            direction: dir,\n            pos: [x, y],\n        };\n    });\n}\nfunction getClipPath(\n    target: HTMLElement | SVGElement,\n    width: number,\n    height: number,\n    defaultClip?: string,\n    customClip?: string,\n) {\n    let clipText: string | undefined = customClip;\n\n    if (!clipText) {\n        const style = getComputedStyle(target!);\n        const clipPath = style.clipPath!;\n\n        clipText = clipPath !== \"none\" ? clipPath : style.clip!;\n    }\n    if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n        clipText = defaultClip;\n\n        if (!clipText) {\n            return;\n        }\n    }\n    const {\n        prefix: clipPrefix = clipText,\n        value = \"\",\n    } = splitBracket(clipText);\n    const isCircle = clipPrefix === \"circle\";\n    let splitter = \" \";\n\n    if (clipPrefix === \"polygon\") {\n        const values = splitComma(value! || `0% 0%, 100% 0%, 100% 100%, 0% 100%`);\n        splitter = \",\";\n\n        const poses: ControlPose[] = values.map(pos => {\n            const [xPos, yPos] = pos.split(\" \");\n\n            return {\n                vertical: 1,\n                horizontal: 1,\n                pos: [\n                    convertUnitSize(xPos, width),\n                    convertUnitSize(yPos, height),\n                ],\n            };\n        });\n\n        return {\n            type: clipPrefix,\n            clipText,\n            poses,\n            splitter,\n        } as const;\n    } else if (isCircle || clipPrefix === \"ellipse\") {\n        let xPos = \"\";\n        let yPos = \"\";\n        let radiusX = 0;\n        let radiusY = 0;\n        const values = splitSpace(value!);\n\n        if (isCircle) {\n            let radius = \"\";\n            [radius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n            radiusY = radiusX;\n        } else {\n            let xRadius = \"\";\n            let yRadius = \"\";\n            [xRadius = \"50%\", yRadius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = convertUnitSize(xRadius, width);\n            radiusY = convertUnitSize(yRadius, height);\n        }\n        const centerPos = [\n            convertUnitSize(xPos, width),\n            convertUnitSize(yPos, height),\n        ];\n        const poses: ControlPose[] = [\n            {\n                vertical: 1,\n                horizontal: 1,\n                pos: centerPos,\n                direction: \"nesw\",\n            },\n            ...CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(dir => ({\n                vertical: Math.abs(dir[1]),\n                horizontal: dir[0],\n                direction: dir[2],\n                sub: true,\n                pos: [\n                    centerPos[0] + dir[0] * radiusX,\n                    centerPos[1] + dir[1] * radiusY,\n                ],\n            })),\n        ];\n        return {\n            type: clipPrefix as \"circle\" | \"ellipse\",\n            clipText,\n            radiusX,\n            radiusY,\n            left: centerPos[0] - radiusX,\n            top: centerPos[1] - radiusY,\n            poses,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"inset\") {\n        const values = splitSpace(value! || \"0 0 0 0\");\n        const roundIndex = values.indexOf(\"round\");\n\n        const rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n        const radiusValues = values.slice(rectLength + 1);\n        const [\n            topValue,\n            rightValue = topValue,\n            bottomValue = topValue,\n            leftValue = rightValue,\n        ] = values.slice(0, rectLength);\n        const [top, bottom] = [topValue, bottomValue].map(pos => convertUnitSize(pos, height));\n        const [left, right] = [leftValue, rightValue].map(pos => convertUnitSize(pos, width));\n        const nextRight = width - right;\n        const nextBottom = height - bottom;\n        const radiusPoses = getRadiusValues(\n            radiusValues,\n            nextRight - left,\n            nextBottom - top,\n            left,\n            top,\n        );\n        const poses: ControlPose[] = [\n            ...getRectPoses(top, nextRight, nextBottom, left),\n            ...radiusPoses,\n        ];\n\n        return {\n            type: \"inset\",\n            clipText,\n            poses,\n            top,\n            left,\n            right: nextRight,\n            bottom: nextBottom,\n            radius: radiusValues,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"rect\") {\n        // top right bottom left\n        const values = splitComma(value! || `0px, ${width}px, ${height}px, 0px`);\n\n        splitter = \",\";\n        const [top, right, bottom, left] = values.map(pos => {\n            const { value: posValue } = splitUnit(pos);\n\n            return posValue;\n        });\n        const poses = getRectPoses(top, right, bottom, left);\n\n        return {\n            type: \"rect\",\n            clipText,\n            poses,\n            top,\n            right,\n            bottom,\n            left,\n            values,\n            splitter,\n        } as const;\n    }\n    return;\n}\nfunction addClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const [distX, distY] = calculatePointerDist(moveable, e);\n    const { clipPath, index } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    if (clipType === \"polygon\") {\n        poses.splice(index, 0, [distX, distY]);\n    } else if (clipType === \"inset\") {\n        const horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);\n        const verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);\n        const length = clipPoses.length;\n\n        addRadiusPos(\n            clipPoses,\n            poses,\n            8,\n            horizontalIndex,\n            verticalIndex,\n            distX,\n            distY,\n            poses[4][0],\n            poses[4][1],\n            poses[0][0],\n            poses[0][1],\n        );\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"added\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\nfunction removeClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const { clipPath, index } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    const length = poses.length;\n    if (clipType === \"polygon\") {\n        clipPoses.splice(index, 1);\n        poses.splice(index, 1);\n    } else if (clipType === \"inset\") {\n        if (index < 8) {\n            return;\n        }\n        removeRadiusPos(clipPoses, poses, index, 8, length);\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"removed\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\nexport default {\n    name: \"clippable\",\n    props: {\n        clippable: Boolean,\n        defaultClipPath: String,\n        customClipPath: String,\n        clipRelative: Boolean,\n        clipArea: Boolean,\n        dragWithClip: Boolean,\n        clipTargetBounds: Boolean,\n        clipVerticalGuidelines: Array,\n        clipHorizontalGuidelines: Array,\n        clipSnapThreshold: Boolean,\n    } as const,\n    events: {\n        onClipStart: \"clipStart\",\n        onClip: \"clip\",\n        onClipEnd: \"clipEnd\",\n    } as const,\n    css: [\n        `.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`,\n        `:host {\n    --bounds-color: #d66;\n}`,\n        `.guideline {\n    pointer-events: none;\n    z-index: 2;\n}`,\n        `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, React: Renderer): any[] {\n        const {\n            customClipPath, defaultClipPath,\n            clipArea, zoom,\n        } = moveable.props;\n        const {\n            target, width, height, allMatrix, is3d, left, top,\n            pos1, pos2, pos3, pos4,\n            clipPathState,\n            snapBoundInfos,\n        } = moveable.state;\n\n        if (!target) {\n            return [];\n        }\n\n        const clipPath = getClipPath(\n            target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n\n        if (!clipPath) {\n            return [];\n        }\n        const n = is3d ? 4 : 3;\n        const type = clipPath.type;\n        const clipPoses = clipPath.poses;\n        const poses = clipPoses.map(pos => {\n            // return [x, y];\n            const calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n\n            return [\n                calculatedPos[0] - left,\n                calculatedPos[1] - top,\n            ];\n        });\n\n        let controls: any[] = [];\n        let lines: any[] = [];\n\n        const isRect = type === \"rect\";\n        const isInset = type === \"inset\";\n        const isPolygon = type === \"polygon\";\n\n        if (isRect || isInset || isPolygon) {\n            const linePoses = isInset ? poses.slice(0, 8) : poses;\n\n            lines = linePoses.map((to, i) => {\n                const from = i === 0 ? linePoses[linePoses.length - 1] : linePoses[i - 1];\n\n                const rad = getRad(from, to);\n                const dist = getDiagonalSize(from, to);\n                return <div key={`clipLine${i}`} className={prefix(\"line\", \"clip-line\", \"snap-control\")}\n                    data-clip-index={i}\n                    style={{\n                        width: `${dist}px`,\n                        transform: `translate(${from[0]}px, ${from[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n                    }}></div>;\n            });\n        }\n        controls = poses.map((pos, i) => {\n            return <div key={`clipControl${i}`}\n                className={prefix(\"control\", \"clip-control\", \"snap-control\")}\n                data-clip-index={i}\n                style={{\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) scale(${zoom})`,\n                }}></div>;\n        });\n\n        if (isInset) {\n            controls.push(...poses.slice(8).map((pos, i) => {\n                return <div key={`clipRadiusControl${i}`}\n                    className={prefix(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\")}\n                    data-clip-index={8 + i}\n                    style={{\n                        transform: `translate(${pos[0]}px, ${pos[1]}px) scale(${zoom})`,\n                    }}></div>;\n            }));\n        }\n        if (type === \"circle\" || type === \"ellipse\") {\n            const {\n                left: clipLeft,\n                top: clipTop,\n                radiusX,\n                radiusY,\n            } = clipPath;\n\n            const [distLeft, distTop] = minus(\n                calculatePosition(allMatrix, [clipLeft!, clipTop!], n),\n                calculatePosition(allMatrix, [0, 0], n),\n            );\n            let ellipseClipPath = \"none\";\n\n            if (!clipArea) {\n                const piece = Math.max(10, radiusX! / 5, radiusY! / 5);\n                const areaPoses: number[][] = [];\n\n                for (let i = 0; i <= piece; ++i) {\n                    const rad = Math.PI * 2 / piece * i;\n                    areaPoses.push([\n                        radiusX! + (radiusX! - zoom!) * Math.cos(rad),\n                        radiusY! + (radiusY! - zoom!) * Math.sin(rad),\n                    ]);\n                }\n                areaPoses.push([radiusX!, -2]);\n                areaPoses.push([-2, -2]);\n                areaPoses.push([-2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, -2]);\n                areaPoses.push([radiusX!, -2]);\n\n                ellipseClipPath = `polygon(${areaPoses.map(pos => `${pos[0]}px ${pos[1]}px`).join(\", \")})`;\n            }\n            controls.push(<div key=\"clipEllipse\" className={prefix(\"clip-ellipse\", \"snap-control\")} style={{\n                width: `${radiusX! * 2}px`,\n                height: `${radiusY! * 2}px`,\n                clipPath: ellipseClipPath,\n                transform: `translate(${-left + distLeft}px, ${-top + distTop}px) ${makeMatrixCSS(allMatrix)}`,\n            }}></div>);\n        }\n        if (clipArea) {\n            const {\n                width: allWidth,\n                height: allHeight,\n                left: allLeft,\n                top: allTop,\n            } = getRect([pos1, pos2, pos3, pos4, ...poses]);\n            if (isPolygon || isRect || isInset) {\n                const areaPoses = isInset ? poses.slice(0, 8) : poses;\n                controls.push(<div key=\"clipArea\" className={prefix(\"clip-area\", \"snap-control\")} style={{\n                    width: `${allWidth}px`,\n                    height: `${allHeight}px`,\n                    transform: `translate(${allLeft}px, ${allTop}px)`,\n                    clipPath: `polygon(${areaPoses.map(pos => `${pos[0] - allLeft}px ${pos[1] - allTop}px`).join(\", \")})`,\n                }}></div>);\n            }\n        }\n        if (snapBoundInfos) {\n            ([\"vertical\", \"horizontal\"] as const).forEach(directionType => {\n                const info = snapBoundInfos[directionType];\n                const isHorizontal = directionType === \"horizontal\";\n                if (info.isSnap) {\n                    lines.push(...info.snap.posInfos.map(({ pos }, i) => {\n                        const snapPos1 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n                        const snapPos2 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n\n                        return renderLine(\n                            React, \"\", snapPos1, snapPos2, zoom!,\n                            `clip${directionType}snap${i}`, \"guideline\");\n                    }));\n                }\n                if (info.isBound) {\n                    lines.push(...info.bounds.map(({ pos }, i) => {\n                        const snapPos1 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);\n                        const snapPos2 = minus(calculatePosition(\n                            allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);\n\n                        return renderLine(\n                            React, \"\", snapPos1, snapPos2, zoom!,\n                            `clip${directionType}bounds${i}`, \"guideline\", \"bounds\", \"bold\");\n                    }));\n                }\n            });\n        }\n        return [\n            ...controls,\n            ...lines,\n        ];\n    },\n    dragControlCondition(moveable: any, e: any) {\n        return e.inputEvent && (e.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n    },\n    dragStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const props = moveable.props;\n        const {\n            dragWithClip = true,\n        } = props;\n\n        if (dragWithClip) {\n            return false;\n        }\n\n        return this.dragControlStart(moveable, e);\n    },\n    drag(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        return this.dragControl(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        return this.dragControlEnd(moveable, e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const state = moveable.state;\n        const { defaultClipPath, customClipPath } = moveable.props;\n        const { target, width, height } = state;\n        const inputTarget = e.inputEvent ? e.inputEvent.target : null;\n        const className = inputTarget ? inputTarget.getAttribute(\"class\") : \"\";\n        const datas = e.datas;\n        const clipPath = getClipPath(target!, width, height, defaultClipPath || \"inset\", customClipPath);\n\n        if (!clipPath) {\n            return false;\n        }\n        const { clipText, type, poses } = clipPath;\n        const result = triggerEvent(moveable, \"onClipStart\", fillParams<OnClipStart>(moveable, e, {\n            clipType: type,\n            clipStyle: clipText,\n            poses: poses.map(pos => pos.pos),\n        }));\n\n        if (result === false) {\n            datas.isClipStart = false;\n            return false;\n        }\n        datas.isControl = className.indexOf(\"clip-control\") > -1;\n        datas.isLine = className.indexOf(\"clip-line\") > -1;\n        datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n        datas.index = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n        datas.clipPath = clipPath;\n        datas.isClipStart = true;\n        state.clipPathState = clipText;\n        setDragStart(moveable, e);\n\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const { datas, originalDatas } = e;\n\n        if (!datas.isClipStart) {\n            return false;\n        }\n        const draggableData = (originalDatas && originalDatas.draggable) || {};\n        const { isControl, isLine, isArea, index, clipPath } = datas as {\n            clipPath: ReturnType<typeof getClipPath>,\n            [key: string]: any,\n        };\n        if (!clipPath) {\n            return false;\n        }\n        let [distX, distY] = draggableData.isDrag ? draggableData.prevDist : getDragDist(e);\n        const props = moveable.props;\n        const state = moveable.state;\n        const { width, height } = state;\n        const isDragWithTarget = !isArea && !isControl && !isLine;\n        const {\n            type: clipType,\n            poses: clipPoses,\n            splitter,\n        } = clipPath;\n        const poses = clipPoses.map(pos => pos.pos);\n\n        if (isDragWithTarget) {\n            distX = -distX;\n            distY = -distY;\n        }\n        const isAll = !isControl || clipPoses[index].direction === \"nesw\";\n        const isRect = clipType === \"inset\" || clipType === \"rect\";\n        let dists = clipPoses.map(() => [0, 0]);\n\n        if (isControl && !isAll) {\n            const { horizontal, vertical } = clipPoses[index];\n            const dist = [\n                distX * Math.abs(horizontal),\n                distY * Math.abs(vertical),\n            ];\n            dists = moveControlPos(clipPoses, index, dist, isRect);\n        } else if (isAll) {\n            dists = poses.map(() => [distX, distY]);\n        }\n        const nextPoses: number[][] = poses.map((pos, i) => plus(pos, dists[i]));\n        const guidePoses = [...nextPoses];\n\n        state.snapBoundInfos = null;\n        const isCircle = clipPath.type === \"circle\";\n        const isEllipse = clipPath.type === \"ellipse\";\n\n        if (isCircle || isEllipse) {\n            const guideRect = getRect(nextPoses);\n            const ry = Math.abs(guideRect.bottom - guideRect.top);\n            const rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);\n            const bottom = nextPoses[0][1] + ry;\n            const left = nextPoses[0][0] - rx;\n            const right = nextPoses[0][0] + rx;\n\n            // right\n            if (isCircle) {\n                guidePoses.push([right, guideRect.bottom]);\n                dists.push([1, 0]);\n            }\n            // bottom\n            guidePoses.push([guideRect.left, bottom]);\n            dists.push([0, 1]);\n            // left\n            guidePoses.push([left, guideRect.bottom]);\n            dists.push([1, 0]);\n        }\n\n        const guidelines = getDefaultGuidelines(\n            (props.clipHorizontalGuidelines || []).map(v => convertUnitSize(`${v}`, height)),\n            (props.clipVerticalGuidelines || []).map(v => convertUnitSize(`${v}`, width)),\n            width!, height!,\n        );\n        let guideXPoses: number[] = [];\n        let guideYPoses: number[] = [];\n\n        if (isCircle || isEllipse) {\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n        } else if (isRect) {\n            const rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n            const rectDists = [dists[0], dists[2], dists[4], dists[6]];\n\n            guideXPoses = rectPoses.filter((_, i) => rectDists[i][0]).map(pos => pos[0]);\n            guideYPoses = rectPoses.filter((_, i) => rectDists[i][1]).map(pos => pos[1]);\n        } else {\n            guideXPoses = guidePoses.filter((_, i) => dists[i][0]).map(pos => pos[0]);\n            guideYPoses = guidePoses.filter((_, i) => dists[i][1]).map(pos => pos[1]);\n        }\n        for (let i = 0; i < 2; ++i) {\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkSnapBounds(\n                guidelines,\n                props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height },\n                guideXPoses,\n                guideYPoses,\n                {\n                    snapThreshold: 5,\n                },\n            );\n            const snapOffsetY = horizontalSnapInfo.offset;\n            const snapOffsetX = verticalSnapInfo.offset;\n\n            if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n                const guideRect = getRect(nextPoses);\n                let cy = guideRect.bottom - guideRect.top;\n                let cx = isEllipse ? guideRect.right - guideRect.left : cy;\n                const distSnapX = verticalSnapInfo.isBound\n                    ? Math.abs(snapOffsetX)\n                    : (verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX);\n                const distSnapY = horizontalSnapInfo.isBound\n                    ? Math.abs(snapOffsetY)\n                    : (horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY);\n                cx -= distSnapX;\n                cy -= distSnapY;\n\n                if (isCircle) {\n                    cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;\n                    cx = cy;\n                }\n                const center = guidePoses[0];\n\n                guidePoses[1][1] = center[1] - cy;\n                guidePoses[2][0] = center[0] + cx;\n                guidePoses[3][1] = center[1] + cy;\n                guidePoses[4][0] = center[0] - cx;\n            } else {\n                guidePoses.forEach((pos, j) => {\n                    const dist = dists[j];\n\n                    if (dist[0]) {\n                        pos[0] -= snapOffsetX;\n                    }\n                    if (dist[1]) {\n                        pos[1] -= snapOffsetY;\n                    }\n                });\n                break;\n            }\n        }\n        const nextClipStyles = getClipStyles(moveable, clipPath, nextPoses)!;\n        const clipStyle = `${clipType}(${nextClipStyles.join(splitter)})`;\n\n        state.clipPathState = clipStyle;\n\n        if (isCircle || isEllipse) {\n            guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n            guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n        } else if (isRect) {\n            const rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];\n\n            guideXPoses = rectPoses.map(pos => pos[0]);\n            guideYPoses = rectPoses.map(pos => pos[1]);\n        } else {\n            guideXPoses = guidePoses.map(pos => pos[0]);\n            guideYPoses = guidePoses.map(pos => pos[1]);\n        }\n        state.snapBoundInfos = checkSnapBounds(\n            guidelines,\n            props.clipTargetBounds && { left: 0, top: 0, right: width, bottom: height },\n            guideXPoses,\n            guideYPoses,\n            {\n                snapThreshold: 1,\n            },\n        );\n\n        triggerEvent(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n            clipEventType: \"changed\",\n            clipType,\n            poses: nextPoses,\n            clipStyle,\n            clipStyles: nextClipStyles,\n            distX,\n            distY,\n        }));\n\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        this.unset(moveable);\n        const { isDrag, datas, isDouble } = e;\n        const { isLine, isClipStart, isControl } = datas;\n\n        if (!isClipStart) {\n            return false;\n        }\n        triggerEvent(moveable, \"onClipEnd\", fillEndParams<OnClipEnd>(moveable, e, {}));\n        if (isDouble) {\n            if (isControl) {\n                removeClipPath(moveable, e);\n            } else if (isLine) {\n                // add\n                addClipPath(moveable, e);\n            }\n        }\n        return isDouble || isDrag;\n    },\n    unset(moveable: MoveableManagerInterface<ClippableProps, ClippableState>) {\n        moveable.state.clipPathState = \"\";\n        moveable.state.snapBoundInfos = null;\n    },\n};\n\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea. (default: false)\n * @name Moveable.Clippable#clipArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n* Whether the clip is bound to the target. (default: false)\n* @name Moveable.Clippable#clipTargetBounds\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipTargetBounds: true,\n* });\n* moveable.on(\"clipStart\", e => {\n*     console.log(e);\n* }).on(\"clip\", e => {\n*     if (e.clipType === \"rect\") {\n*         e.target.style.clip = e.clipStyle;\n*     } else {\n*         e.target.style.clipPath = e.clipStyle;\n*     }\n* }).on(\"clipEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* Add clip guidelines in the vertical direction. (default: [])\n* @name Moveable.Clippable#clipVerticalGuidelines\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n\n/**\n* Add clip guidelines in the horizontal direction. (default: [])\n* @name Moveable.Clippable#clipHorizontalGuidelines\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n/**\n* istance value that can snap to clip guidelines. (default: 5)\n* @name Moveable.Clippable#clipSnapThreshold\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     clippable: true,\n*     defaultClipPath: \"inset\",\n*     customClipPath: \"\",\n*     clipRelative: false,\n*     clipArea: false,\n*     dragWithClip: true,\n*     clipVerticalGuidelines: [0, 100, 200],\n*     clipHorizontalGuidelines: [0, 100, 200],\n*     clipSnapThreshold: 5,\n* });\n*/\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    prefix, triggerEvent,\n    fillParams, calculatePoses, getRect, fillEndParams, convertCSSSize,\n} from \"../utils\";\nimport {\n    OnDragOriginStart, OnDragOrigin,\n    OnDragOriginEnd, MoveableManagerInterface, DraggableProps, OriginDraggableProps, MoveableGroupInterface,\n} from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, getNextMatrix } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport Draggable from \"./Draggable\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\nexport default {\n    name: \"originDraggable\",\n    props: {\n        originDraggable: Boolean,\n        originRelative: Boolean,\n    } as const,\n    events: {\n        onDragOriginStart: \"dragOriginStart\",\n        onDragOrigin: \"dragOrigin\",\n        onDragOriginEnd: \"dragOriginEnd\",\n    } as const,\n    css: [\n        `:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`,\n    ],\n    dragControlCondition(_: any, e: any) {\n        if (e.isRequest) {\n            return e.requestAble === \"originDraggable\";\n        }\n        return hasClass(e.inputEvent.target, prefix(\"origin\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas } = e;\n\n        setDragStart(moveable, e);\n\n        const params = fillParams<OnDragOriginStart>(moveable, e, {\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = triggerEvent<OriginDraggableProps>(\n            moveable, \"onDragOriginStart\", params);\n\n        datas.startOrigin = moveable.state.transformOrigin;\n        datas.startTargetOrigin = moveable.state.targetOrigin;\n        datas.prevOrigin = [0, 0];\n        datas.isDragOrigin = true;\n\n        if (result === false) {\n            datas.isDragOrigin = false;\n            return false;\n        }\n\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas, isPinch, isRequest } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        const [distX, distY] = getDragDist(e);\n        const state = moveable.state;\n        const {\n            width,\n            height,\n            offsetMatrix,\n            targetMatrix,\n            is3d,\n        } = state;\n        const {\n            originRelative = true,\n        } = moveable.props;\n        const n = is3d ? 4 : 3;\n        let dist = [distX, distY];\n\n        if (isRequest) {\n            const distOrigin = e.distOrigin;\n            if (distOrigin[0] || distOrigin[1]) {\n                dist = distOrigin;\n            }\n        }\n        const origin = plus(datas.startOrigin, dist);\n        const targetOrigin = plus(datas.startTargetOrigin, dist);\n        const delta = minus(dist, datas.prevOrigin);\n\n        const nextMatrix = getNextMatrix(\n            offsetMatrix,\n            targetMatrix,\n            origin,\n            n,\n        );\n\n        const rect = moveable.getRect();\n        const nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n\n        const dragDelta = [\n            rect.left - nextRect.left,\n            rect.top - nextRect.top,\n        ];\n\n        datas.prevOrigin = dist;\n        const transformOrigin = [\n            convertCSSSize(targetOrigin[0], width, originRelative),\n            convertCSSSize(targetOrigin[1], height, originRelative),\n        ].join(\" \");\n        const params = fillParams<OnDragOrigin>(moveable, e, {\n            width,\n            height,\n            origin,\n            dist,\n            delta,\n            transformOrigin,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false),\n            )!,\n        });\n        triggerEvent<OriginDraggableProps>(moveable, \"onDragOrigin\", params);\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<OriginDraggableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        triggerEvent<OriginDraggableProps>(moveable, \"onDragOriginEnd\",\n            fillEndParams<OnDragOriginEnd>(moveable, e, {}));\n        return true;\n    },\n    dragGroupControlCondition(moveable: any, e: any) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        return true;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        moveable.transformOrigin = params.transformOrigin;\n\n        return true;\n    },\n    /**\n    * @method Moveable.OriginDraggable#request\n    * @param {object} e - the OriginDraggable's request parameter\n    * @param {number} [e.x] - x position\n    * @param {number} [e.y] - y position\n    * @param {number} [e.deltaX] - x number to move\n    * @param {number} [e.deltaY] - y number to move\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n    * @param {array} [e.origin] - transform-origin position\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\n    * @return {Moveable.Requester} Moveable Requester\n    * @example\n\n    * // Instantly Request (requestStart - request - requestEnd)\n    * // Use Relative Value\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n    * // Use Transform Value\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n    * // requestStart\n    * const requester = moveable.request(\"originDraggable\");\n    *\n    * // request\n    * // Use Relative Value\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n    *\n    * // requestEnd\n    * requester.requestEnd();\n    */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        const transformOrigin = rect.transformOrigin;\n        const distOrigin = [0, 0];\n\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaOrigin\" in e) {\n                    distOrigin[0] += e.deltaOrigin[0];\n                    distOrigin[1] += e.deltaOrigin[1];\n                } else if (\"origin\" in e) {\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\n                } else {\n                    if (\"x\" in e) {\n                        distX = e.x - rect.left;\n                    } else if (\"deltaX\" in e) {\n                        distX += e.deltaX;\n                    }\n                    if (\"y\" in e) {\n                        distY = e.y - rect.top;\n                    } else if (\"deltaY\" in e) {\n                        distY += e.deltaY;\n                    }\n                }\n\n                return { datas, distX, distY, distOrigin };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n","import {\n    prefix, triggerEvent,\n    fillParams, fillEndParams, calculatePosition,\n    getComputedStyle,\n} from \"../utils\";\nimport {\n    Renderer, RoundableProps, OnRoundStart, RoundableState, OnRound, ControlPose, OnRoundEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { splitSpace } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, calculatePointerDist } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    getRadiusValues, getRadiusStyles, removeRadiusPos,\n    addRadiusPos, splitRadiusPoses,\n} from \"./roundable/borderRadius\";\n\nfunction addBorderRadius(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    lineIndex: number,\n    distX: number,\n    distY: number,\n    width: number,\n    height: number,\n) {\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses);\n    const horizontalsLength = horizontals.length;\n    const verticalsLength = verticals.length;\n    // lineIndex\n    // 0 top\n    // 1 right\n    // 2 left\n    // 3 bottom\n\n    // 0 top - left\n    // 1 top - right\n    // 2 bottom - right\n    // 3 bottom - left\n    // 0 left - top\n    // 1 right - top\n    // 2 right - bottom\n    // 3 left - bottom\n    let horizontalIndex = -1;\n    let verticalIndex = -1;\n\n    if (lineIndex === 0) {\n        if (horizontalsLength === 0) {\n            horizontalIndex = 0;\n        } else if (horizontalsLength === 1) {\n            horizontalIndex = 1;\n        }\n    } else if (lineIndex === 3) {\n        if (horizontalsLength <= 2) {\n            horizontalIndex = 2;\n        } else if (horizontalsLength <= 3) {\n            horizontalIndex = 3;\n        }\n    }\n    if (lineIndex === 2) {\n        if (verticalsLength === 0) {\n            verticalIndex = 0;\n        } else if (verticalsLength < 4) {\n            verticalIndex = 3;\n        }\n    } else if (lineIndex === 1) {\n        if (verticalsLength <= 1) {\n            verticalIndex = 1;\n        } else if (verticalsLength <= 2) {\n            verticalIndex = 2;\n        }\n    }\n\n    addRadiusPos(\n        controlPoses, poses, 0,\n        horizontalIndex, verticalIndex,\n        distX, distY, width, height,\n    );\n}\nfunction getBorderRadius(\n    target: HTMLElement | SVGElement,\n    width: number, height: number,\n    minCounts: number[] = [0, 0],\n    state?: string,\n) {\n    let borderRadius: string;\n    let values: string[] = [];\n\n    if (!state) {\n        const style = getComputedStyle(target);\n\n        borderRadius = (style && style.borderRadius) || \"\";\n    } else {\n        borderRadius = state;\n    }\n    if (!borderRadius || (!state && borderRadius === \"0px\")) {\n        values = [];\n    } else {\n        values = splitSpace(borderRadius);\n    }\n\n    return getRadiusValues(values, width, height, 0, 0, minCounts);\n}\n\nfunction triggerRoundEvent(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any,\n    dist: number[],\n    delta: number[],\n    controlPoses: ControlPose[],\n    nextPoses: number[][],\n) {\n    const state = moveable.state;\n    const {\n        width,\n        height,\n    } = state;\n    const {\n        raws,\n        styles,\n    } = getRadiusStyles(\n        nextPoses,\n        controlPoses,\n        moveable.props.roundRelative!,\n        width,\n        height,\n    );\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses, raws);\n    const borderRadius = styles.join(\" \");\n\n    state.borderRadiusState = borderRadius;\n    triggerEvent<RoundableProps>(moveable, \"onRound\", fillParams<OnRound>(moveable, e, {\n        horizontals,\n        verticals,\n        borderRadius,\n        width,\n        height,\n        delta,\n        dist,\n    }));\n}\n\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\nexport default {\n    name: \"roundable\",\n    props: {\n        roundable: Boolean,\n        roundRelative: Boolean,\n        minRoundControls: Array,\n        maxRoundControls: Array,\n        roundClickable: Boolean,\n    } as const,\n    events: {\n        onRoundStart: \"roundStart\",\n        onRound: \"round\",\n        onRoundEnd: \"roundEnd\",\n    } as const,\n    css: [\n        `.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}`,\n        `:host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, React: Renderer): any {\n        const {\n            target,\n            width,\n            height,\n            allMatrix,\n            is3d,\n            left,\n            top,\n            borderRadiusState,\n        } = moveable.state;\n        const {\n            minRoundControls = [0, 0],\n            maxRoundControls = [4, 4],\n            zoom,\n        } = moveable.props;\n\n        if (!target) {\n            return null;\n        }\n\n        const n = is3d ? 4 : 3;\n        const radiusValues = getBorderRadius(\n            target, width, height, minRoundControls, borderRadiusState);\n\n        if (!radiusValues) {\n            return null;\n        }\n        let verticalCount = 0;\n        let horizontalCount = 0;\n\n        return radiusValues.map((v, i) => {\n            horizontalCount += Math.abs(v.horizontal);\n            verticalCount += Math.abs(v.vertical);\n            const pos = minus(calculatePosition(allMatrix, v.pos, n), [left, top]);\n            const isDisplay = v.vertical\n                ? verticalCount <= maxRoundControls[1]\n                : horizontalCount <= maxRoundControls[0];\n\n            return <div key={`borderRadiusControl${i}`}\n                className={prefix(\"control\", \"border-radius\")}\n                data-radius-index={i}\n                style={{\n                    display: isDisplay ? \"block\" : \"none\",\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) scale(${zoom})`,\n                }}></div>;\n        });\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (!e.inputEvent || e.isRequest) {\n            return false;\n        }\n        const className = (e.inputEvent.target.getAttribute(\"class\") || \"\");\n\n        return className.indexOf(\"border-radius\") > -1\n            || (className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { inputEvent, datas } = e;\n        const inputTarget = inputEvent.target;\n        const className = (inputTarget.getAttribute(\"class\") || \"\");\n        const isControl = className.indexOf(\"border-radius\") > -1;\n        const isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n        const controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n        const lineIndex = isLine ? parseInt(inputTarget.getAttribute(\"data-line-index\"), 10) : -1;\n\n        if (!isControl && !isLine) {\n            return false;\n        }\n\n        const result = triggerEvent<RoundableProps>(\n            moveable, \"onRoundStart\", fillParams<OnRoundStart>(moveable, e, {}));\n\n        if (result === false) {\n            return false;\n        }\n\n        datas.lineIndex = lineIndex;\n        datas.controlIndex = controlIndex;\n        datas.isControl = isControl;\n        datas.isLine = isLine;\n\n        setDragStart(moveable, e);\n\n        const {\n            roundRelative,\n            minRoundControls = [0, 0],\n        } = moveable.props;\n        const state = moveable.state;\n        const {\n            target,\n            width,\n            height,\n        } = state;\n\n        datas.isRound = true;\n        datas.prevDist = [0, 0];\n        const controlPoses = getBorderRadius(target!, width, height, minRoundControls) || [];\n\n        datas.controlPoses = controlPoses;\n\n        state.borderRadiusState = getRadiusStyles(\n            controlPoses.map(pos => pos.pos), controlPoses, roundRelative!, width, height).styles.join(\" \");\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {\n            return false;\n        }\n        const index = datas.controlIndex as number;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const [distX, distY] = getDragDist(e);\n        const dist = [distX, distY];\n        const delta = minus(dist, datas.prevDist);\n        const {\n            maxRoundControls = [4, 4],\n        } = moveable.props;\n        const { width, height } = moveable.state;\n        const selectedControlPose = controlPoses[index];\n        const selectedVertical = selectedControlPose.vertical;\n        const selectedHorizontal = selectedControlPose.horizontal;\n\n        // 0: [0, 1, 2, 3] maxCount === 1\n        // 0: [0, 2] maxCount === 2\n        // 1: [1, 3] maxCount === 2\n\n        // 0: [0] maxCount === 3\n        // 1: [1, 3] maxCount === 3\n\n        const dists = controlPoses.map(pose => {\n            const { horizontal, vertical } = pose;\n            const poseDist = [\n                horizontal * selectedHorizontal * dist[0],\n                vertical * selectedVertical * dist[1],\n            ];\n            if (horizontal) {\n                if (maxRoundControls[0] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\n                    return poseDist;\n                }\n            } else if (maxRoundControls[1] === 0) {\n                poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\n\n                return poseDist;\n            } else if (selectedVertical) {\n                if (maxRoundControls[1] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n                    return poseDist;\n                }\n            }\n            return [0, 0];\n        });\n        dists[index] = dist;\n        const nextPoses = controlPoses.map((pos, i) => plus(pos.pos, dists[i]));\n\n        datas.prevDist = [distX, distY];\n\n        triggerRoundEvent(\n            moveable,\n            e,\n            dist,\n            delta,\n            controlPoses,\n            nextPoses,\n        );\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const state = moveable.state;\n\n        state.borderRadiusState = \"\";\n        const { datas, isDouble } = e;\n        if (!datas.isRound) {\n            return false;\n        }\n        const {\n            width,\n            height,\n        } = state;\n        const {\n            isControl,\n            controlIndex,\n            isLine,\n            lineIndex,\n        } = datas;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const poses = controlPoses.map(pos => pos.pos);\n        const length = poses.length;\n        const {\n            roundClickable = true,\n        } = moveable.props;\n\n        if (isDouble && roundClickable) {\n            if (isControl) {\n                removeRadiusPos(controlPoses, poses, controlIndex, 0);\n            } else if (isLine) {\n                const [distX, distY] = calculatePointerDist(moveable, e);\n\n                addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);\n            }\n            if (length !== controlPoses.length) {\n                triggerRoundEvent(\n                    moveable,\n                    e,\n                    [0, 0],\n                    [0, 0],\n                    controlPoses,\n                    poses,\n                );\n            }\n        }\n        triggerEvent<RoundableProps>(moveable, \"onRoundEnd\",\n            fillEndParams<OnRoundEnd>(moveable, e, {}));\n        state.borderRadiusState = \"\";\n        return true;\n    },\n    unset(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        moveable.state.borderRadiusState = \"\";\n    },\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\n * @name Moveable.Roundable#minRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     minRoundControls: [0, 0],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\n * @name Moveable.Roundable#maxRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     maxRoundControls: [4, 4],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * @property - Whether you can add/delete round controls by double-clicking a line or control. (default: true)\n * @name Moveable.Roundable#roundClickable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     roundClickable: true,\n * });\n * moveable.roundClickable = false;\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    MoveableManagerInterface, BeforeRenderableProps,\n    OnBeforeRenderStart, OnBeforeRender, OnBeforeRenderEnd,\n    MoveableGroupInterface, OnBeforeRenderGroupStart,\n    OnBeforeRenderGroup, OnBeforeRenderGroupEnd,\n} from \"../types\";\nimport { fillParams, triggerEvent } from \"../utils\";\nimport { convertMatrixtoCSS } from \"@scena/matrix\";\nimport { isArray, splitSpace } from \"@daybrush/utils\";\nimport { fillChildEvents } from \"../groupUtils\";\n\nexport default {\n    isPinch: true,\n    name: \"beforeRenderable\",\n    props: {\n    } as const,\n    events: {\n        onBeforeRenderStart: \"beforeRenderStart\",\n        onBeforeRender: \"beforeRender\",\n        onBeforeRenderEnd: \"beforeRenderEnd\",\n        onBeforeRenderGroupStart: \"beforeRenderGroupStart\",\n        onBeforeRenderGroup: \"beforeRenderGroup\",\n        onBeforeRenderGroupEnd: \"beforeRenderGroupEnd\",\n    } as const,\n    setTransform(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        const {\n            is3d,\n            target,\n            targetMatrix,\n        } = moveable.state;\n        const transform = target?.style.transform;\n        const cssMatrix = is3d\n            ? `matrix3d(${targetMatrix.join(\",\")})`\n            : `matrix(${convertMatrixtoCSS(targetMatrix, true)})`;\n        e.datas.startTransforms = !transform || transform === \"none\" ? [cssMatrix] : splitSpace(transform);\n    },\n    resetTransform(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        e.datas.nextTransforms = e.datas.startTransforms;\n        e.datas.nextTransformAppendedIndexes = [];\n    },\n    fillDragStartParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRenderStart>(moveable, e, {\n            setTransform: (transform: string | string[]) => {\n                e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            },\n            isPinch: !!e.isPinch,\n        });\n    },\n    fillDragParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        });\n    },\n    dragStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.setTransform(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRenderStart`, this.fillDragStartParams(moveable, e));\n    },\n    drag(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.resetTransform(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRender`, fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    dragEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        triggerEvent(moveable, `onBeforeRenderEnd`, fillParams<OnBeforeRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragStart(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.setTransform(childMoveable, childEvent);\n            return this.fillDragStartParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroupStart`, fillParams<OnBeforeRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            setTransform() { },\n            events: params,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.drag(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.resetTransform(childMoveable, childEvent);\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onBeforeRenderGroup`, fillParams<OnBeforeRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            events: params,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragEnd(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRenderGroupEnd`, fillParams<OnBeforeRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n} as const;\n","import {\n    MoveableManagerInterface, RenderableProps, OnRenderStart, OnRender,\n    OnRenderEnd, MoveableGroupInterface,\n    OnRenderGroupStart, OnRenderGroup, OnRenderGroupEnd,\n} from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\n\nexport default {\n    name: \"renderable\",\n    props: {\n    } as const,\n    events: {\n        onRenderStart: \"renderStart\",\n        onRender: \"render\",\n        onRenderEnd: \"renderEnd\",\n        onRenderGroupStart: \"renderGroupStart\",\n        onRenderGroup: \"renderGroup\",\n        onRenderGroupEnd: \"renderGroupEnd\",\n    } as const,\n    dragStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderStart`, fillParams<OnRenderStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    drag(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRender`, fillParams<OnRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    dragEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderEnd`, fillParams<OnRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderGroupStart`, fillParams<OnRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderGroup`, fillParams<OnRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderGroupEnd`, fillParams<OnRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n} as const;\n","import { Able, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { convertDragDist } from \"../utils\";\nimport Gesto from \"gesto\";\nimport BeforeRenderable from \"../ables/BeforeRenderable\";\nimport Renderable from \"../ables/Renderable\";\n\nexport function triggerAble(\n    moveable: MoveableManagerInterface,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    requestInstant?: boolean,\n) {\n    const isStart = eventType === \"Start\";\n    const target = moveable.state.target;\n    const isRequest = e.isRequest;\n\n    if (\n        !target\n        || (isStart && eventAffix.indexOf(\"Control\") > -1\n            && !isRequest && moveable.areaElement === e.inputEvent.target)\n    ) {\n        return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType.indexOf(\"After\") > -1;\n    const isFirstStart = isStart && (\n        !moveable.targetGesto || !moveable.controlGesto\n        || (!moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag())\n    );\n\n    if (isFirstStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    if (eventType === \"\" && !isAfter && !isRequest) {\n        convertDragDist(moveable.state, e);\n    }\n    // const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Able[] = [BeforeRenderable, ...(moveable as any)[ableType].slice(), Renderable];\n\n    if (isRequest) {\n        const requestAble = e.requestAble;\n        if (!ables.some(able => able.name === requestAble)) {\n            ables.push(...moveable.props.ables!.filter(able => able.name === requestAble));\n        }\n    }\n\n    if (!ables.length) {\n        return false;\n    }\n    const events = ables.filter((able: any) => able[eventName]);\n    const datas = e.datas;\n\n    if (isFirstStart) {\n        events.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n\n    const inputEvent = e.inputEvent;\n    let inputTarget: Element;\n\n    if (isEnd && inputEvent) {\n        inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n    }\n    const results = events.filter((able: any) => {\n        const ableName = able.name;\n        const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n        if (isStart) {\n            nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);\n        }\n\n        if (nextDatas.isEventStart) {\n            return able[eventName](moveable, { ...e, datas: nextDatas, originalDatas: datas, inputTarget });\n        }\n        return false;\n    });\n\n    const isUpdate = results.length;\n    const isForceEnd = isStart && events.length && !isUpdate;\n\n    if (isEnd || isForceEnd) {\n        moveable.state.gesto = null;\n\n        if ((moveable as MoveableGroupInterface).moveables) {\n            (moveable as MoveableGroupInterface).moveables.forEach(childMoveable => {\n                childMoveable.state.gesto = null;\n            });\n        }\n    }\n    if (isFirstStart && isForceEnd) {\n        events.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n    if (moveable.isUnmounted || isForceEnd) {\n        return false;\n    }\n    if ((!isStart && isUpdate && !requestInstant) || isEnd) {\n        moveable.updateRect(eventType, true, false);\n        moveable.forceUpdate();\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n    return true;\n}\n\nexport function getTargetAbleGesto(\n    moveable: MoveableManagerInterface,\n    moveableTarget: HTMLElement | SVGElement,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox.getElement();\n    const targets: Array<HTMLElement | SVGElement> = [];\n\n    targets.push(controlBox);\n\n    if (!moveable.props.dragArea || moveable.props.dragTarget) {\n        targets.push(moveableTarget);\n    }\n\n    const startFunc = (e: any) => {\n        const eventTarget = e.inputEvent.target;\n        const areaElement = moveable.areaElement;\n\n        return eventTarget === areaElement\n            || !moveable.isMoveableElement(eventTarget)\n            || hasClass(eventTarget, \"moveable-area\")\n            || hasClass(eventTarget, \"moveable-padding\");\n    };\n\n    return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n        dragStart: startFunc,\n        pinchStart: startFunc,\n    });\n}\nexport function getAbleGesto(\n    moveable: MoveableManagerInterface,\n    target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n    ableType: string,\n    eventAffix: string,\n    conditionFunctions: IObject<any> = {},\n) {\n    const {\n        pinchOutside,\n        pinchThreshold,\n    } = moveable.props;\n    const options: IObject<any> = {\n        container: window,\n        pinchThreshold,\n        pinchOutside,\n    };\n    const gesto = new Gesto(target!, options);\n\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            gesto.on(`${eventOperation}${eventType}` as any, e => {\n                const eventName = e.eventType;\n\n                if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                    e.stop();\n                    return;\n                }\n                const result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n\n                if (!result) {\n                    e.stop();\n                }\n            });\n        });\n    });\n\n    return gesto;\n}\n","import { Able, MoveableManagerInterface } from \"./types\";\n\nexport default class EventManager {\n    private ables: Able[] = [];\n    constructor(\n        private target: HTMLElement | SVGElement | null,\n        private moveable: MoveableManagerInterface | null,\n        private eventName: string,\n    ) {\n        this.target!.addEventListener(this.eventName.toLowerCase(), this.onEvent);\n    }\n    public setAbles(ables: Able[]) {\n        this.ables = ables;\n    }\n    public onEvent = (e: Event) => {\n        const eventName = this.eventName;\n        const moveable = this.moveable!;\n\n        if (moveable.state.disableNativeEvent) {\n            return;\n        }\n        this.ables.forEach(able => {\n            (able as any)[eventName](moveable, {\n                inputEvent: e,\n            });\n        });\n    }\n    public destroy() {\n        this.target!.removeEventListener(this.eventName.toLowerCase(), this.onEvent);\n        this.target = null;\n        this.moveable = null;\n    }\n}\n","import * as React from \"react\";\nimport { createElement } from \"react\";\nimport { PREFIX } from \"./consts\";\nimport {\n    prefix,\n    getTargetInfo,\n    unset,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    flat,\n    groupByMap,\n    calculatePadding,\n    getAbsoluteRotation,\n} from \"./utils\";\nimport Gesto from \"gesto\";\nimport { ref } from \"framework-utils\";\nimport {\n    MoveableManagerProps, MoveableManagerState, Able,\n    RectInfo, Requester, PaddingBox, HitRect, MoveableManagerInterface,\n} from \"./types\";\nimport { triggerAble, getTargetAbleGesto, getAbleGesto } from \"./gesto/getAbleGesto\";\nimport { plus } from \"@scena/matrix\";\nimport { getKeys, IObject, removeEvent } from \"@daybrush/utils\";\nimport { renderLine } from \"./renderDirections\";\nimport { fitPoints, getAreaSize, getOverlapSize, isInside } from \"overlap-area\";\nimport EventManager from \"./EventManager\";\nimport styled from \"react-css-styled\";\n\nexport default class MoveableManager<T = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        dragTarget: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        edge: false,\n        parentMoveable: null,\n        wrapperMoveable: null,\n        parentPosition: null,\n        portalContainer: null,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        passDragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n        triggerAblesSimultaneously: false,\n        padding: {},\n        pinchOutside: true,\n        checkInput: false,\n        groupable: false,\n        cspNonce: \"\",\n        translateZ: 0,\n        cssStyled: null,\n        customStyledMap: {},\n        props: {},\n    };\n    public state: MoveableManagerState = {\n        container: null,\n        target: null,\n        gesto: null,\n        renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        disableNativeEvent: false,\n        ...getTargetInfo(null),\n    };\n    public enabledAbles: Able[] = [];\n    public targetAbles: Able[] = [];\n    public controlAbles: Able[] = [];\n    public controlBox!: { getElement(): HTMLElement };\n    public areaElement!: HTMLElement;\n    public targetGesto!: Gesto;\n    public controlGesto!: Gesto;\n    public rotation = 0;\n    public scale: number[] = [1, 1];\n    public isUnmounted = false;\n    public events: Record<string, EventManager | null>  = {\n        \"mouseEnter\": null,\n        \"mouseLeave\": null,\n    };\n\n    public render() {\n        const props = this.props;\n        const state = this.state;\n        const {\n            edge, parentPosition, className,\n            target: propsTarget,\n            zoom, cspNonce,\n            translateZ,\n            cssStyled: ControlBoxElement,\n            portalContainer,\n        } = props;\n\n        this.checkUpdate();\n        this.updateRenderPoses();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const { left, top, target: stateTarget, direction, renderPoses } = state;\n        const groupTargets = (props as any).targets;\n        const isDisplay = ((groupTargets && groupTargets.length) || propsTarget) && stateTarget;\n        const isDragging = this.isDragging();\n        const ableAttributes: IObject<boolean> = {};\n        const Renderer = {\n            createElement: React.createElement,\n        };\n        this.getEnabledAbles().forEach(able => {\n            ableAttributes[`data-able-${able.name.toLowerCase()}`] = true;\n        });\n        return (\n            <ControlBoxElement\n                cspNonce={cspNonce}\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1\n                    ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\")} ${className}`}\n                {...ableAttributes}\n                onClick={this.onPreventClick}\n                portalContainer={portalContainer}\n                style={{\n                    \"position\": \"absolute\",\n                    \"display\": isDisplay ? \"block\" : \"none\",\n                    \"transform\": `translate3d(${left - parentLeft}px, ${top - parentTop}px, ${translateZ})`,\n                    \"--zoom\": zoom,\n                    \"--zoompx\": `${zoom}px`,\n                }}>\n                {this.renderAbles()}\n                {renderLine(Renderer, edge ? \"n\" : \"\", renderPoses[0], renderPoses[1], zoom!, 0)}\n                {renderLine(Renderer, edge ? \"e\" : \"\", renderPoses[1], renderPoses[3], zoom!, 1)}\n                {renderLine(Renderer, edge ? \"w\" : \"\", renderPoses[0], renderPoses[2], zoom!, 2)}\n                {renderLine(Renderer, edge ? \"s\" : \"\", renderPoses[2], renderPoses[3], zoom!, 3)}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container, wrapperMoveable } = props;\n\n        this.updateEvent(props);\n        this.updateNativeEvents(props);\n        if (!container && !parentMoveable && !wrapperMoveable) {\n            this.updateRect(\"\", false, true);\n        }\n        this.updateCheckInput();\n    }\n    public componentDidUpdate(prevProps: MoveableManagerProps) {\n        this.updateNativeEvents(prevProps);\n        this.updateEvent(prevProps);\n        this.updateCheckInput();\n    }\n    public componentWillUnmount() {\n        this.isUnmounted = true;\n        unset(this, \"targetGesto\");\n        unset(this, \"controlGesto\");\n\n        const events = this.events;\n        for (const name in events) {\n            const manager = events[name];\n            manager && manager.destroy();\n        }\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, wrapperMoveable, container } = this.props;\n\n        return container!\n            || (wrapperMoveable && wrapperMoveable.getContainer())\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @method Moveable#isMoveableElement\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: Element) {\n        return target && ((target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1);\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @method Moveable#dragStart\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent) {\n        if (this.targetGesto) {\n            this.targetGesto.triggerDragStart(e);\n        }\n        return this;\n    }\n    /**\n     * Hit test an element or rect on a moveable target.\n     * @method Moveable#hitTest\n     * @param - element or rect to test\n     * @return - Get hit test rate (rate > 0 is hitted)\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.hitTest(e.target) > 0) {\n     *          console.log(\"hiited\");\n     *     }\n     * });\n     */\n    public hitTest(el: Element | HitRect): number {\n        const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n        if (!target) {\n            return 0;\n        }\n        let rect: Required<HitRect>;\n\n        if (el instanceof Element) {\n            const clientRect = el.getBoundingClientRect();\n\n            rect = {\n                left: clientRect.left,\n                top: clientRect.top,\n                width: clientRect.width,\n                height: clientRect.height,\n            };\n        } else {\n            rect = { width: 0, height: 0, ...el };\n        }\n\n        const {\n            left: rectLeft,\n            top: rectTop,\n            width: rectWidth,\n            height: rectHeight,\n        } = rect;\n        const points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);\n        const size = getOverlapSize(points, [\n            [rectLeft, rectTop],\n            [rectLeft + rectWidth, rectTop],\n            [rectLeft + rectWidth, rectTop + rectHeight],\n            [rectLeft, rectTop + rectHeight],\n        ]);\n        const totalSize = getAreaSize(points);\n\n        if (!size || !totalSize) {\n            return 0;\n        }\n\n        return Math.min(100, size / totalSize * 100);\n    }\n    /**\n     * Whether the coordinates are inside Moveable\n     * @method Moveable#isInside\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number) {\n        const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @method Moveable#updateRect\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const props = this.props;\n        const parentMoveable = props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        const rootContainer = parentMoveable\n            ? parentMoveable.props.rootContainer\n            : props.rootContainer;\n        this.updateState(\n            getTargetInfo(this.controlBox && this.controlBox.getElement(),\n                target, container, container,\n                rootContainer || container,\n                // isTarget ? state : undefined\n            ),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    public isTargetChanged(prevProps: MoveableManagerProps, useDragArea?: boolean) {\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const prevTarget = prevProps.dragTarget || prevProps.target;\n        const dragArea = props.dragArea;\n        const prevDragArea = prevProps.dragArea;\n        const isTargetChanged = !dragArea && prevTarget !== target;\n\n        return isTargetChanged || ((useDragArea || dragArea) && prevDragArea !== dragArea);\n    }\n    public updateNativeEvents(prevProps: MoveableManagerProps) {\n        const props = this.props;\n        const target = props.dragArea ? this.areaElement : this.state.target;\n        const events = this.events;\n        const eventKeys = getKeys(events);\n\n        if (this.isTargetChanged(prevProps)) {\n            for (const eventName in events) {\n                const manager = events[eventName];\n                manager && manager.destroy();\n                events[eventName] = null;\n            }\n        }\n        if (!target) {\n            return;\n        }\n        const enabledAbles = this.enabledAbles;\n        eventKeys.forEach(eventName => {\n            const ables = filterAbles(enabledAbles, [eventName] as any);\n            const hasAbles = ables.length > 0;\n            let manager = events[eventName];\n\n            if (!hasAbles) {\n                if (manager) {\n                    manager.destroy();\n                    events[eventName] = null;\n                }\n                return;\n            }\n            if (!manager) {\n                manager = new EventManager(target, this, eventName);\n                events[eventName] = manager;\n            }\n            manager.setAbles(ables);\n        });\n    }\n    public updateEvent(prevProps: MoveableManagerProps) {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const isTargetChanged = this.isTargetChanged(prevProps, true);\n        const isUnset = (!hasTargetAble && this.targetGesto) || isTargetChanged;\n\n        if (isUnset) {\n            unset(this, \"targetGesto\");\n            this.updateState({ gesto: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlGesto\");\n        }\n\n        if (target && hasTargetAble && !this.targetGesto) {\n            this.targetGesto = getTargetAbleGesto(this, target!, \"\");\n        }\n        if (!this.controlGesto && hasControlAble) {\n            this.controlGesto = getAbleGesto(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n        if (isUnset) {\n            this.unsetAbles();\n        }\n    }\n    /**\n     * Check if the moveable state is being dragged.\n     * @method Moveable#isDragging\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // false\n     * console.log(moveable.isDragging());\n     *\n     * moveable.on(\"drag\", () => {\n     *   // true\n     *   console.log(moveable.isDragging());\n     * });\n     */\n    public isDragging() {\n        return (this.targetGesto ? this.targetGesto.isFlag() : false)\n            || (this.controlGesto ? this.controlGesto.isFlag() : false);\n    }\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @method Moveable#updateTarget\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @method Moveable#getRect\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        const statePos = [state.left, state.top];\n        const origin = plus(statePos, state.origin);\n        const beforeOrigin = plus(statePos, state.beforeOrigin);\n        const transformOrigin = state.transformOrigin;\n\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n            beforeOrigin,\n            origin,\n            transformOrigin,\n            rotation: this.getRotation(),\n        };\n    }\n    /**\n     * Get a manager that manages the moveable's state and props.\n     * @method Moveable#getManager\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const manager = moveable.getManager(); // real moveable class instance\n     */\n    public getManager(): MoveableManagerInterface<any, any> {\n        return this as any;\n    }\n    public getRotation() {\n        const {\n            pos1,\n            pos2,\n            direction,\n        } = this.state;\n\n        return getAbsoluteRotation(pos1, pos2, direction);\n    }\n    /**\n     * Request able through a method rather than an event.\n     * At the moment of execution, requestStart is executed,\n     * and then request and requestEnd can be executed through Requester.\n     * @method Moveable#request\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n     * @param - ableName\n     * @param - request to be able params.\n     * @param - If isInstant is true, request and requestEnd are executed immediately.\n     * @return - Able Requester. If there is no request in able, nothing will work.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     *\n     * // Start move\n     * const requester = moveable.request(\"draggable\");\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.requestEnd();\n     */\n    public request(ableName: string, param: IObject<any> = {}, isInstant?: boolean): Requester {\n        const { ables, groupable } = this.props as any;\n        const requsetAble: Able = ables!.filter((able: Able) => able.name === ableName)[0];\n\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request() {\n                    return this;\n                },\n                requestEnd() {\n                    return this;\n                },\n            };\n        }\n        const self = this;\n        const ableRequester = requsetAble.request(this);\n\n        const requestInstant = isInstant || param.isInstant;\n        const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        const eventAffix = `${(groupable ? \"Group\" : \"\")}${ableRequester.isControl ? \"Control\" : \"\"}`;\n\n        const requester = {\n            request(ableParam: IObject<any>) {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"\", {\n                    ...ableRequester.request(ableParam),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n            requestEnd() {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"End\", {\n                    ...ableRequester.requestEnd(),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n        };\n\n        triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", {\n            ...ableRequester.requestStart(param),\n            requestAble: ableName,\n            isRequest: true,\n        }, requestInstant);\n\n        return requestInstant ? requester.request(param).requestEnd() : requester;\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @method Moveable#destroy\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy(): void {\n        this.componentWillUnmount();\n    }\n    public updateRenderPoses() {\n        const state = this.state;\n        const props = this.props;\n        const {\n            originalBeforeOrigin, transformOrigin,\n            allMatrix, is3d, pos1, pos2, pos3, pos4,\n            left: stateLeft, top: stateTop,\n        } = state;\n        const {\n            left = 0,\n            top = 0,\n            bottom = 0,\n            right = 0,\n        } = (props.padding || {}) as PaddingBox;\n        const n = is3d ? 4 : 3;\n        const absoluteOrigin = (props as any).groupable\n            ? originalBeforeOrigin : plus(originalBeforeOrigin, [stateLeft, stateTop]);\n\n        state.renderPoses = [\n            plus(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)),\n            plus(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n)),\n        ];\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n\n        this.updateState({ target, container });\n\n        if (!parentMoveable && (container || this.controlBox)) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    public useCSS(tag: string, css: string) {\n        const customStyleMap = this.props.customStyledMap as Record<string, any>;\n\n        const key = tag + css;\n\n        if (!customStyleMap[key]) {\n            customStyleMap[key] = styled(tag, css);\n        }\n        return customStyleMap[key];\n    }\n    public onPreventClick = (e: any) => {\n        e.stopPropagation();\n        removeEvent(window, \"click\", this.onPreventClick, true);\n    }\n    protected unsetAbles() {\n        if (this.targetAbles.filter(able => {\n            if (able.unset) {\n                able.unset(this);\n                return true;\n            }\n            return false;\n        }).length) {\n            this.forceUpdate();\n        }\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const enabledAbles = ables!.filter(able => able && (able.always || props[able.name]));\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n\n        this.enabledAbles = enabledAbles;\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            this.setState(nextState);\n        } else {\n            const state = this.state;\n\n            for (const name in nextState) {\n                (state as any)[name] = nextState[name];\n            }\n        }\n    }\n    protected getEnabledAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        return ables.filter(able => able && props[able.name]);\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const Renderer = {\n            createElement,\n        };\n\n        return groupByMap(flat<any>(\n            filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(({ render }) => {\n                return render!(this, Renderer) || [];\n            })).filter(el => el), ({ key }) => key).map(group => group[0]);\n    }\n    protected updateCheckInput() {\n        this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n    }\n}\n\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Zooms in the elements of a moveable. (default: 1)\n * @name Moveable#zoom\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox. (default: \"\")\n * @name Moveable#className\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s) (default: target)\n * @name Moveable#dragTarget\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n","import { refs } from \"framework-utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer, MoveableGroupInterface } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        defaultGroupOrigin: String,\n        groupable: Boolean,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableGroupInterface, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n\n        return targets.map((target, i) => {\n            return <MoveableManager\n                key={\"moveable\" + i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                cssStyled={moveable.props.cssStyled}\n                customStyledMap={moveable.props.customStyledMap}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        });\n    },\n};\n","import {\n    MoveableManagerInterface, MoveableGroupInterface,\n    ClickableProps, OnClick, OnClickGroup,\n} from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { addEvent, findIndex, removeEvent } from \"@daybrush/utils\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"clickable\", {\n    props: {},\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    always: true,\n    dragStart(moveable: MoveableManagerInterface, e: any) {\n        if (!e.isRequest) {\n            addEvent(window, \"click\", moveable.onPreventClick, true);\n        }\n    },\n    dragControlStart(moveable: MoveableManagerInterface, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragStart(moveable, e);\n        e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.endEvent(moveable);\n        const target = moveable.state.target!;\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            // External event duplicate target or dragAreaElement\n        ) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent<ClickableProps>(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<ClickableProps>, e: any) {\n        this.endEvent(moveable);\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            // External event duplicate target or dragAreaElement\n            || e.datas.inputTarget === inputTarget\n        ) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent<ClickableProps>(moveable, \"onClickGroup\", fillParams<OnClickGroup>(moveable, e, {\n            isDouble: e.isDouble,\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClickableProps>) {\n        this.endEvent(moveable);\n    },\n    dragGroupControlEnd(moveable: MoveableManagerInterface<ClickableProps>) {\n        this.endEvent(moveable);\n    },\n    endEvent(moveable: MoveableManagerInterface<ClickableProps>) {\n        requestAnimationFrame(() => {\n            this.unset(moveable);\n        });\n    },\n    unset(moveable: MoveableManagerInterface<ClickableProps>) {\n        removeEvent(window, \"click\", moveable.onPreventClick, true);\n    },\n});\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n","import { hasClass } from \"@daybrush/utils\";\nimport { DraggableProps, MoveableGroupInterface, MoveableManagerInterface } from \"../types\";\nimport { prefix } from \"../utils\";\nimport Draggable from \"./Draggable\";\nimport { makeAble } from \"./AbleManager\";\n\nfunction getDraggableEvent(e: any) {\n    let datas = e.originalDatas.draggable;\n    if (!datas) {\n        e.originalDatas.draggable = {};\n        datas = e.originalDatas.draggable;\n    }\n    return { ...e, datas };\n}\nexport default makeAble(\"edgeDraggable\", {\n    dragControlCondition(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        if (!moveable.props.edgeDraggable || !e.inputEvent) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n        return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        return Draggable.dragStart(moveable, getDraggableEvent(e));\n    },\n    dragControl(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n        return Draggable.drag(moveable, getDraggableEvent(e));\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<DraggableProps, any>, e: any) {\n        return Draggable.dragEnd(moveable, getDraggableEvent(e));\n    },\n    dragGroupControlCondition(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        if (!moveable.props.edgeDraggable || !e.inputEvent) {\n            return false;\n        }\n        const target = e.inputEvent.target;\n        return hasClass(target, prefix(\"direction\")) && hasClass(target, prefix(\"line\"));\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n        return Draggable.dragGroup(moveable, getDraggableEvent(e));\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<DraggableProps, any>, e: any) {\n        return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n});\n\n/**\n * Whether to move by dragging the edge line (default: false)\n * @name Moveable.Draggable#edgeDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  draggable: true,\n *  edgeDraggable: false,\n * });\n *\n * moveable.edgeDraggable = true;\n */\n","export default {\n    name: \"individualGroupable\",\n    props: {\n        individualGroupable: Boolean,\n    } as const,\n    events: {} as const,\n} as const;\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\nimport Padding from \"./Padding\";\nimport Clippable from \"./Clippable\";\nimport OriginDraggable from \"./OriginDraggable\";\nimport Roundable from \"./Roundable\";\nimport { UnionToIntersection } from \"../types\";\nimport { invertObject } from \"../utils\";\nimport Groupable from \"./Groupable\";\nimport BeforeRenderable from \"./BeforeRenderable\";\nimport Renderable from \"./Renderable\";\nimport Clickable from \"./Clickable\";\nimport edgeDraggable from \"./edgeDraggable\";\nimport IndividualGroupable from \"./IndividualGroupable\";\n\nexport const MOVEABLE_ABLES = /*#__PURE__*/[\n    BeforeRenderable,\n    Default, Snappable, Pinchable, Draggable, edgeDraggable, Rotatable,\n    Resizable, Scalable, Warpable, Scrollable, Padding, Origin,\n    OriginDraggable,\n    Clippable, Roundable, Groupable, IndividualGroupable,\n    Clickable,\n    DragArea,\n    Renderable,\n] as const;\n\nexport const MOVEABLE_EVENTS_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...(\"events\" in able ? able.events : {})};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"events\"]>;\nexport const MOVEABLE_PROPS_MAP = /*#__PURE__*/MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...able.props};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"props\"]>;\n\nexport const MOVEABLE_EVENTS_MAP = /*#__PURE__*/invertObject(MOVEABLE_EVENTS_PROPS_MAP);\nexport const MOVEABLE_EVENTS: string[] = /*#__PURE__*/Object.keys(MOVEABLE_EVENTS_MAP);\nexport const MOVEABLE_PROPS: string[] = /*#__PURE__*/Object.keys(MOVEABLE_PROPS_MAP);\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, MoveableManagerProps, RectInfo } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleGesto, getTargetAbleGesto } from \"./gesto/getAbleGesto\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getTargetInfo, getAbsolutePosesByState, equals, unset } from \"./utils\";\nimport { minus, plus, rotate } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport { throttle } from \"@daybrush/utils\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = fixedRotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1MinMax = [MIN_NUM, MAX_NUM];\n        const b2MinMax = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                // b = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1MinMax[0] = Math.max(b1MinMax[0], b1);\n                b1MinMax[1] = Math.min(b1MinMax[1], b1);\n                b2MinMax[0] = Math.max(b2MinMax[0], b2);\n                b2MinMax[1] = Math.min(b2MinMax[1], b2);\n            });\n        });\n\n        b1MinMax.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2MinMax.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\nclass MoveableGroup extends MoveableManager<GroupableProps> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n        defaultGroupOrigin: \"50% 50%\",\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public transformOrigin = \"50% 50%\";\n\n    public updateEvent(prevProps: MoveableManagerProps<GroupableProps>) {\n        const state = this.state;\n        const props = this.props;\n\n        const prevTarget = prevProps.dragTarget || state.target;\n        const nextTarget = props.dragTarget || this.areaElement;\n\n        if (prevTarget !== nextTarget) {\n            unset(this, \"targetGesto\");\n            unset(this, \"controlGesto\");\n            state.target = null;\n        }\n\n        if (!state.target) {\n            state.target = this.areaElement;\n\n            this.controlBox.getElement().style.display = \"block\";\n            this.targetGesto = getTargetAbleGesto(this, nextTarget, \"Group\");\n            this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n        }\n        const isContainerChanged = !equals(prevProps.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n            this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n            this.scale = [1, 1];\n\n        }\n        const rotation = this.rotation;\n        const scale = this.scale;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        const transform = `rotate(${rotation}deg) scale(${scale[0] >= 0 ? 1 : -1}, ${scale[1] >= 0 ? 1 : -1})`;\n        target.style.cssText += `left:0px;top:0px; transform-origin: ${this.transformOrigin}; width:${width}px; height:${height}px;`\n            + `transform:${transform}`;\n        state.width = width;\n        state.height = height;\n\n        const container = this.getContainer();\n        const info = getTargetInfo(\n            this.controlBox.getElement(),\n            target,\n            this.controlBox.getElement(),\n            this.getContainer(),\n            this.props.rootContainer || container,\n            // state,\n        );\n        const pos = [info.left!, info.top!];\n        const [\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        ] = getAbsolutePosesByState(info); // info.left + info.pos(1 ~ 4)\n\n        const minPos = getMinMaxs([pos1, pos2, pos3, pos4]);\n        const delta = [minPos.minX, minPos.minY];\n        info.pos1 = minus(pos1, delta);\n        info.pos2 = minus(pos2, delta);\n        info.pos3 = minus(pos3, delta);\n        info.pos4 = minus(pos4, delta);\n        info.left = left - info.left! + delta[0];\n        info.top = top - info.top! + delta[1];\n        info.origin = minus(plus(pos, info.origin!), delta);\n        info.beforeOrigin = minus(plus(pos, info.beforeOrigin!), delta);\n        info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin!);\n        // info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);\n\n        const clientRect = info.targetClientRect!;\n        const direction = scale[0] * scale[1] > 0 ? 1 : -1;\n\n        clientRect.top += info.top - state.top;\n        clientRect.left += info.left - state.left;\n\n        target.style.transform = `translate(${-delta[0]}px, ${-delta[1]}px) ${transform}`;\n\n        this.updateState(\n            {\n                ...info,\n                direction,\n                beforeDirection: direction,\n            },\n            isSetState,\n        );\n    }\n    public getRect(): RectInfo {\n        return {\n            ...super.getRect(),\n            children: this.moveables.map(child => child.getRect()),\n        };\n    }\n    public triggerEvent(name: string, e: any, isManager?: boolean): any {\n        if (isManager || name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n}\n\n/**\n * Sets the initial rotation of the group. (default 0)\n * @name Moveable.Group#defaultGroupRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Sets the initial origin of the group. (default 0)\n * @name Moveable.Group#defaultGroupOrigin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupOrigin: \"50% 50%\",\n * });\n *\n * moveable.defaultGroupOrigin = \"20% 40%\";\n */\nexport default MoveableGroup;\n","import { ref, refs } from \"framework-utils\";\nimport * as React from \"react\";\nimport MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, RectInfo } from \"./types\";\nimport { prefix } from \"./utils\";\n\n/**\n * @namespace Moveable.IndividualGroup\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\n */\nclass MoveableIndividualGroup extends MoveableManager<GroupableProps> {\n    public moveables: MoveableManager[] = [];\n    public render() {\n        const {\n            cspNonce,\n            cssStyled: ControlBoxElement,\n            targets,\n        } = this.props;\n\n        return <ControlBoxElement\n            cspNonce={cspNonce}\n            ref={ref(this, \"controlBox\")}\n            className={prefix(\"control-box\")}>\n            {targets!.map((target, i) => {\n                return <MoveableManager\n                    key={\"moveable\" + i}\n                    ref={refs(this, \"moveables\", i)}\n                    {...this.props}\n                    target={target}\n                    wrapperMoveable={this}\n                />;\n            })}\n        </ControlBoxElement>;\n    }\n    public componentDidUpdate() {}\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, isTarget, isSetState);\n        });\n    }\n    public getRect(): RectInfo {\n        return {\n            ...super.getRect(),\n            children: this.moveables.map(child => child.getRect()),\n        };\n    }\n    public request() {\n        return {\n            request() {\n                return this;\n            },\n            requestEnd() {\n                return this;\n            },\n        };\n    }\n    public dragStart() {\n        return this;\n    }\n    public hitTest() {\n        return 0;\n    }\n    public isInside() {\n        return false;\n    }\n    public isDragging() {\n        return false;\n    }\n    public updateRenderPoses() { }\n    public updateEvent() { }\n    public checkUpdate() { }\n    public triggerEvent() { }\n    protected updateAbles() { }\n}\n\n/**\n * Create targets individually, not as a group.\n * @name Moveable.IndividualGroup#individualGroupable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   individualGroupable: true,\n * });\n */\nexport default MoveableIndividualGroup;\n","import * as React from \"react\";\nimport {\n    Able, MoveableInterface, GroupableProps, MoveableDefaultProps,\n    IndividualGroupableProps, MoveableManagerInterface,\n} from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref, withMethods, prefixCSS } from \"framework-utils\";\nimport { getKeys, IObject, isString } from \"@daybrush/utils\";\nimport { MOVEABLE_METHODS, PREFIX, MOVEABLE_CSS } from \"./consts\";\nimport Default from \"./ables/Default\";\nimport Groupable from \"./ables/Groupable\";\nimport DragArea from \"./ables/DragArea\";\nimport styled from \"react-css-styled\";\nimport { getRefTargets, getElementTargets } from \"./utils\";\nimport IndividualGroupable from \"./ables/IndividualGroupable\";\nimport MoveableIndividualGroup from \"./MoveableIndividualGroup\";\n\n\nexport class InitialMoveable<T = {}>\n    extends React.PureComponent<MoveableDefaultProps & GroupableProps & IndividualGroupableProps & T> {\n    public static defaultAbles: Able[] = [];\n    public static customStyledMap: Record<string, any> = {};\n    public static defaultStyled: any = null;\n    public static makeStyled() {\n        const cssMap: IObject<boolean> = {};\n\n        const ables = this.getTotalAbles();\n        ables.forEach(({ css }: Able) => {\n            if (!css) {\n                return;\n            }\n            css.forEach(text => {\n                cssMap[text] = true;\n            });\n        });\n        const style = getKeys(cssMap).join(\"\\n\");\n\n        this.defaultStyled = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + style));\n    }\n    public static getTotalAbles(): Able[] {\n\n        return [Default, Groupable, IndividualGroupable, DragArea, ...this.defaultAbles];\n    }\n    @withMethods(MOVEABLE_METHODS)\n    public moveable!: MoveableManager | MoveableGroup | MoveableIndividualGroup;\n    public refTargets: Array<HTMLElement | SVGElement | string | undefined | null> = [];\n    public selectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n    public render() {\n        const moveableContructor = (this.constructor as typeof InitialMoveable);\n\n        if (!moveableContructor.defaultStyled) {\n            moveableContructor.makeStyled();\n        }\n        const {\n            ables: userAbles,\n            props: userProps,\n            ...props\n        } = this.props;\n        const refTargets = getRefTargets((props.target || props.targets) as any);\n        const elementTargets = getElementTargets(refTargets, this.selectorMap);\n\n        this.refTargets = refTargets;\n\n        const isGroup = elementTargets.length > 1;\n        const totalAbles = moveableContructor.getTotalAbles();\n        const ables = [\n            ...totalAbles,\n            ...(userAbles as any || []),\n        ];\n        const nextProps = {\n            ...props,\n            ...(userProps || {}),\n            ables,\n            cssStyled: moveableContructor.defaultStyled,\n            customStyledMap: moveableContructor.customStyledMap,\n        };\n\n        if (isGroup) {\n            if (props.individualGroupable) {\n                return <MoveableIndividualGroup key=\"individual-group\" ref={ref(this, \"moveable\")}\n                    {...nextProps}\n                    target={null}\n                    targets={elementTargets} />;\n            }\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps}\n                target={null}\n                targets={elementTargets}  />;\n        } else {\n            return <MoveableManager<any> key=\"single\" ref={ref(this, \"moveable\")}\n                {...nextProps}\n                target={elementTargets[0]} />;\n        }\n    }\n    public componentDidMount() {\n        this.updateRefs();\n    }\n    public componentDidUpdate() {\n        this.updateRefs();\n    }\n    public updateRefs(isReset?: boolean) {\n        const refTargets = getRefTargets((this.props.target || this.props.targets) as any);\n        let isUpdate = this.refTargets.some((target, i) => {\n            const nextTarget = refTargets[i];\n\n            if (!target && !nextTarget) {\n                return false;\n            } else if (target !== nextTarget) {\n                return true;\n            }\n            return false;\n        });\n        const selectorMap = isReset ? {} : this.selectorMap;\n        const nextSelectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n        this.refTargets.forEach(target => {\n            if (isString(target)) {\n                if (!selectorMap[target]) {\n                    isUpdate = true;\n                    nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));\n                } else {\n                    nextSelectorMap[target] = selectorMap[target];\n                }\n            }\n        });\n\n        this.selectorMap = nextSelectorMap;\n\n        if (isUpdate) {\n            this.forceUpdate();\n        }\n    }\n    public getManager(): MoveableManagerInterface<any, any> {\n        return this.moveable;\n    }\n}\nexport interface InitialMoveable<T = {}>\n    extends React.PureComponent<MoveableDefaultProps & GroupableProps & IndividualGroupableProps & T>,\n    MoveableInterface {\n    setState(state: any, callback?: () => any): any;\n}\n","import { MoveableProps, Able } from \"./types\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport default class Moveable<T = {}> extends InitialMoveable<MoveableProps & T> {\n    public static defaultAbles: Able[] = MOVEABLE_ABLES as any;\n}\n","import { Able } from \"./types\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport function makeMoveable<T = {}>(\n    ables: Array<Able<T>>): typeof InitialMoveable & (new (...args: any[]) => InitialMoveable<T>) {\n    return class Moveable extends InitialMoveable<T> {\n        public static defaultAbles = ables;\n    };\n}\n"]},"metadata":{},"sourceType":"module"}