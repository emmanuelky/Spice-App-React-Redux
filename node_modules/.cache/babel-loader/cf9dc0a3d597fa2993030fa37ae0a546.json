{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: css-to-mat\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/css-to-mat.git\nversion: 1.0.3\n*/\nimport { splitBracket, splitComma, splitUnit, isArray, splitSpace } from '@daybrush/utils';\nimport { calculate, matrix3d, invert, translate3d, scale3d, rotateZ3d, rotateX3d, rotateY3d } from '@scena/matrix';\n\nfunction createMatrix() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\nfunction parseMat(transform) {\n  return toMat(parse(transform));\n}\n\nfunction getElementMatrix(el) {\n  return parseMat(getComputedStyle(el).transform);\n}\n\nfunction calculateMatrixDist(matrix, pos) {\n  var res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);\n  var w = res[3] || 1;\n  return [res[0] / w, res[1] / w, res[2] / w];\n}\n\nfunction getDistElementMatrix(el, container) {\n  if (container === void 0) {\n    container = document.body;\n  }\n\n  var target = el;\n  var matrix = createMatrix();\n\n  while (target) {\n    var transform = getComputedStyle(target).transform;\n    matrix = matrix3d(parseMat(transform), matrix);\n\n    if (target === container) {\n      break;\n    }\n\n    target = target.parentElement;\n  }\n\n  matrix = invert(matrix, 4);\n  matrix[12] = 0;\n  matrix[13] = 0;\n  matrix[14] = 0;\n  return matrix;\n}\n\nfunction toMat(matrixInfos) {\n  var target = createMatrix();\n  matrixInfos.forEach(function (info) {\n    var matrixFunction = info.matrixFunction,\n        functionValue = info.functionValue;\n\n    if (!matrixFunction) {\n      return;\n    }\n\n    target = matrixFunction(target, functionValue);\n  });\n  return target;\n}\n\nfunction parse(transform) {\n  var transforms = isArray(transform) ? transform : splitSpace(transform);\n  return transforms.map(function (t) {\n    var _a = splitBracket(t),\n        name = _a.prefix,\n        value = _a.value;\n\n    var matrixFunction = null;\n    var functionName = name;\n    var functionValue = \"\";\n\n    if (name === \"translate\" || name === \"translateX\" || name === \"translate3d\") {\n      var _b = splitComma(value).map(function (v) {\n        return parseFloat(v);\n      }),\n          posX = _b[0],\n          _c = _b[1],\n          posY = _c === void 0 ? 0 : _c,\n          _d = _b[2],\n          posZ = _d === void 0 ? 0 : _d;\n\n      matrixFunction = translate3d;\n      functionValue = [posX, posY, posZ];\n    } else if (name === \"translateY\") {\n      var posY = parseFloat(value);\n      matrixFunction = translate3d;\n      functionValue = [0, posY, 0];\n    } else if (name === \"translateZ\") {\n      var posZ = parseFloat(value);\n      matrixFunction = translate3d;\n      functionValue = [0, 0, posZ];\n    } else if (name === \"scale\" || name === \"scale3d\") {\n      var _e = splitComma(value).map(function (v) {\n        return parseFloat(v);\n      }),\n          sx = _e[0],\n          _f = _e[1],\n          sy = _f === void 0 ? sx : _f,\n          _g = _e[2],\n          sz = _g === void 0 ? 1 : _g;\n\n      matrixFunction = scale3d;\n      functionValue = [sx, sy, sz];\n    } else if (name === \"scaleX\") {\n      var sx = parseFloat(value);\n      matrixFunction = scale3d;\n      functionValue = [sx, 1, 1];\n    } else if (name === \"scaleY\") {\n      var sy = parseFloat(value);\n      matrixFunction = scale3d;\n      functionValue = [1, sy, 1];\n    } else if (name === \"scaleZ\") {\n      var sz = parseFloat(value);\n      matrixFunction = scale3d;\n      functionValue = [1, 1, sz];\n    } else if (name === \"rotate\" || name === \"rotateZ\" || name === \"rotateX\" || name === \"rotateY\") {\n      var _h = splitUnit(value),\n          unit = _h.unit,\n          unitValue = _h.value;\n\n      var rad = unit === \"rad\" ? unitValue : unitValue * Math.PI / 180;\n\n      if (name === \"rotate\" || name === \"rotateZ\") {\n        functionName = \"rotateZ\";\n        matrixFunction = rotateZ3d;\n      } else if (name === \"rotateX\") {\n        matrixFunction = rotateX3d;\n      } else if (name === \"rotateY\") {\n        matrixFunction = rotateY3d;\n      }\n\n      functionValue = rad;\n    } else if (name === \"matrix3d\") {\n      matrixFunction = matrix3d;\n      functionValue = splitComma(value).map(function (v) {\n        return parseFloat(v);\n      });\n    } else if (name === \"matrix\") {\n      var m = splitComma(value).map(function (v) {\n        return parseFloat(v);\n      });\n      matrixFunction = matrix3d;\n      functionValue = [m[0], m[1], 0, 0, m[2], m[3], 0, 0, 0, 0, 1, 0, m[4], m[5], 0, 1];\n    } else {\n      functionName = \"\";\n    }\n\n    return {\n      name: name,\n      functionName: functionName,\n      value: value,\n      matrixFunction: matrixFunction,\n      functionValue: functionValue\n    };\n  });\n}\n\nexport { calculateMatrixDist, createMatrix, getDistElementMatrix, getElementMatrix, parse, parseMat, toMat };","map":{"version":3,"sources":["../src/CssToMatrix.ts"],"names":["createMatrix","parseMat","transform","toMat","parse","getElementMatrix","el","getComputedStyle","calculateMatrixDist","matrix","pos","res","calculate","w","getDistElementMatrix","container","document","target","matrix3d","invert","matrixInfos","matrixFunction","functionValue","transforms","isArray","splitSpace","_a","name","value","functionName","posX","_c","_d","posY","parseFloat","posZ","sx","_f","_g","sy","sz","_h","unit","unitValue","rad","Math","m"],"mappings":"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","sourcesContent":["import { splitComma, splitBracket, splitUnit, splitSpace, isArray } from \"@daybrush/utils\";\nimport { MatrixInfo } from \"./types\";\nimport { calculate, invert, matrix3d, rotateX3d, rotateY3d, rotateZ3d, scale3d, translate3d } from \"@scena/matrix\";\n\nexport function createMatrix() {\n    return [\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1,\n    ];\n}\nexport function parseMat(transform: string | string[]): number[] {\n    return toMat(parse(transform));\n}\nexport function getElementMatrix(el: HTMLElement) {\n    return parseMat(getComputedStyle(el).transform!);\n}\nexport function calculateMatrixDist(matrix: number[], pos: number[]) {\n    const res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);\n    const w = res[3] || 1;\n\n    return [\n        res[0] / w,\n        res[1] / w,\n        res[2] / w,\n    ];\n}\nexport function getDistElementMatrix(el: HTMLElement, container = document.body): number[] {\n    let target: HTMLElement | null = el;\n    let matrix = createMatrix();\n\n    while (target) {\n        const transform = getComputedStyle(target).transform!;\n        matrix = matrix3d(parseMat(transform), matrix);\n\n        if (target === container) {\n            break;\n        }\n        target = target.parentElement;\n    }\n    matrix = invert(matrix, 4);\n\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n\n    return matrix;\n}\n\nexport function toMat(matrixInfos: MatrixInfo[]): number[] {\n    let target = createMatrix();\n\n    matrixInfos.forEach(info => {\n        const {\n            matrixFunction,\n            functionValue,\n        } = info;\n\n        if (!matrixFunction) {\n            return;\n        }\n        target = matrixFunction(target, functionValue);\n    });\n    return target;\n}\nexport function parse(transform: string | string[]): MatrixInfo[] {\n    const transforms = isArray(transform) ? transform : splitSpace(transform);\n\n    return transforms.map(t => {\n        const { prefix: name, value } = splitBracket(t);\n\n\n        let matrixFunction = null;\n        let functionName: string = name;\n        let functionValue: any = \"\";\n\n        if (name === \"translate\" || name === \"translateX\" || name === \"translate3d\") {\n            const [posX, posY = 0, posZ = 0] = splitComma(value!).map(v => parseFloat(v));\n\n            matrixFunction = translate3d;\n            functionValue = [posX, posY, posZ];\n        } else if (name === \"translateY\") {\n            const posY = parseFloat(value!);\n\n            matrixFunction = translate3d;\n            functionValue = [0, posY, 0];\n        } else if (name === \"translateZ\") {\n            const posZ = parseFloat(value!);\n\n            matrixFunction = translate3d;\n            functionValue = [0, 0, posZ];\n        } else if (name === \"scale\" || name === \"scale3d\") {\n            const [sx, sy = sx, sz = 1] = splitComma(value!).map(v => parseFloat(v)) as number[];\n\n            matrixFunction = scale3d;\n            functionValue = [sx, sy, sz];\n        } else if (name === \"scaleX\") {\n            const sx = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [sx, 1, 1];\n        } else if (name === \"scaleY\") {\n            const sy = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [1, sy, 1];\n        } else if (name === \"scaleZ\") {\n            const sz = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [1, 1, sz];\n        } else if (name === \"rotate\" || name === \"rotateZ\" || name === \"rotateX\" || name === \"rotateY\") {\n            const { unit, value: unitValue } = splitUnit(value!);\n            const rad = unit === \"rad\" ? unitValue : unitValue * Math.PI / 180;\n\n            if (name === \"rotate\" || name === \"rotateZ\") {\n                functionName = \"rotateZ\";\n                matrixFunction = rotateZ3d;\n            } else if (name === \"rotateX\") {\n                matrixFunction = rotateX3d;\n            } else if (name === \"rotateY\") {\n                matrixFunction = rotateY3d;\n            }\n            functionValue = rad;\n        } else if (name === \"matrix3d\") {\n            matrixFunction = matrix3d;\n            functionValue = splitComma(value!).map(v => parseFloat(v));\n        } else if (name === \"matrix\") {\n            const m = splitComma(value!).map(v => parseFloat(v));\n            matrixFunction = matrix3d;\n            functionValue = [\n                m[0], m[1], 0, 0,\n                m[2], m[3], 0, 0,\n                0, 0, 1, 0,\n                m[4], m[5], 0, 1,\n            ];\n        } else {\n            functionName = \"\";\n        }\n        return {\n            name: name!,\n            functionName,\n            value: value!,\n            matrixFunction,\n            functionValue,\n        };\n    });\n}\n"]},"metadata":{},"sourceType":"module"}