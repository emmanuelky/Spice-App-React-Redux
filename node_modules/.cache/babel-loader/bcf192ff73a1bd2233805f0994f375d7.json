{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: @scena/dragscroll\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/dragscroll.git\nversion: 1.0.2\n*/\nimport EventEmitter from '@scena/event-emitter';\nimport { now } from '@daybrush/utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction getDefaultScrollPosition(e) {\n  var container = e.container;\n\n  if (container === document.body) {\n    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];\n  }\n\n  return [container.scrollLeft, container.scrollTop];\n}\n\nvar DragScroll = /*#__PURE__*/function (_super) {\n  __extends(DragScroll, _super);\n\n  function DragScroll() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.startRect = null;\n    _this.startPos = [];\n    _this.prevTime = 0;\n    _this.timer = 0;\n    return _this;\n  }\n\n  var __proto = DragScroll.prototype;\n\n  __proto.dragStart = function (e, options) {\n    var container = options.container;\n    var top = 0;\n    var left = 0;\n    var width = 0;\n    var height = 0;\n\n    if (container === document.body) {\n      width = window.innerWidth;\n      height = window.innerHeight;\n    } else {\n      var rect = container.getBoundingClientRect();\n      top = rect.top;\n      left = rect.left;\n      width = rect.width;\n      height = rect.height;\n    }\n\n    this.startPos = [e.clientX, e.clientY];\n    this.startRect = {\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n  };\n\n  __proto.drag = function (e, options) {\n    var _this = this;\n\n    var clientX = e.clientX,\n        clientY = e.clientY;\n    var container = options.container,\n        _a = options.threshold,\n        threshold = _a === void 0 ? 0 : _a,\n        _b = options.throttleTime,\n        throttleTime = _b === void 0 ? 0 : _b,\n        _c = options.getScrollPosition,\n        getScrollPosition = _c === void 0 ? getDefaultScrollPosition : _c;\n\n    var _d = this,\n        startRect = _d.startRect,\n        startPos = _d.startPos;\n\n    var nowTime = now();\n    var distTime = Math.max(throttleTime + this.prevTime - nowTime, 0);\n    var direction = [0, 0];\n\n    if (startRect.top > clientY - threshold) {\n      if (startPos[1] > startRect.top || clientY < startPos[1]) {\n        direction[1] = -1;\n      }\n    } else if (startRect.top + startRect.height < clientY + threshold) {\n      if (startPos[1] < startRect.top + startRect.height || clientY > startPos[1]) {\n        direction[1] = 1;\n      }\n    }\n\n    if (startRect.left > clientX - threshold) {\n      if (startPos[0] > startRect.left || clientX < startPos[0]) {\n        direction[0] = -1;\n      }\n    } else if (startRect.left + startRect.width < clientX + threshold) {\n      if (startPos[0] < startRect.left + startRect.width || clientX > startPos[0]) {\n        direction[0] = 1;\n      }\n    }\n\n    clearTimeout(this.timer);\n\n    if (!direction[0] && !direction[1]) {\n      return false;\n    }\n\n    if (distTime > 0) {\n      this.timer = window.setTimeout(function () {\n        _this.drag(e, options);\n      }, distTime);\n      return false;\n    }\n\n    this.prevTime = nowTime;\n    var prevPos = getScrollPosition({\n      container: container,\n      direction: direction\n    });\n    this.trigger(\"scroll\", {\n      container: container,\n      direction: direction,\n      inputEvent: e\n    });\n    var nextPos = getScrollPosition({\n      container: container,\n      direction: direction\n    });\n    var offsetX = nextPos[0] - prevPos[0];\n    var offsetY = nextPos[1] - prevPos[1];\n\n    if (!offsetX && !offsetY) {\n      return false;\n    }\n\n    this.trigger(\"move\", {\n      offsetX: direction[0] ? offsetX : 0,\n      offsetY: direction[1] ? offsetY : 0,\n      inputEvent: e\n    });\n\n    if (throttleTime) {\n      this.timer = window.setTimeout(function () {\n        _this.drag(e, options);\n      }, throttleTime);\n    }\n\n    return true;\n  };\n\n  __proto.dragEnd = function () {\n    clearTimeout(this.timer);\n  };\n\n  return DragScroll;\n}(EventEmitter);\n\nexport default DragScroll;","map":{"version":3,"sources":["../src/DragScroll.ts"],"names":["container","e","document","__extends","_this","options","top","left","width","height","window","rect","clientX","clientY","_a","_b","_c","_d","startRect","startPos","nowTime","now","distTime","Math","throttleTime","direction","clearTimeout","prevPos","getScrollPosition","inputEvent","nextPos","offsetX","offsetY"],"mappings":"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","sourcesContent":["import EventEmitter from \"@scena/event-emitter\";\nimport { now } from \"@daybrush/utils\";\nimport { DragScrollEvents, DragScrollOptions, Rect } from \"./types\";\n\nfunction getDefaultScrollPosition(e: { container: HTMLElement, direction: number[] }) {\n    let container = e.container;\n\n    if (container === document.body) {\n        return [\n            container.scrollLeft || document.documentElement.scrollLeft,\n            container.scrollTop || document.documentElement.scrollTop,\n        ];\n    }\n    return [\n        container.scrollLeft,\n        container.scrollTop,\n    ];\n}\n\nexport default class DragScroll extends EventEmitter<DragScrollEvents> {\n    private startRect: Rect | null = null;\n    private startPos: number[] = [];\n    private prevTime: number = 0;\n    private timer: number = 0;\n    public dragStart(e: any, options: DragScrollOptions) {\n        const container = options.container;\n        let top = 0;\n        let left = 0;\n        let width = 0;\n        let height = 0;\n\n        if (container === document.body) {\n            width = window.innerWidth;\n            height = window.innerHeight;\n        } else {\n            const rect = container.getBoundingClientRect();\n\n            top = rect.top;\n            left = rect.left;\n            width = rect.width;\n            height = rect.height;\n        }\n\n        this.startPos = [e.clientX, e.clientY];\n        this.startRect = { top, left, width, height };\n    }\n    public drag(e: any, options: DragScrollOptions) {\n        const {\n            clientX,\n            clientY,\n        } = e;\n        const {\n            container,\n            threshold = 0,\n            throttleTime = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = options;\n        const {\n            startRect,\n            startPos,\n        } = this;\n        const nowTime = now();\n        const distTime = Math.max(throttleTime + this.prevTime - nowTime, 0);\n\n        const direction = [0, 0];\n\n        if (startRect.top > clientY - threshold) {\n            if (startPos[1] > startRect.top || clientY < startPos[1]) {\n                direction[1] = -1;\n            }\n        } else if (startRect.top + startRect.height < clientY + threshold) {\n            if (startPos[1] < startRect.top + startRect.height || clientY > startPos[1]) {\n                direction[1] = 1;\n            }\n        }\n        if (startRect.left > clientX - threshold) {\n            if (startPos[0] > startRect.left || clientX < startPos[0]) {\n                direction[0] = -1;\n            }\n        } else if (startRect.left + startRect.width < clientX + threshold) {\n            if (startPos[0] < startRect.left + startRect.width || clientX > startPos[0]) {\n                direction[0] = 1;\n            }\n        }\n        clearTimeout(this.timer);\n\n        if (!direction[0] && !direction[1]) {\n            return false;\n        }\n        if (distTime > 0) {\n            this.timer = window.setTimeout(() => {\n                this.drag(e, options);\n            }, distTime);\n\n            return false;\n        }\n        this.prevTime = nowTime;\n        const prevPos = getScrollPosition({ container, direction });\n\n        this.trigger(\"scroll\", {\n            container,\n            direction,\n            inputEvent: e,\n        });\n\n        const nextPos = getScrollPosition({ container, direction });\n        const offsetX = nextPos[0] - prevPos[0];\n        const offsetY = nextPos[1] - prevPos[1];\n\n        if (!offsetX && !offsetY) {\n            return false;\n        }\n        this.trigger(\"move\", {\n            offsetX: direction[0] ? offsetX : 0,\n            offsetY: direction[1] ? offsetY : 0,\n            inputEvent: e,\n        });\n\n        if (throttleTime) {\n            this.timer = window.setTimeout(() => {\n                this.drag(e, options);\n            }, throttleTime);\n        }\n        return true;\n    }\n    public dragEnd() {\n        clearTimeout(this.timer);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}