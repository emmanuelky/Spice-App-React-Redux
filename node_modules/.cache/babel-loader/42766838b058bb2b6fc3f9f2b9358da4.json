{"ast":null,"code":"/*\nCopyright (c) 2020 Daybrush\nname: overlap-area\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/overlap-area.git\nversion: 1.0.0\n*/\nimport { sum, findIndex, getShapeDirection, getDist } from '@daybrush/utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n}\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\n\n\nfunction getAreaSize(points) {\n  if (points.length < 3) {\n    return 0;\n  }\n\n  return Math.abs(sum(points.map(function (point, i) {\n    var nextPoint = points[i + 1] || points[0];\n    return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n  }))) / 2;\n}\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\n\n\nfunction fitPoints(points, rect) {\n  var width = rect.width,\n      height = rect.height,\n      left = rect.left,\n      top = rect.top;\n\n  var _a = getMinMaxs(points),\n      minX = _a.minX,\n      minY = _a.minY,\n      maxX = _a.maxX,\n      maxY = _a.maxY;\n\n  var ratioX = width / (maxX - minX);\n  var ratioY = height / (maxY - minY);\n  return points.map(function (point) {\n    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];\n  });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\n\n\nfunction getMinMaxs(points) {\n  var xs = points.map(function (point) {\n    return point[0];\n  });\n  var ys = points.map(function (point) {\n    return point[1];\n  });\n  return {\n    minX: Math.min.apply(Math, xs),\n    minY: Math.min.apply(Math, ys),\n    maxX: Math.max.apply(Math, xs),\n    maxY: Math.max.apply(Math, ys)\n  };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\n\n\nfunction isInside(pos, points, excludeLine) {\n  var x = pos[0],\n      y = pos[1];\n\n  var _a = getMinMaxs(points),\n      minX = _a.minX,\n      minY = _a.minY,\n      maxX = _a.maxX,\n      maxY = _a.maxY;\n\n  var xLine = [[minX, y], [maxX, y]];\n  var yLine = [[x, minY], [x, maxY]];\n  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n  var yLinearConstants = getLinearConstants(yLine[0], yLine[1]);\n  var lines = convertLines(points);\n  var intersectionXPoints = [];\n  var intersectionYPoints = [];\n  lines.forEach(function (line) {\n    var linearConstants = getLinearConstants(line[0], line[1]);\n    var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n    var yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);\n\n    if (xPoints.length === 1 ? line[0][1] !== y : true) {\n      intersectionXPoints.push.apply(intersectionXPoints, xPoints);\n    }\n\n    if (yPoints.length === 1 ? line[0][0] !== x : true) {\n      intersectionYPoints.push.apply(intersectionYPoints, yPoints);\n    }\n\n    if (!linearConstants[0]) {\n      intersectionXPoints.push.apply(intersectionXPoints, xPoints);\n    }\n\n    if (!linearConstants[1]) {\n      intersectionYPoints.push.apply(intersectionYPoints, yPoints);\n    }\n  });\n\n  if (!excludeLine) {\n    if (findIndex(intersectionXPoints, function (p) {\n      return p[0] === x;\n    }) > -1 || findIndex(intersectionYPoints, function (p) {\n      return p[1] === y;\n    }) > -1) {\n      return true;\n    }\n  }\n\n  if (intersectionXPoints.filter(function (p) {\n    return p[0] > x;\n  }).length % 2 && intersectionYPoints.filter(function (p) {\n    return p[1] > y;\n  }).length % 2) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\n\n\nfunction getLinearConstants(point1, point2) {\n  var x1 = point1[0],\n      y1 = point1[1];\n  var x2 = point2[0],\n      y2 = point2[1]; // ax + by + c = 0\n\n  if (x1 === x2 && y1 === y2) {\n    return [0, 0, 0];\n  }\n\n  if (x1 === x2) {\n    // x = x1\n    return [1, 0, -x1];\n  } else if (y1 === y2) {\n    // y = y1\n    return [0, 1, -y1];\n  } else {\n    // x1 + a * y1 + b = 0\n    // x2 + a * y2 + b = 0\n    // (x1 -x2) + (y1 - y2) * a = 0\n    // a = (x2 - x1) / (y1 - y2)\n    // x1 + (x2 - x1) / (y1 - y2)\n    var a_1 = (x2 - x1) / (y1 - y2);\n    var b_1 = -x1 - a_1 * y1;\n    return [1, a_1, b_1];\n  }\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\n\n\nfunction getIntersectionPointsByConstants(linearConstants1, linearConstants2) {\n  var a1 = linearConstants1[0],\n      b1 = linearConstants1[1],\n      c1 = linearConstants1[2];\n  var a2 = linearConstants2[0],\n      b2 = linearConstants2[1],\n      c2 = linearConstants2[2];\n  var isZeroA = a1 === 0 && a2 === 0;\n  var isZeroB = b1 === 0 && b2 === 0;\n\n  if (isZeroA && isZeroB) {\n    return [];\n  } else if (isZeroA) {\n    // b1 * y + c1 = 0\n    // b2 * y + c2 = 0\n    var y1 = -c1 / b1;\n    var y2 = -c2 / b2;\n\n    if (y1 !== y2) {\n      return [];\n    } else {\n      return [[-Infinity, y1], [Infinity, y1]];\n    }\n  } else if (isZeroB) {\n    // a1 * x + c1 = 0\n    // a2 * x + c2 = 0\n    var x1 = -c1 / a1;\n    var x2 = -c2 / a2;\n\n    if (x1 !== x2) {\n      return [];\n    } else {\n      return [[x1, -Infinity], [x1, Infinity]];\n    }\n  } else if (a1 === 0) {\n    // b1 * y + c1 = 0\n    // y = - c1 / b1;\n    // a2 * x + b2 * y + c2 = 0\n    var y = -c1 / b1;\n    var x = -(b2 * y + c2) / a2;\n    return [[x, y]];\n  } else if (a2 === 0) {\n    // b2 * y + c2 = 0\n    // y = - c2 / b2;\n    // a1 * x + b1 * y + c1 = 0\n    var y = -c2 / b2;\n    var x = -(b1 * y + c1) / a1;\n    return [[x, y]];\n  } else if (b1 === 0) {\n    // a1 * x + c1 = 0\n    // x = - c1 / a1;\n    // a2 * x + b2 * y + c2 = 0\n    var x = -c1 / a1;\n    var y = -(a2 * x + c2) / b2;\n    return [[x, y]];\n  } else if (b2 === 0) {\n    // a2 * x + c2 = 0\n    // x = - c2 / a2;\n    // a1 * x + b1 * y + c1 = 0\n    var x = -c2 / a2;\n    var y = -(a1 * x + c1) / b1;\n    return [[x, y]];\n  } else {\n    // a1 * x + b1 * y + c1 = 0\n    // a2 * x + b2 * y + c2 = 0\n    // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n    // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n    // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n    var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n    var y = -(a1 * x + c1) / b1;\n    return [[x, y]];\n  }\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\n\n\nfunction getIntersectionPoints(line1, line2, isLimit) {\n  var points = getIntersectionPointsByConstants(getLinearConstants(line1[0], line1[1]), getLinearConstants(line2[0], line2[1]));\n\n  if (isLimit) {\n    return getPointsOnLines(points, [line1, line2]);\n  }\n\n  return points;\n}\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\n\n\nfunction getPointsOnLines(points, lines) {\n  var minMaxs = lines.map(function (line) {\n    return [0, 1].map(function (order) {\n      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];\n    });\n  });\n\n  if (points.length === 2) {\n    var _a = points[0],\n        x = _a[0],\n        y = _a[1];\n\n    if (x === points[1][0]) {\n      /// Math.max(minY1, minY2)\n      var top = Math.max.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[1][0];\n      })); /// Math.min(maxY1, miax2)\n\n      var bottom = Math.min.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[1][1];\n      }));\n\n      if (top > bottom) {\n        return [];\n      }\n\n      return [[x, top], [x, bottom]];\n    } else if (y === points[1][1]) {\n      /// Math.max(minY1, minY2)\n      var left = Math.max.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[0][0];\n      })); /// Math.min(maxY1, miax2)\n\n      var right = Math.min.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[0][1];\n      }));\n\n      if (left > right) {\n        return [];\n      }\n\n      return [[left, y], [right, y]];\n    }\n  }\n\n  return points.filter(function (point) {\n    return minMaxs.every(function (minMax) {\n      return minMax[0][0] <= point[0] && point[0] <= minMax[0][1] && minMax[1][0] <= point[1] && point[1] <= minMax[1][1];\n    });\n  });\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\n\n\nfunction convertLines(points) {\n  return __spreadArrays(points.slice(1), [points[0]]).map(function (point, i) {\n    return [points[i], point];\n  });\n}\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\n\n\nfunction getOverlapPoints(points1, points2) {\n  var targetPoints1 = points1.slice();\n  var targetPoints2 = points2.slice();\n\n  if (getShapeDirection(targetPoints1) === -1) {\n    targetPoints1.reverse();\n  }\n\n  if (getShapeDirection(targetPoints2) === -1) {\n    targetPoints2.reverse();\n  }\n\n  var lines1 = convertLines(targetPoints1);\n  var lines2 = convertLines(targetPoints2);\n  var linearConstantss1 = lines1.map(function (line1) {\n    return getLinearConstants(line1[0], line1[1]);\n  });\n  var linearConstantss2 = lines2.map(function (line2) {\n    return getLinearConstants(line2[0], line2[1]);\n  });\n  var overlapInfos = [];\n  linearConstantss1.forEach(function (linearConstants1, i) {\n    var line1 = lines1[i];\n    var linePointInfos = [];\n    linearConstantss2.forEach(function (linearConstants2, j) {\n      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n      linePointInfos.push.apply(linePointInfos, points.map(function (pos) {\n        return {\n          index1: i,\n          index2: j,\n          pos: pos\n        };\n      }));\n    });\n    linePointInfos.sort(function (a, b) {\n      return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n    });\n    overlapInfos.push.apply(overlapInfos, linePointInfos);\n\n    if (isInside(line1[1], targetPoints2)) {\n      overlapInfos.push({\n        index1: i,\n        index2: -1,\n        pos: line1[1]\n      });\n    }\n  });\n  lines2.forEach(function (line2, i) {\n    if (isInside(line2[1], targetPoints1)) {\n      var isNext_1 = false;\n      var index = findIndex(overlapInfos, function (_a) {\n        var index2 = _a.index2;\n\n        if (index2 === i) {\n          isNext_1 = true;\n          return false;\n        }\n\n        if (isNext_1) {\n          return true;\n        }\n\n        return false;\n      });\n\n      if (index === -1) {\n        isNext_1 = false;\n        index = findIndex(overlapInfos, function (_a) {\n          var index1 = _a.index1,\n              index2 = _a.index2;\n\n          if (index1 === -1 && index2 + 1 === i) {\n            isNext_1 = true;\n            return false;\n          }\n\n          if (isNext_1) {\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      if (index === -1) {\n        overlapInfos.push({\n          index1: -1,\n          index2: i,\n          pos: line2[1]\n        });\n      } else {\n        overlapInfos.splice(index, 0, {\n          index1: -1,\n          index2: i,\n          pos: line2[1]\n        });\n      }\n    }\n  }); // console.log(overlapInfos);\n\n  var overlapPoints = overlapInfos.map(function (_a) {\n    var pos = _a.pos;\n    return pos;\n  });\n  var pointMap = {};\n  return overlapPoints.filter(function (point) {\n    var key = point[0] + \"x\" + point[1];\n\n    if (pointMap[key]) {\n      return false;\n    }\n\n    pointMap[key] = true;\n    return true;\n  });\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\n\n\nfunction getOverlapSize(points1, points2) {\n  var points = getOverlapPoints(points1, points2);\n  return getAreaSize(points);\n}\n\nexport { convertLines, fitPoints, getAreaSize, getIntersectionPoints, getIntersectionPointsByConstants, getLinearConstants, getMinMaxs, getOverlapPoints, getOverlapSize, getPointsOnLines, isInside };","map":{"version":3,"sources":["../src/index.ts"],"names":["getAreaSize","points","sum","nextPoint","i","point","fitPoints","rect","height","left","top","minX","minY","maxX","maxY","getMinMaxs","ratioX","width","ratioY","xs","ys","Math","isInside","pos","excludeLine","y","xLine","yLine","xLinearConstants","getLinearConstants","yLinearConstants","lines","convertLines","intersectionXPoints","intersectionYPoints","linearConstants","line","xPoints","getPointsOnLines","getIntersectionPointsByConstants","yPoints","point1","point2","y1","y2","x1","a_1","x2","b_1","linearConstants1","linearConstants2","b1","c1","b2","c2","isZeroA","a1","a2","isZeroB","x","getIntersectionPoints","line1","line2","isLimit","minMaxs","bottom","right","minMax","getOverlapPoints","points1","points2","targetPoints1","targetPoints2","getShapeDirection","lines1","lines2","linearConstantss1","linearConstantss2","overlapInfos","linePointInfos","intersectionPoints","index1","index2","getDist","a","b","isNext_1","index","findIndex","overlapPoints","pointMap","key","getOverlapSize"],"mappings":"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","sourcesContent":["import { sum, findIndex, getShapeDirection, getDist } from \"@daybrush/utils\";\nimport { PointInfo, Rect } from \"./types\";\n\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\nexport function getAreaSize(points: number[][]): number {\n    if (points.length < 3) {\n        return 0;\n    }\n    return Math.abs(sum(points.map((point, i) => {\n        const nextPoint = points[i + 1] || points[0];\n\n        return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n    }))) / 2;\n}\n\n\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\nexport function fitPoints(points: number[][], rect: Rect): number[][] {\n    const { width, height, left, top } = rect;\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const ratioX = width / (maxX - minX);\n    const ratioY = height / (maxY - minY);\n\n    return points.map(point => {\n        return [\n            left + (point[0] - minX) * ratioX,\n            top + (point[1] - minY) * ratioY,\n        ];\n    });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\nexport function getMinMaxs(points: number[][]): { minX: number, minY: number, maxX: number, maxY: number } {\n    const xs = points.map(point => point[0]);\n    const ys = points.map(point => point[1]);\n\n    return {\n        minX: Math.min(...xs),\n        minY: Math.min(...ys),\n        maxX: Math.max(...xs),\n        maxY: Math.max(...ys),\n    };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\nexport function isInside(pos: number[], points: number[][], excludeLine?: boolean): boolean {\n    const [x, y] = pos;\n    const {\n        minX,\n        minY,\n        maxX,\n        maxY,\n    } = getMinMaxs(points);\n\n    const xLine = [[minX, y], [maxX, y]];\n    const yLine = [[x, minY], [x, maxY]];\n    const xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n    const yLinearConstants = getLinearConstants(yLine[0], yLine[1]);\n    const lines = convertLines(points);\n    const intersectionXPoints: number[][] = [];\n    const intersectionYPoints: number[][] = [];\n\n    lines.forEach(line => {\n        const linearConstants = getLinearConstants(line[0], line[1]);\n        const xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n        const yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);\n\n        if (xPoints.length === 1 ? line[0][1] !== y : true) {\n            intersectionXPoints.push(...xPoints);\n        }\n        if (yPoints.length === 1 ? line[0][0] !== x : true) {\n            intersectionYPoints.push(...yPoints);\n        }\n\n        if (!linearConstants[0]) {\n            intersectionXPoints.push(...xPoints);\n        }\n        if (!linearConstants[1]) {\n            intersectionYPoints.push(...yPoints);\n        }\n    });\n\n    if (!excludeLine) {\n        if (\n            findIndex(intersectionXPoints, p => p[0] === x) > -1\n            || findIndex(intersectionYPoints, p => p[1] === y) > -1\n        ) {\n            return true;\n        }\n    }\n    if (\n        (intersectionXPoints.filter(p => p[0] > x).length % 2)\n        && (intersectionYPoints.filter(p => p[1] > y).length % 2)\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getLinearConstants(point1: number[], point2: number[]): [number, number, number] {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    // ax + by + c = 0\n    // [a, b, c]\n    let a = 0;\n    let b = 0;\n    let c = 0;\n\n    if (x1 === x2 && y1 === y2) {\n        return [0, 0, 0];\n    } if (x1 === x2) {\n        // x = x1\n        return [1, 0, -x1];\n    } else if (y1 === y2) {\n        // y = y1\n        return [0, 1, -y1];\n    } else {\n        // x1 + a * y1 + b = 0\n        // x2 + a * y2 + b = 0\n        // (x1 -x2) + (y1 - y2) * a = 0\n        // a = (x2 - x1) / (y1 - y2)\n        // x1 + (x2 - x1) / (y1 - y2)\n\n        const a = (x2 - x1) / (y1 - y2);\n        const b = -x1 - a * y1;\n        return [1, a, b];\n    }\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\nexport function getIntersectionPointsByConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n): number[][] {\n    const [a1, b1, c1] = linearConstants1;\n    const [a2, b2, c2] = linearConstants2;\n\n    const isZeroA = a1 === 0 && a2 === 0;\n    const isZeroB = b1 === 0 && b2 === 0;\n    if (isZeroA && isZeroB) {\n        return [];\n    } else if (isZeroA) {\n        // b1 * y + c1 = 0\n        // b2 * y + c2 = 0\n        const y1 = -c1 / b1;\n        const y2 = -c2 / b2;\n\n        if (y1 !== y2) {\n            return [];\n        } else {\n            return [\n                [-Infinity, y1],\n                [Infinity, y1],\n            ];\n        }\n    } else if (isZeroB) {\n        // a1 * x + c1 = 0\n        // a2 * x + c2 = 0\n        const x1 = -c1 / a1;\n        const x2 = -c2 / a2;\n\n        if (x1 !== x2) {\n            return [];\n        } else {\n            return [\n                [x1, -Infinity],\n                [x1, Infinity],\n            ];\n        }\n    } else if (a1 === 0) {\n        // b1 * y + c1 = 0\n        // y = - c1 / b1;\n        // a2 * x + b2 * y + c2 = 0\n        const y = -c1 / b1;\n        const x = -(b2 * y + c2) / a2;\n\n        return [[x, y]];\n    } else if (a2 === 0) {\n        // b2 * y + c2 = 0\n        // y = - c2 / b2;\n        // a1 * x + b1 * y + c1 = 0\n        const y = -c2 / b2;\n        const x = -(b1 * y + c1) / a1;\n\n        return [[x, y]];\n    } else if (b1 === 0) {\n        // a1 * x + c1 = 0\n        // x = - c1 / a1;\n        // a2 * x + b2 * y + c2 = 0\n        const x = - c1 / a1;\n        const y = -(a2 * x + c2) / b2;\n\n        return [[x, y]];\n    } else if (b2 === 0) {\n        // a2 * x + c2 = 0\n        // x = - c2 / a2;\n        // a1 * x + b1 * y + c1 = 0\n        const x = - c2 / a2;\n        const y = -(a1 * x + c1) / b1;\n\n        return [[x, y]];\n    } else {\n        // a1 * x + b1 * y + c1 = 0\n        // a2 * x + b2 * y + c2 = 0\n        // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n        // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n        // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n        const x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n        const y = -(a1 * x + c1) / b1;\n\n        return [[x, y]];\n    }\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\nexport function getIntersectionPoints(\n    line1: number[][],\n    line2: number[][],\n    isLimit?: boolean,\n): number[][] {\n    const points = getIntersectionPointsByConstants(\n        getLinearConstants(line1[0], line1[1]),\n        getLinearConstants(line2[0], line2[1]),\n    );\n\n    if (isLimit) {\n        return getPointsOnLines(points, [line1, line2]);\n    }\n    return points;\n}\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\nexport function getPointsOnLines(\n    points: number[][],\n    lines: number[][][],\n): number[][] {\n    const minMaxs = lines.map(line => [0, 1].map(order => [\n        Math.min(line[0][order], line[1][order]),\n        Math.max(line[0][order], line[1][order]),\n    ]));\n    if (points.length === 2) {\n        const [x, y] = points[0];\n        if (x === points[1][0]) {\n            /// Math.max(minY1, minY2)\n            const top = Math.max(...minMaxs.map(minMax => minMax[1][0]));\n            /// Math.min(maxY1, miax2)\n            const bottom = Math.min(...minMaxs.map(minMax => minMax[1][1]));\n\n            if (top > bottom) {\n                return [];\n            }\n            return [\n                [x, top],\n                [x, bottom],\n            ];\n        } else if (y === points[1][1]) {\n            /// Math.max(minY1, minY2)\n            const left = Math.max(...minMaxs.map(minMax => minMax[0][0]));\n            /// Math.min(maxY1, miax2)\n            const right = Math.min(...minMaxs.map(minMax => minMax[0][1]));\n\n            if (left > right) {\n                return [];\n            }\n            return [\n                [left, y],\n                [right, y],\n            ];\n        }\n    }\n\n    return points.filter(point => {\n        return minMaxs.every(minMax => {\n            return (minMax[0][0] <= point[0] && point[0] <= minMax[0][1])\n                && (minMax[1][0] <= point[1] && point[1] <= minMax[1][1]);\n        });\n    });\n\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\nexport function convertLines(points: number[][]): number[][][] {\n    return [...points.slice(1), points[0]].map((point, i) => [points[i], point]);\n}\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapPoints(points1: number[][], points2: number[][]): number[][] {\n    const targetPoints1 = points1.slice();\n    const targetPoints2 = points2.slice();\n\n    if (getShapeDirection(targetPoints1) === -1) {\n        targetPoints1.reverse();\n    }\n    if (getShapeDirection(targetPoints2) === -1) {\n        targetPoints2.reverse();\n    }\n    const lines1 = convertLines(targetPoints1);\n    const lines2 = convertLines(targetPoints2);\n    const linearConstantss1 = lines1.map(line1 => getLinearConstants(line1[0], line1[1]));\n    const linearConstantss2 = lines2.map(line2 => getLinearConstants(line2[0], line2[1]));\n\n    const overlapInfos: Array<{\n        index1: number;\n        index2: number;\n        pos: number[];\n    }> = [];\n\n    linearConstantss1.forEach((linearConstants1, i) => {\n        const line1 = lines1[i];\n        const linePointInfos: PointInfo[] = [];\n        linearConstantss2.forEach((linearConstants2, j) => {\n            const intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n            const points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n\n            linePointInfos.push(...points.map(pos => ({\n                index1: i,\n                index2: j,\n                pos,\n            })));\n        });\n        linePointInfos.sort((a, b) => {\n            return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n        });\n\n        overlapInfos.push(...linePointInfos);\n\n        if (isInside(line1[1], targetPoints2)) {\n            overlapInfos.push({\n                index1: i,\n                index2: -1,\n                pos: line1[1],\n            });\n        }\n    });\n\n    lines2.forEach((line2, i) => {\n        if (isInside(line2[1], targetPoints1)) {\n            let isNext = false;\n            let index = findIndex(overlapInfos, ({ index2 }) => {\n                if (index2 === i) {\n                    isNext = true;\n                    return false;\n                }\n\n                if (isNext) {\n                    return true;\n                }\n                return false;\n            });\n            if (index === -1) {\n                isNext = false;\n                index = findIndex(overlapInfos, ({ index1, index2 }) => {\n                    if (index1 === -1 && index2 + 1 === i) {\n                        isNext = true;\n                        return false;\n                    }\n\n                    if (isNext) {\n                        return true;\n                    }\n                    return false;\n                });\n            }\n            if (index === -1) {\n                overlapInfos.push({\n                    index1: -1,\n                    index2: i,\n                    pos: line2[1],\n                });\n            } else {\n                overlapInfos.splice(index, 0, {\n                    index1: -1,\n                    index2: i,\n                    pos: line2[1],\n                });\n            }\n        }\n    });\n    // console.log(overlapInfos);\n    const overlapPoints = overlapInfos.map(({ pos }) => pos);\n    const pointMap: Record<string, boolean> = {};\n\n    return overlapPoints.filter(point => {\n        const key = `${point[0]}x${point[1]}`;\n\n        if (pointMap[key]) {\n            return false;\n        }\n        pointMap[key] = true;\n        return true;\n    });\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapSize(points1: number[][], points2: number[][]): number {\n    const points = getOverlapPoints(points1, points2);\n\n    return getAreaSize(points);\n}\n"]},"metadata":{},"sourceType":"module"}